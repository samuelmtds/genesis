<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><title>genesis - Modelo de componentes de negócio</title><style type="text/css" media="all">
          @import url("../style/maven-base.css");
          
			    @import url("../style/maven-theme.css");</style><link rel="stylesheet" href="../style/print.css" type="text/css" media="print"></link><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta><meta name="author" content="Michael Nascimento Santos"></meta><meta name="email" content="mister__m@dev.java.net"></meta></head><body class="composite"><div id="banner"><a href="https://genesis.dev.java.net/" id="projectLogo"><img alt="SOL Genesis" src="../genesis.gif"></img></a><div class="clear"><hr></hr></div></div><div id="breadcrumbs"><div class="xleft">
                	Last published: 13 March 2005
                  | Doc for 3.0-EA1</div><div class="xright">
        
        <a href="../index.html">genesis</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-server/index.html">genesis-server</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-client/index.html">genesis-client</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-shared/index.html">genesis-shared</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-aspect/index.html">genesis-aspect</a>
      </div><div class="clear"><hr></hr></div></div><div id="leftColumn"><div id="navcolumn"><div id="menugenesis"><h5>genesis</h5><ul><li class="none"><a href="../pt-BR/index.html">Visão geral</a></li><li class="none"><a href="../pt-BR/screenshots.html">Screenshots</a></li><li class="none"><a href="../pt-BR/download.html">Downloads</a></li><li class="none"><a href="../pt-BR/release_notes.html">Notas de versão</a></li></ul></div><div id="menuDocumentação"><h5>Documentação</h5><ul><li class="expanded"><a href="../pt-BR/documentation_intro.html">Manual do usuário</a><ul><li class="none"><a href="../pt-BR/documentation_intro.html">Introdução</a></li><li class="collapsed"><a href="../pt-BR/ui_basic_concepts.html">Modelo de componentes de interface gráfica</a></li><li class="none"><strong><a href="../pt-BR/business_component_model.html">Modelo de componentes de negócio</a></strong></li><li class="none"><a href="../pt-BR/quick_reference.html">Guia de referência rápida de anotações</a></li></ul></li><li class="none"><a href="../pt-BR/jars_explained.html">Entendendo os jars do genesis</a></li><li class="none"><a href="../pt-BR/empty_project.html">Desenvolvendo com o genesis</a></li><li class="none"><a href="../pt-BR/useradmin_sample.html">Usando o exemplo UserAdmin</a></li><li class="collapsed"><a href="../pt-BR/advanced_introduction.html">Guia avançado</a></li><li class="none"><a href="../pt-BR/faq.html">FAQ</a></li><li class="none"><a href="http://wiki.java.net/bin/view/Projects/GenesisRoadmap" class="externalLink" title="External Link">Roadmap</a></li><li class="none"><a href="http://wiki.java.net/bin/view/Projects/Genesis" class="externalLink" title="External Link">Wiki</a></li></ul></div><div id="menuProject_Documentation"><h5>Project Documentation</h5><ul><li class="none"><a href="../index.html">About SOL Genesis</a></li><li class="collapsed"><a href="../project-info.html">Project Info</a></li><li class="collapsed"><a href="../maven-reports.html">Project Reports</a></li><li class="none"><a href="http://maven.apache.org/development-process.html" class="externalLink" title="External Link">Development Process</a></li></ul></div><div id="menujava_net"><h5>java.net</h5><ul><li class="none"><a href="https://genesis.dev.java.net" class="externalLink" title="External Link">genesis.dev.java.net</a></li><li class="none"><a href="http://java.net" class="externalLink" title="External Link"><img title="java.net member" style="border: 1px" src="../java_dot_net_member.bmp" alt="java.net member"></img></a></li></ul></div><a href="http://maven.apache.org/" title="Built by Maven" id="poweredBy"><img alt="Built by Maven" src="../images/logos/maven-button-1.png"></img></a></div></div><div id="bodyColumn"><div class="contentBox"><div class="section"><a name="Modelo_de_componentes_de_negócio"></a><h2>Modelo de componentes de negócio</h2><p>O modelo de componentes de negócio do genesis é bastante simples de ser
      compreendido. Os seguintes conceitos e/ou características são
      abordados abaixo:
      <ul>
        <li><a href="#Uso_das_classes_de_negócio_no_cliente">Uso das classes de
        negócio no cliente</a></li>
        <li><a href="#Remotabilidade_transparente">Remotabilidade transparente
        </a></li>
        <li><a href="#Suporte_a_transações">Suporte a transações</a></li>
        <li><a href="#Integração_com_o_Hibernate">Integração com o Hibernate</a>
        </li>
        <li><a href="#Paginação">Paginação</a></li>
        <li><a href="#Pesquisas_dinâmicas_com_Criteria">Pesquisas dinâmicas com
        Criteria</a></li>
      </ul>
      </p></div><div class="section"><a name="Uso_das_classes_de_negócio_no_cliente"></a><h2>Uso das classes de negócio no cliente</h2><p>O uso de uma classe de negócio do genesis no código cliente não impõe
      nenhuma restrição. Isto significa que:
      <ul>
        <li>Não é necessário criar uma interface para sua classe de negócio por
        causa do genesis. Outros fatores de boa orientaçào a objetos podem levar
        a isso, mas não o framework.</li>
        <li>Para se obter uma instância de uma das classes, basta usar <code>new
        </code> ou qualquer outro recurso OO ou Java que já seria usado (uma
        Factory, por exemplo, ou reflection).</li>
        <li>Não é necessário notificar ao framework que certa instância deve ser
        gerenciada por ele. A única configuração requerida pelo genesis
        atualmente é a configuração dos aspectos, feita uma vez no <code>aop.xml
        </code>. Esta configuração pode ser copiada dos exemplos e se precisar
        ser alterada, isso provavelmente só ocorrerá uma vez.</li>
      </ul>
      </p></div><div class="section"><a name="Remotabilidade_transparente"></a><h2>Remotabilidade transparente</h2><p>Suponhamos que exista uma classe chamada <code>ExemploSoma</code>
      como abaixo:</p>
    <div class="source"><pre>
 1. public class ExemploSoma {
 2.    public int soma(int a, int b) {
 3.       System.out.println("a = " + a);
 4.       System.out.println("b = " + b);
 5.
 6.       int soma = a + b;
 7.
 8.       System.out.println("a + b = " + soma);
 9.
10.       return soma;
11.    }
12.
13.    public static void main(String[] args) {
14.       System.out.println(new ExemploSoma().soma(2, 2));
15.    }
16. }
</pre></div>
  <p>Ao executar esse código, a seguinte saída é impressa no console local:
      </p>
    <div class="source"><pre>
a = 2
b = 2
a + b = 4
4
</pre></div>
  <p>Pode-se tornar o método <code>soma(int, int)</code> remoto apenas por
      se acrescentar a anotação <code>@Remotable</code>. O código
      modificado ficaria da seguinte forma:</p>
    <div class="source"><pre>
 1. public class ExemploSomaRemota {
 2.    /**
 3.     * @Remotable
 4.     */
 5.    public int soma(int a, int b) {
 6.       System.out.println("a = " + a);
 7.       System.out.println("b = " + b);
 8.
 9.       int soma = a + b;
10.
11.       System.out.println("a + b = " + soma);
12.
13.       return soma;
14.    }
15.
16.    public static void main(String[] args) {
17.       System.out.println(new ExemploSomaRemota().soma(2, 2));
18.    }
19. }
</pre></div>
  <p>Executando-se o novo código com o JBoss iniciado, observa-se uma
      redução na saída no console
      local:</p>
    <div class="source"><pre>
4
</pre></div>
  <p>Ao observar o console do JBoss, pode-se notar que as mensagens
      anteriores foram impressas no servidor. Por que isso acontece?</p><p>A saída observada no console local equivale ao resultado da execução
      da linha 17. Porém, as outras instruções de <code>System.out.println</code> das linhas 6, 7 e 11 encontram-se dentro de um método anotado como <code>@Remotable</code> e por isso são executadas de forma diferente. Na
      verdade, todo o método <code>soma(int,int)</code> passou a ser executado
      no servidor. Como?</p><p>Métodos anotados com <code>@Remotable</code> são interceptados através
      de um aspecto (genesis-aspect) que transfere a instância em que o método
      foi invocado para o servidor, executando-o ali e transferindo o resultado
      de volta para o cliente. Essa característica é chamada de
      <b>remotabilidade transparente</b>.</p><div class="subsection"><a name="Restrições_e_limitações"></a><h3>Restrições e limitações</h3><p>Existem algumas restrições básicas para que um método possa ser
        remoto no genesis:
        <ul>
          <li>Não pode ser abstrato</li>
          <li>Não pode ser estático nem manipular membros estáticos</li>
          <li>Não pode ser nativo</li>
          <li>Deve ser <code>public</code> e estar em uma classe
          <code>public</code></li>
        </ul>
        </p><p>A primeira existe porque um método abstrato não pode ser invocado
        (ele pode ser abstrato na superclasse, no entanto). O método não pode
        ser estático pela simples razão que valores estáticos divergem entre
        JVMs, enquanto a instância pode ser transferida para o servidor durante
        cada execução. As duas últimas restrições existem para manter
        compatibilidade com a especificação EJB.</p><p>Um último efeito colateral a ser notado é que variáveis de instância
        atualizadas em métodos remotos não afetam seus valores locais. Abaixo
        vemos um breve exemplo disso:</p>
    <div class="source"><pre>
 1. public class LocalVersusRemoto {
 2.    private int valor;
 3.
 4.    public void local() {
 5.       valor++;
 6.       System.out.println("valor em local(): " + valor);
 7.    }
 8.
 9.    /**
10.     * @Remotable
11.     */
12.    public void remoto() {
13.       valor++;
14.       System.out.println("valor em remoto(): " + valor);
15.    }
16.
17.    public int getValor() {
18.       return valor;
19.    }
20.
21.    public static void main(String[] args) {
22.       LocalVersusRemoto lvr = new LocalVersusRemoto();
23.       lvr.local();
24.       System.out.println("valor: " + lvr.getValor());
25.       lvr.remoto();
26.       System.out.println("valor: " + lvr.getValor());
27.       lvr.local();
28.       System.out.println("valor: " + lvr.getValor());
29.    }
30. }
</pre></div>
  <p>A saída no console local é:</p>
    <div class="source"><pre>
valor em local(): 1
valor: 1
valor: 1
valor em local(): 2
valor: 2
</pre></div>
  <p>enquanto no console remoto é:</p>
    <div class="source"><pre>
valor em remoto(): 2
</pre></div>
  <p>Ao se executar a linha 23, a variável <code>valor</code> é modificada
        localmente e seu conteúdo tanto dentro do método <code>local()</code>
        como o impresso na linha 24 são os mesmos. Porém, ao se executar a linha
        25 a instância <code>lvr</code> é transferida para o servidor e o método
        <code>remoto()</code> é executado nela, alterando a cópia remota de
        <code>valor</code> de 1 para 2, conforme exibido no console remoto,
        mantendo, no entanto, sua cópia local intacta como notamos na linha 26
        (console local).</p><p>De modo que valores locais são transferidos para o servidor, mas não
        ao contrário. O mesmo se aplica a objetos passados como parâmetros. Se
        quiser obter a cópia modificada do servidor retorne-a diretamente a
        partir do método anotado como <code>@Remotable</code>.</p><p>Para corrigir o problema no método anterior, basta alterá-lo para
        retornar o novo valor:</p>
    <div class="source"><pre>
    /**
     * @Remotable
     */
    public int remoto() {
       valor++;
       System.out.println("valor em remoto(): " + valor);
       return valor;
    }

    public void setValor(int valor) {
       this.valor = valor;

    }

    public static void main(String[] args) {
       LocalVersusRemoto lvr = new LocalVersusRemoto();
       // ...
       lvr.setValor(lvr.remoto());
       // ...
    }
</pre></div>
  <p>Isso pode intimidar alguns inicialmente, mas é exatamente como
        funciona um Stateless Session Bean (SSB), por exemplo, ou o
        comportamento de parâmetros não-remotos passados a uma chamada RMI.
        Um modelo de componentes com estado (stateful) deve ser implementado
        futuramente, provavelmente na release 3.0, embora a experiência nos
        tenha mostrado que isto não é necessário para clientes desktop e web,
        bastando lidar com o problema da mesma forma que se lida com o ele
        usando-se SSBs ou componentes RMI: retornando os dados alterados no
        método.</p></div></div><div class="section"><a name="Suporte_a_transações"></a><h2>Suporte a transações</h2><p>Para executar um método dentro de uma transação, basta usar a anotação
      <code>@Transactional</code> de forma similar ao uso de <code>@Remotable
      </code>, como abaixo:</p>
    <div class="source"><pre>
/**
 * @Transactional
 */
public void metodoTransacional() {
   // codigo do metodo
}
</pre></div>
  <p>O uso de <code>@Transactional</code> automaticamente implica em tornar
      um método <code>@Remotable</code>, de modo que o uso de apenas uma dessas
      anotações por método é necessário. Além de manter as características de
      remotabilidade transparente, <code>@Transactional</code> faz com que o
      método seja executado dentro de uma transação JTA. Quaisquer recursos
      transacionais que sejam acessados durante sua execução e tenham suporte a
      JTA serão automaticamente incluídos na transação. O contexto transacional
      se propagará automaticamente para qualquer outro componente ou método que
      for invocado durante a execução do método <code>@Transactional</code>, sem
      que nenhuma programação adicional tenha de ser feita para isso.</p><p>Se a execução do método transcorrer normalmente, a transação será
      automaticamente comitada ao final. Caso seja lançada qualquer exceção
      haverá rollback automático das alterações e a exceção será propagada
      diretamente ao código cliente.</p></div><div class="section"><a name="Integração_com_o_Hibernate"></a><h2>Integração com o Hibernate</h2><p>O genesis provê uma ótima integração com o Hibernate para os
      componentes de negócio. Atualmente, para tirar proveito dela, a classe
      deve implementar a interface <code>
      net.java.dev.genesis.command.hibernate.HibernateCommand</code> diretamente
      ou através de introduction. Futuramente essa limitação será removida,
      provavelmente na versão 3.0.</p><p>Essa interface expõe o método <code>setSession(Session)</code> que é
      invocado automaticamente pelo framework no servidor antes da execução de
      cada método remoto injetando uma sessão válida e após com o valor <code>
      null</code>, para liberar a referência. Para facilitar o uso dessa
      integração na maior parte dos casos, é provida uma classe, <code>
      net.java.dev.genesis.command.hibernate.AbstractHibernateCommand</code> que
      implementa a interface e possui métodos úteis como <code>getSession()
      </code>.</p><p>Abaixo temos um exemplo de como utilizar essa integração num componente
      de negócios:</p>
    <div class="source"><pre>
public class ExemploIntegracaoHibernate extends AbstractHibernateCommand {
   /**
    * @Remotable
    */
   public Collection getTodos() throws HibernateException {
      return getSession().createQuery("from ClasseMapeada").list();
   }
}
</pre></div>
  <p>Como o exemplo acima mostra, utilizar o Hibernate em conjunto com suas
      classes de negócio é bastante simples e direto.</p></div><div class="section"><a name="Paginação"></a><h2>Paginação</h2><p>O suporte à paginação está implementado no pacote <code>
      net.java.dev.genesis.paging</code>. As duas classes principais são <code>
      Page</code>, que representa uma página de resultados e <code>Pager</code>,
      que é responsável por gerar as páginas.</p><p>As seguintes propriedades estão expostas em <code>Page</code> através
      de getters e setters:
      <ul>
        <li><b>results</b>: uma <code>java.util.List</code> contendo os
        resultados da página atual.</li>
        <li><b>resultsPerPage</b>: número máximo de resultados por página. <b>
        Não contém</b> o número de resultados da página atual; para obter essa
        informação deve-se chamar o método <code>size()</code> em <code>results
        </code>.</li>
        <li><b>pageNumber</b>: número da página atual, baseado em 0.</li>
        <li><b>first</b>: indica se esta é a primeira página. O mesmo que <code>getPageNumber() == 0</code>.</li>
        <li><b>last</b>: indica se esta é a última página. Algumas
        implementações de <code>Pager</code> podem não retornar essa
        propriedade como <code>true</code> quando a última página contiver
        exatamente o número de resultados por página, ou seja, quando
        <code>getResults().size() == getResultsPerPage()</code>.</li>
      </ul></p><p>Enquanto há uma implementação básica para <code>Page</code> (<code>
      PageImpl</code>), não se tem o mesmo para <code>Pager</code>, visto que a
      funcionalidade de um paginador está bastante ligada à origem dos dados que
      este está paginando. Aplicações cliente normalmente não usarão <code>
      PageImpl</code> nem tampouco terão sua própria implementação de <code>Page
      </code>, mas a implementação provida pelo framework pode ser bastante útil
      para implementações específicas de <code>Pager</code>.</p><div class="subsection"><a name="Paginação_com_Hibernate"></a><h3>Paginação com Hibernate</h3><p>Duas implementação de <code>Pager</code> são providas junto com o
        genesis para integração com Hibernate: <code>CriteriaPager</code> e
        <code>QueryPager</code>, implementados em <code>
        net.java.dev.genesis.paging.hibernate</code>. Essas classes podem tanto
        ser usadas diretamente como de forma mais fácil e indireta em uma classe
        que estenda <code>AbstractHibernateCommand</code>. Como ilustração,
        vamos modificar nosso exemplo do Hibernate de modo a executar a consulta
        retornando uma página:</p>
    <div class="source"><pre>
public class ExemploPaginacaoHibernate extends AbstractHibernateCommand {
   /**
    * @Remotable
    */
   public Page getTodos(int numeroPagina, int resultadosPorPagina)
         throws PagingException {
      return getPage(getSession().createQuery("from ClasseMapeada"),
            numeroPagina, resultadosPorPagina);
   }
}
</pre></div>
  <p>Para se obter as instâncias de <code>ClasseMapeada</code> de dentro
        da página retornada, basta apenas chamar <code>getResults()</code> no
        objeto <code>Page</code> retornado. Essa <code>List</code> - <code>
        getResults()</code> retorna uma <code>List</code>, conforme explicado
        nas propriedades de <code>Page</code>, logo acima - sempre conterá
        elementos do mesmo tipo que estariam presentes numa chamada a <code>
        query.list()</code> ou <code> criteria.list()</code>.</p></div></div><div class="section"><a name="Pesquisas_dinâmicas_com_Criteria"></a><h2>Pesquisas dinâmicas com Criteria</h2><p>Embora o Hibernate possua suporte a pesquisas dinâmicas, isto é, com
      cláusulas "montadas" ou definidas em tempo de execução através da
      interface <code>Criteria</code>, o uso prático desse suporte básico leva a
      código bastante repetitivo e difícil de manter. O genesis possui suporte a
      pesquisas dinâmicas num nível de abstração mais alto, o que facilita a
      implementação delas. Abordaremos aqui o uso desse suporte com foco na
      camada de negócios.</p><p>Existe uma subinterface de <code>HibernateCommand</code> chamada <code>
      HibernateCriteria</code>. Assim como a <code>Session</code> é injetada
      para instâncias de <code>HibernateCommand</code>, uma instância de
      <code>Criteria</code> é atribuída através do método
      <code>setCriteria(Criteria)</code> para implementações de
      <code>HibernateCriteria</code> nos momentos apropriados. Da mesma forma
      que ocorre com a primeira interface, existe uma classe base para facilitar
      a implementação de <code>HibernateCriteria</code>,
      <code>AbstractHibernateCriteria</code>. Esta classe auxiliar define o
      método <code>getCriteria()</code>, além de outros métodos utilitários.</p><p>O método de negócio que precisa da instância de <code>Criteria</code>
      para sua execução recebe a anotação <code>@Criteria
      &lt;NomeDaClasseMapeadaNoHibernate&gt; &lt;order-by=propriedades&gt;</code>.
      Essa anotação implica que o método também é <code>@Remotable</code>,
      mantendo assim a remotabilidade transparente. Antes de invocar este
      método e depois de ter invocado <code>setCriteria(Criteria)</code>, os
      setters das propriedades "preenchidas" do objeto de negócio que tenham
      sido copiadas no cliente (ver documentação do
      <a href="ui_additional_features.html">modelo de componentes para interface
      gráfica</a>) serão automaticamente chamados
      pelo framework de modo que a recém-injetada instância de
      <code>Criteria</code> possa ser configurada apropriadamente. Finalmente o
      método de negócios será invocado e seu retorno repassado ao código
      cliente.</p><p>Para entender melhor esse conceito, o exemplo abaixo pode ser de ajuda.
      Supondo-se que existe uma classe <code>Pessoa</code> mapeada via
      Hibernate, que, entre outros atributos, possua <code>nome</code> e <code>
      sobrenome</code>, que são os critérios de pesquisa, podemos implementar
      uma pesquisa dinâmica e paginada sobre a classe da seguinte forma:</p>
    <div class="source"><pre>
public class PesquisaPessoa extends AbstractHibernateCriteria {
   public void setNome(String nome) {
      getCriteria().add(Expression.ilike("nome", nome, MatchMode.START));
   }

   public void setSobrenome(String sobrenome) {
      getCriteria().add(Expression.ilike("sobrenome", sobrenome,
            MatchMode.START));
   }

   /**
    * @Criteria Pessoa order-by=nome, sobrenome asc
    */
   public Page getPessoas(int numeroPagina) throws PagingException {
      return getPage(getCriteria(), numeroPagina);
   }
}
</pre></div>
  <p>Uma vez tendo copiado as propriedades do formulário para o objeto de
      negócios (conforme explicado na documentação do <a href="ui_additional_features.html">modelo cliente</a>), a seguinte seqüência de
      eventos ocorre quando o método <code>getPessoas(int)</code> é invocado:
      <ul>
        <li>A instância é transferida pelo servidor através da remotabilidade
        transparente.</li>
        <li>É injetada a sessão do Hibernate através da chamada a <code>
        setSession(Session)</code>, definida em <code>HibernateCommand</code>.
        </li>
        <li>É criado um <code>Criteria</code> tendo como base a entidade
        persistente <code>Pessoa</code>, conforme informado na anotação <code>
        @Criteria</code>.</li>
        <li>A instância de <code>Criteria</code> é injetada através de chamada a
        <code>setCriteria(Criteria)</code>, definido em <code>HibernateCriteria
        </code>.</li>
        <li>Os setters das propriedades que estavam preenchidas no form no
        momento da cópia são chamados. A classe <code>PesquisaPessoa</code> tem
        então a chance de restringir o <code>Criteria</code> somente para os
        campos de busca, sem ter de se preocupar se o campo foi preenchido ou
        não, já que o genesis garante que se o setter foi chamado, o campo foi
        preenchido.</li>
        <li>Finalmente, o método <code>getPessoas(int)</code> é chamado e o
        resultado retornado para o cliente de forma transparente.</li>
      </ul>
      </p><p>É possível utilizar a anotação sem informar o nome da classe mapeada no
      Hibernate. Neste caso, a instância de <code>Criteria</code> não será
      criada e o valor injetado na classe será <code>null</code>, mas o resto do
      comportamento descrito acima será mantido. Isto é útil quando é necessário
      realizar pesquisas dinâmicas complexas que não podem ser implementadas com
      <code>Criteria</code>.</p></div></div></div><div class="clear"><hr></hr></div><div id="footer"><div class="xright">© 2004-2005, Summa Tecnologies do Brasil Ltda.</div><div class="clear"><hr></hr></div></div></body></html>