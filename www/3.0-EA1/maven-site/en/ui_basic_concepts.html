<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><title>genesis - User interface component model</title><style type="text/css" media="all">
          @import url("../style/maven-base.css");
          
			    @import url("../style/maven-theme.css");</style><link rel="stylesheet" href="../style/print.css" type="text/css" media="print"></link><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta><meta name="author" content="Michael Nascimento Santos"></meta><meta name="email" content="mister__m@dev.java.net"></meta></head><body class="composite"><div id="banner"><a href="https://genesis.dev.java.net/" id="projectLogo"><img alt="SOL Genesis" src="../genesis.gif"></img></a><div class="clear"><hr></hr></div></div><div id="breadcrumbs"><div class="xleft">
                	Last published: 13 March 2005
                  | Doc for 3.0-EA1</div><div class="xright">
        
        <a href="../index.html">genesis</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-server/index.html">genesis-server</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-client/index.html">genesis-client</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-shared/index.html">genesis-shared</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-aspect/index.html">genesis-aspect</a>
      </div><div class="clear"><hr></hr></div></div><div id="leftColumn"><div id="navcolumn"><div id="menugenesis"><h5>genesis</h5><ul><li class="none"><a href="../en/index.html">Overview</a></li><li class="none"><a href="../en/screenshots.html">Screenshots</a></li><li class="none"><a href="../en/download.html">Downloads</a></li><li class="none"><a href="../en/release_notes.html">Release notes</a></li></ul></div><div id="menuDocumentation"><h5>Documentation</h5><ul><li class="expanded"><a href="../en/documentation_intro.html">User manual</a><ul><li class="none"><a href="../en/documentation_intro.html">Introduction</a></li><li class="expanded"><strong><a href="../en/ui_basic_concepts.html">UI component model</a></strong><ul><li class="none"><strong><a href="../en/ui_basic_concepts.html">Basic concepts</a></strong></li><li class="none"><a href="../en/ui_additional_features.html">Additional features</a></li></ul></li><li class="none"><a href="../en/business_component_model.html">Business component model</a></li><li class="none"><a href="../en/quick_reference.html">Annotation quick reference guide</a></li></ul></li><li class="none"><a href="../en/jars_explained.html">Understanding genesis jars</a></li><li class="none"><a href="../en/empty_project.html">Developing with genesis</a></li><li class="none"><a href="../en/useradmin_sample.html">Using the UserAdmin sample</a></li><li class="collapsed"><a href="../en/advanced_introduction.html">Advanced guide</a></li><li class="none"><a href="../en/faq.html">FAQ</a></li><li class="none"><a href="http://wiki.java.net/bin/view/Projects/GenesisRoadmap" class="externalLink" title="External Link">Roadmap</a></li><li class="none"><a href="http://wiki.java.net/bin/view/Projects/Genesis" class="externalLink" title="External Link">Wiki</a></li></ul></div><div id="menuProject_Documentation"><h5>Project Documentation</h5><ul><li class="none"><a href="../index.html">About SOL Genesis</a></li><li class="collapsed"><a href="../project-info.html">Project Info</a></li><li class="collapsed"><a href="../maven-reports.html">Project Reports</a></li><li class="none"><a href="http://maven.apache.org/development-process.html" class="externalLink" title="External Link">Development Process</a></li></ul></div><div id="menujava_net"><h5>java.net</h5><ul><li class="none"><a href="https://genesis.dev.java.net" class="externalLink" title="External Link">genesis.dev.java.net</a></li><li class="none"><a href="http://java.net" class="externalLink" title="External Link"><img title="java.net member" style="border: 1px" src="../java_dot_net_member.bmp" alt="java.net member"></img></a></li></ul></div><a href="http://maven.apache.org/" title="Built by Maven" id="poweredBy"><img alt="Built by Maven" src="../images/logos/maven-button-1.png"></img></a></div></div><div id="bodyColumn"><div class="contentBox"><div class="section"><a name="Basic_concepts_about_UI_components"></a><h2>Basic concepts about UI components</h2><p>genesis' UI component model is quite expressive yet simple and is
      mostly based on <b>annotation</b> usage. These annotations are not
      interpreted as Tiger medatata, as defined by JSR-175, but are used in a
      way similar to XDoclet tags. Examples provided below will make their use
      clear.</p><p>The following features and/or concepts are explained below:
      <ul>
        <li><a href="#Configuring_genesis_at_startup">Configuring genesis at
        startup</a></li>
        <li><a href="#UI_component_types">UI component types</a></li>
        <li><a href="#Understanding_views">Understanding views</a></li>
        <li><a href="#Using_auxiliary_UI_classes">Using auxiliary UI classes</a>
        </li>
        <li><a href="#Understanding_forms">Understanding forms</a></li>
        <li><a href="#Implementing_actions_in_forms_and_views">Implementing
        actions in forms and views</a></li>
      </ul>
      </p></div><div class="section"><a name="Configuring_genesis_at_startup"></a><h2>Configuring genesis at startup</h2><p>Several components must be initialized and/or configured so that
      genesis works properly. In order to make this process easier, genesis
      contains the class named
      <code>net.java.dev.genesis.helpers.StartupHelper</code>. This class
      encapsulates the steps that would be manually performed, but that tend to
      be very similar for most applications</p><p>Most of the times, the only thing required is to add the following line
      to your application startup code (probably the
      <code>main(String[] args)</code> method of one of the classes):</p>
    <div class="source"><pre>
new StartupHelper().initialize();
</pre></div>
  <p>It is important to notice that this class needs to be executed before
      using any other genesis API in your application. The default
      initialization process performed by this instruction is the following:</p><ul>
        <li>commons-beanutils configuration, so it is consistent with genesis
        API</li>
        <li>commons-jxpath configuration, in order to support conditional
        expressions</li>
        <li>Registration of default converters and formatters, needed to
        integrate Java components and the graphical API</li>
        <li>Execution of a simple empty business class,
        <code>net.java.dev.genesis.command.NoopCommand</code>, in a background
        thread, just to initialize aspects and connect to the application server
        without blocking the application.</li>
        <li>Validation rules are loaded by a background thread in order to have
        them ready when they are needed.</li>
      </ul><p>All points in this process may be customized by calling method exposed
      by <code>StartupHelper</code>, what allows this class to be useful in
      almost all scenarios. For example, if an application does not communicate
      with a application server or will perform this anyway right after its
      initialization, <code>NoopCommand</code> execution can be turned off by
      doing:</p>
    <div class="source"><pre>
StartupHelper helper = new StartupHelper();
helper.setRunNoopCommand(false);
helper.initialize();
</pre></div>
  <p><code>StartupHelper</code> registers a converter and a formatter for
      <code>java.util.Date</code> according to a specific data format and
      <code>java.util.Locale</code> instance. By default, their values are the
      constant <code>MM/dd/yyyy</code> and the JVM default <code>Locale</code>,
      but there is an overloaded constructor that allow us to specify them
      directly:</p>
    <div class="source"><pre>
new StartupHelper(new Locale("pt", "BR"), "dd/MM/yyyy");
</pre></div>
  <p>By default, <code>StartupHelper</code> loads all validation rules
      If validation is not being used by the application, this pre-loading
      process should be turned off as showed below:</p>
    <div class="source"><pre>
StartupHelper helper = new StartupHelper();
helper.setLoadValidatorRules(false);
helper.initialize();
</pre></div>
  </div><div class="section"><a name="UI_component_types"></a><h2>UI component types</h2><p>In order to make client code simple and testable, two types of
      components are combined to produce a user interface (UI): a <b>View</b>
      and a <b>Form</b>. A view is a class that performs operations that are
      specific to a graphical API, while a form is a simple JavaBean that
      contains interface logic and is not coupled to a graphical API. A form may
      even be reused with a different API.</p><p>It is important to notice that the fact a form is not coupled to a
      graphical API and is just a JavaBean has several useful consequences to a
      developer, such as:</p><ul>
          <li>It's possible to write unit tests for business logic.</li>
          <li>A form may extend any class and inheritance may be used to share
          common characteristics.</li>
          <li>Clear separation of concerns motivates developers to program in a
          clear, understandable way.</li>
          <li>The same unmodified form might be used together with a Swing UI as
          soon as genesis supports it.</li>
        </ul><p>This proposed architecture, as cited on the last item, allows the same
      form model to be used in several views. Currently genesis supports Thinlet
      as its sole view implementation model, but future versions will provide
      support for Swing and even Thinlet for PersonalJava-compatible PDAs.</p></div><div class="section"><a name="Understanding_views"></a><h2>Understanding views</h2><p>Views are tightly coupled to the graphical API being used. Thinlet
      support is implemented in genesis in two classes that are part of the
      <code>net.java.dev.genesis.ui.thinlet</code> package:
      <code>BaseThinlet</code> and its subclass <code>BaseDialogThinlet</code>.
      </p><p><code>BaseThinlet</code> extends <code>Thinlet</code> in the following
      ways:
        <ul>
          <li>Exposes constants for Thinlet's widget names that are used in
          several points of the API and also internally.</li>
          <li>Provides several
          <code>set&lt;Property&gt;(Object,&lt;type&gt;)</code> and
          <code>&lt;type&gt; get&lt;Property&gt;(Object)</code> methods so that
          widget properties may be accessed in a strongly typed way.</li>
          <li>Implements some <code>create&lt;Widget&gt;(..)</code> methods that
          make it easy to dinamically generate graphical components.</li>
          <li>Has methods to display a bean on screen
          (<code>displayBean(..)</code> and <code>populateFrom..(..)</code>) as
          well as to capture displayed values in a bean
          (<code>populate(Object)</code>).</li>
          <li>Makes it possible to handle errors through
          <code>handleException(Throwable)</code> and more specialized methods
          such as <code>handleUIException(UIException),
          handleCustomException(Throwable),</code> and
          <code>handleUnknownException(Throwable)</code>.</li>
          <li>Integrates validation and implements specific error handling for
          it.</li>
          <li>Implements form-to-view binding through methods
          <code>bind(..)</code>, <code>invokeFormAction(..)</code> etc.</li>
        </ul>
      </p><p>When the model explained in this document is used, i.e., form binding,
      only the last three characteristics are directly used by client code.
      Therefore, just these ones will be explored from this point on.</p><p><code>BaseDialogThinlet</code> is a specialization of
      <code>BaseThinlet</code> that makes it simpler to create dialogs. As a
      consequence, all explanations regarding <code>BaseThinlet</code> also
      apply to it.</p><div class="subsection"><a name="Setting_up_and_displaying_a_window"></a><h3>Setting up and displaying a window</h3><p>The programmer is responsible for creating the window in which a view
        will be displayed. A way to create the main window is by using
        <code>FrameLauncher</code>, a class that is contained in Thinlet's
        distribution. An example of this technique is shown below:</p>
    <div class="source"><pre>
public class FrameCreationExample extends BaseThinlet {
   public FrameCreationExample() throws Exception {
      add(parse("frame_creation_example.xml"));
   }

   public static void main(String[] args) throws Exception {
      new FrameLauncher("Frame creation example",
            new FrameCreationExample(), 800, 600);
   }
}
</pre></div>
  <p>This trivial example may be sufficient for several situations, but in
        a few others it might be necessary to change a frame's properties before
        displaying it. If all frames in an application need to be changed in the
        same way, it's recommended to create an intermediate base class. This
        technique is used in the examples provided with genesis. The following
        class was extracted from the useradmin sample:</p>
    <div class="source"><pre>
public abstract class BaseView extends BaseThinlet {
   public BaseView(String title, String xmlFile, int width, int height,
         boolean resizable) throws Exception {
      Frame f = new Frame();
      f.add(this);
      Insets is = f.getInsets();
      width += is.left + is.right;
      height += is.top + is.bottom;
      Dimension ss = getToolkit().getScreenSize();
      width = Math.min(width, ss.width);
      height = Math.min(height, ss.height);
      f.setBounds((ss.width - width) / 2, (ss.height - height) / 2, width,
            height);
      f.setResizable(resizable);
      f.setTitle(UIUtils.getInstance().getBundle().getString(title));
      f.addWindowListener(new WindowAdapter() {
         public void windowClosing(WindowEvent e) {
            System.exit(0);
         }
      });
      setAllI18n(true);
      setResourceBundle(UIUtils.getInstance().getBundle());
      add(parse(xmlFile));
   }
}
</pre></div>
  <p>The above class creates its own frame so it can be centered,
        makes it resizable or not, defines its title using a
        <code>ResourceBundle</code>, - which makes internationalization
        possible) - configures the window to stop execution when it is closed
        and configures UI internationalization before adding the xml file.</p><p><code>BaseDialogThinlet</code> has constructors capable of
        instantiating a <code>Dialog</code> - using an existent
        <code>Frame</code> or a <code>BaseThinlet</code> instance or creating a
        new <code>Frame</code> - and others that receive an externally created
        instance. Generally it won't be necessary to externally configure a
        <code>Dialog</code> instance. By default a listener that calls the non-
        final method <code>onClose()</code> when the window is closed is a
        added. It is possible to customize the behaviour in response to the
        window closing event by overriding <code>onClose()</code>.</p><p>It's also recommended to create an intermediate, project-specific
        super class for <code>BaseDialogThinlet</code>. An example, also
        extracted from the useradmin sample, can be seen below:</p>
    <div class="source"><pre>
public abstract class BaseDialogView extends BaseDialogThinlet {
   public BaseDialogView(Frame frame, String title, String xmlFile,
         boolean resizable, boolean modal) throws Exception {
      super(frame);
      getDialog().setModal(modal);
      getDialog().setResizable(resizable);
      getDialog().setTitle(UIUtils.getInstance().getBundle().getString(title));
      setAllI18n(true);
      setResourceBundle(UIUtils.getInstance().getBundle());
      add(parse(xmlFile));
   }
}
</pre></div>
  <p>The above code is very similar to the previous code. It just
        configures the <code>Dialog</code> instance - that can be obtained using
        <code>getDialog()</code>, as showed above - to be modal or not and
        resizable or not.</p></div></div><div class="section"><a name="Using_auxiliary_UI_classes"></a><h2>Using auxiliary UI classes</h2><p>Some auxiliary classes are provided together with genesis-client to
      accelerate UI development process. They implement several common tasks,
      such as displaying messages, asking for user confirmation and displaying
      exceptions. All these classes belong to the package
      <code>net.java.dev.genesis.ui.thinlet</code>.</p><div class="subsection"><a name="MessageDialog"></a><h3>MessageDialog</h3><p>The first of these auxiliary classes is <code>MessageDialog</code>,
        which displays a message to an user in a <code>Dialog</code> that also
        contains a "Close" button. Two static <code>show(..)</code> methods are
        provided in order to make using this class even more convenient. Both
        accept the window title as their second argument and the message to
        display as the third, whereas the first parameter might be an instance
        of <code>Frame</code> or <code>BaseThinlet</code>. The second version
        makes it even easier to use inside a class that extends
        <code>BaseThinlet</code> as the code below demonstrates:</p>
    <div class="source"><pre>
public void displayMessage() {
   MessageDialog.show(this, "Title", "Message to be displayed");
}
</pre></div>
  </div><div class="subsection"><a name="OptionDialog"></a><h3>OptionDialog</h3><p>To display a choice, the class <code>OptionDialog</code> might be
        useful. Similarly to <code>MessageDialog</code>, two versions of a <code>display(..)</code> method are provided, accepting either an instance of
        <code>BaseThinlet</code> or <code>Frame</code>, the window title and the
        question to be displayed. When one of these methods is used, a dialog
        window is shown with three buttons (Yes/No/Cancel). There is a
        <code>displayYesNo(BaseThinlet,String,String)</code> method for
        occasions when just these options would be appropriate. All the three
        methods return a value from the enumeration <code>Option</code>, so it's
        possible to know which option the user has selected.
        <code>OptionDialog</code> may be used in a class that extends
        <code>BaseThinlet</code> as shown below:</p>
    <div class="source"><pre>
public void performOperation() {
   Option option = OptionDialog.displayYesNo(this, "Title", "Do you really " +
         "want to do that?");

   if (option == Option.YES) {
      // perform the operation
   }
}
</pre></div>
  </div><div class="subsection"><a name="ErrorReporterDialog"></a><h3>ErrorReporterDialog</h3><p><code>ErrorReporterDialog</code> allows one to display an exception
        with a descriptive message, besides all the stack trace. As it is true
        for <code>MessageDialog</code>, there are also two versions of
        <code>show(..)</code>: one for a <code>BaseThinlet</code> instance and
        another one for a <code>Frame</code>. The example below shows how to use
        this class in a <code>BaseThinlet</code> subclass:</p>
    <div class="source"><pre>
public void displayError(Throwable t) {
   ErrorReporterDialog.show(this, "Error", t.getMessage(), t);
}
</pre></div>
  <p>Directly usage of <code>ErrorReporterDialog</code> in client code
        will probably be unnecessary, since the default error handling
        implemented in <code>BaseThinlet</code> already uses this class as
        explained later.</p></div></div><div class="section"><a name="Understanding_forms"></a><h2>Understanding forms</h2><p>Forms contain UI logic and are not coupled to the graphical API used to
      display screens. A form is just a JavaBean that has annotations that
      indicate how its properties and methods should be handled by a UI.</p><p>Since the form is not directly bound to a graphical API, this binding
      must be made explicitly. A <b>binding</b> is a concept supported by
      genesis and each genesis-client implementation model will have a specific
      way to perform the binding. Using the Thinlet implementation model, this
      can be done by calling <code>bind(Object)</code>, that binds a form to a
      view.</p><p>A very simple, yet complete UI example can be seen below. We have all
      of the components that are required to implement a simple login interface.
      First, let's see the UI xml, which is contained in a file named
      <code>login.xml</code>:</p>
    <div class="source"><pre>

 1. &lt;panel gap="5" top="5" left="5" bottom="5" right="5" weightx="1"
 2.        weighty="1"&gt;
 3.    &lt;panel gap="5" columns="2" weightx="1"&gt;
 4.       &lt;label text="User" font="bold" /&gt;
 5.       &lt;textfield name="user" columns="10" /&gt;
 6.       &lt;label text="Password" font="bold" /&gt;
 7.       &lt;passwordfield name="password" columns="10" /&gt;
 8.    &lt;/panel&gt;
 9.    &lt;panel gap="5" halign="center" weightx="1"&gt;
10.       &lt;button name="login" text="Login" /&gt;
11.       &lt;button name="reset" text="Reset" /&gt;
12.    &lt;/panel&gt;
13. &lt;/panel&gt;

</pre></div>
  <p>Next, we have the view's code:</p>
    <div class="source"><pre>
public class LoginView extends BaseDialogThinlet {
   public LoginView() throws Exception {
      getDialog().setTitle("Login");

      add(parse("login.xml"));
      bind(new LoginForm());
   }

   public static void main(String[] args) throws Exception {
      new LoginView().display();
   }
}
</pre></div>
  <p>Notice in the code above how the method <code>bind(Object)</code> is used, passing a form instance as an argument. Below, we have the
      code for the form used in this example:</p>
    <div class="source"><pre>
 1. /**
 2.  * @Form
 3.  */
 4. public class LoginForm {
 5.    private String user;
 6.    private String password;
 7.
 8.    public String getUser() {
 9.       return user;
10.    }
11.
12.    public void setUser(String user) {
13.       this.user = user;
14.    }
15.
16.    public String getPassword() {
17.       return password;
18.    }
19.
20.    public void setPassword(String password) {
21.       this.password = password;
22.    }
23.
24.    /**
25.     * @Action
26.     */
27.    public void login() {
28.       System.out.println(user);
29.       System.out.println(password);
30.    }
31.
32.    /**
33.     * @Action
34.     */
35.    public void reset() {
36.       setUser(null);
37.       setPassword(null);
38.    }
39. }
</pre></div>
  <p>By analyzing this example we can learn a few important things about
      defining a form. A form is annotated with a <code>@Form</code> tag in its
      class level, as shown in lines 1-3. This annotation tells genesis this
      class should be treated as a form, a fact that requires special
      treatment internally through a genesis-aspect component.</p><p>Properties exposed through getters and setters - for this example,
      <code>user</code> (lines 8-14) and <code>password</code> (lines 16-22) -
      may be dynamically bound to a variety of UI widgets, such as textfields,
      passwordfields, labels and others. To make that possible, widget
      <code>name</code>s in the UI xml file (lines 5 and 7) must match the
      form's property names. Both the property value in the form and its
      displayed value will be in synch whenever the widget representing the
      property loses focus. In the example given, this happens when the user
      press the TAB key or clicks in a different point of the window when the
      focus is on textfields <code>user</code> or <code>password</code>.</p><p>If a property should neither be updated nor displayed by genesis,
      its getter method should be annotated as <code>@NotBound</code>.</p><p>Methods may also be bound to buttons on the screen. In order for that
      to happen, they must be annotated as <code>@Action</code> (lines 24-26
      and 32-34) and there must exist buttons with a <code>name</code> value
      equal to them in the UI (lines 10-11 in the xml file). So, when the
      button is pressed, the method whose name matches the the button's name is
      invoked on the form instance. In the example above, when the Login button
      is clicked, the values for widgets User and Password are printed on the
      standard output, while activating button Reset will clear the fields'
      content both on the screen and within the form.</p></div><div class="section"><a name="Implementing_actions_in_forms_and_views"></a><h2>Implementing actions in forms and views</h2><p>Although genesis makes it possible to bind form actions to widgets,
      nothing stops one from taking advantage of Thinlet's built-in feature of
      invoking methods by configuring them in the UI xml definition. As a
      consequence, a recurring question is when to use <code>@Action</code> and
      when to use <code>action="method()"</code> directly in the view's code.
      Some basic principles might be helpful in order to decide which approach
      to use.</p><p>If an action changes the form or isn't bound to the graphical API, it
      should be implemented on the form class using <code>@Action</code>. If the
      response to a certain event is simply to display a new window, dialog or
      some API-specific task, it should be implemented on the view and triggered
      by an <code>action="method()"</code> construction. However, there are
      occasions that are not so simple and when it's necessary to manipulate
      both the form and the view. These cases are considered below.</p><div class="subsection"><a name="Using_@BeforeAction"></a><h3>Using @BeforeAction</h3><p>Let's consider the following example: a use case about deleting some
        information must be implemented. But before deleting it, the user is
        supposed to confirm the operation. This confirmation could be
        implemented by displaying an <code>OptionDialog</code> to the user and
        continuing the operation only if s/he agreed to delete it. However,
        deleting some information is not a graphical API specific operation and,
        therefore, should be implemented on the form class. How can it be done
        correctly?</p><p>In order to execute a UI-related method before invoking a form
        method - and even not calling the form method at all -, the
        <code>@BeforeAction</code> annotation is used. This annotation should be
        put in a view method that should be executed before a form method and
        can either return a <code>boolean</code> or <code>void</code>. When
        <code>false</code> is returned, the form method is not invoked.</p><p>If the view method name is the same as the form method name, it's not
        necessary to specify any additional parameter for the annotation. In
        some situations, however, a view method name cannot be the same used for
        naming a form method. In order to indicate which form method should be
        executed only after a view method is invoked, the form method name is
        passed as an annotation argument. A full example is shown below. First,
        the view:</p>
    <div class="source"><pre>
public class BeforeActionViewExample extends BaseThinlet {
   public BeforeActionViewExample() {
      // initialization logic
      bind(new BeforeActionFormExample());
   }

   /**
    * @BeforeAction delete
    */
   public boolean confirmDeletion() {
      return OptionDialog.displayYesNo(this, "Deleting record...",
            "Do you really want to delete this record?") == Option.YES;
   }

   // ...
}
</pre></div>
  <p>Now, the form:</p>
    <div class="source"><pre>
/**
 * @Form
 */
public class BeforeActionFormExample {
   /**
    * @Action
    */
   public void delete() {
      // here goes business logic for this operation.
   }

   // ...
}
</pre></div>
  <p>When the button whose <code>name</code> is <code>"delete"</code> is
        pressed, genesis invokes <code>confirmDeletion()</code> in
        <code>BeforeActionViewExample</code> since it is annotated with the
        <code>@BeforeAction delete</code>. If the view method name was
        <code>delete</code> it wouldn't be necessary to specify the method
        name as an annotation parameter.</p><p>Since <code>confirmDeletion()</code> returns a <code>boolean</code>,
        the form method will be invoked only when the return value is
        <code>true</code>. For this specific example, this only happens when the
        user chooses "Yes" in the displayed dialog. When this confirmation
        occurs, <code>delete()</code> is invoked by genesis and event handling
        is considered done.</p></div><div class="subsection"><a name="Using_@AfterAction"></a><h3>Using @AfterAction</h3><p>After executing a form method it might be needed to use graphical
        API-specific resources, such as, for example, close the currently
        displayed window. In order to make it possible genesis supports the
        <code>@AfterAction</code> annotation, that should tag the view method
        to be invoked. Its syntax is very similar to the
        <code>@BeforeAction</code>'s syntax, except that a method annotated with
        it should always return <code>void</code>. A usage example is:</p>
    <div class="source"><pre>
public class AfterActionViewExample extends BaseDialogThinlet {
   public AfterActionViewExample() {
      // initialization logic
      bind(new AfterActionFormExample());
   }

   /**
    * @AfterAction save
    */
   public void closeWindow() {
      getDialog().dispose();
   }

   // ...
}
</pre></div>
  
    <div class="source"><pre>
/**
 * @Form
 */
public class AfterActionFormExample {
   /**
    * @Action
    */
   public void save() {
      // here goes business logic for this operation.
   }

   // ...
}
</pre></div>
  <p>In the example above, when the button whose <code>name</code> is
        <code>"save"</code> is pressed, the method named <code>save()</code> is
        invoked on the form instance. After its execution, view's method <code>
        closeWindow()</code>, which is annotated as
        <code>@AfterAction save</code> is executed. As it was true for
        <code>@BeforeAction</code>, if the view method name was also
        <code>save()</code> it wouldn't be necessary to use it as an argument to
        the annotation.</p></div><div class="subsection"><a name="Using_refreshView_____and_refreshViewFromForm_Object_"></a><h3>Using refreshView(..) and refreshViewFromForm(Object)</h3><p>Sometimes form values may be updated by an external source or
        directly by the view - to coordinate multiple form iteraction, for
        example. However, since these changes are not managed by genesis, both
        the framework internal value cache as displayed data will be stale,
        causing several anomalies. Methods <code>refreshView()</code>,
        <code>refreshView(Object)</code> and
        <code>refreshViewFromForm(Object)</code> can be used in these scenarios.
        </p><p>The first method, <code>refreshView()</code>, should be used when
        just one form instance is bound to a view.
        <code>refreshView(Object)</code> takes as its parameter the widget to
        which one or several forms are bound and process any changes to their
        values. <code>refreshViewFromForm(Object)</code> updates the widget
        bound to the form instance informed as its parameter. An example of how
        to use the first method is shown below:</p>
    <div class="source"><pre>
public class RefreshViewViewExample extends BaseThinlet {
   private RefreshViewFormExample form;

   public RefreshViewViewExample() {
      // initialization logic
      bind(form = new RefreshViewFormExample());
   }

   public void selectRelatedEntity() {
      // display a helper view for selecting the entity and returns
      Entity entity = new EntityLookupView().getEntity();

      if (entity != null) {
         form.setEntity(entity);
         refreshView();
      }
   }

   // ...
}
</pre></div>
  
    <div class="source"><pre>
/**
 * @Form
 */
public class RefreshViewExampleForm {
   private Entity entity;
   // ...

   public Entity getEntity() {
      return entity;
   }

   public void setEntity(Entity entity) {
      this.entity = entity;
   }

   // ...
}
</pre></div>
  </div><div class="subsection"><a name="Using_invokeFormAction____"></a><h3>Using invokeFormAction(..)</h3><p>In some situations it may be necessary to invoke one or more form
        methods inside a view method under certain specific conditions where
        using <code>@BeforeAction</code> and <code>@AfterAction</code> is not
        enough. Although calling a form method directly is possible, genesis is
        not notified of the method invocation. This has several consequences,
        such as a stale UI, for example.</p><p>In order to invoke a form method and still keep the automatic
        synchronization between view and form, either the method
        <code>invokeFormAction(String)</code> or the method
        <code>invokeFormAction(Object,String)</code>should be used. The
        <code>String</code> parameter both take is the name of the form method
        to be invoked. The second method accepts the form instance in which the
        method should be invoked and is useful when several forms are bound to
        the same view. An example of how to use the first method is shown below:
        </p>
    <div class="source"><pre>
public class InvokeFormActionViewExample extends BaseThinlet {
   private InvokeFormActionFormExample form;

   public InvokeFormActionViewExample() {
      // initialization logic
      bind(form = new InvokeFormActionFormExample());
   }

   public void selectFinantialIndexes() {
      BigDecimal index = //... index is acquired from another window,
                         // for example
      form.setIndex(index);
      invokeFormAction("recalculateTotals");
   }

   // ...
}
</pre></div>
  
    <div class="source"><pre>
/**
 * @Form
 */
public class InvokeFormActionFormExample {
   private BigDecimal index;
   // ...

   public BigDecimal getIndex() {
      return index;
   }

   public void setIndex(BigDecimal index) {
      this.index = index;
   }

   /**
    * @DataProvider objectField=totals
    */
   public void recalculateTotals() {
      // business logic to manipulate several other properties
   }
}
</pre></div>
  </div></div></div></div><div class="clear"><hr></hr></div><div id="footer"><div class="xright">© 2004-2005, Summa Tecnologies do Brasil Ltda.</div><div class="clear"><hr></hr></div></div></body></html>