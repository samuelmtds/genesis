<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><title>Populando combos, listas e tabelas - genesis</title><style type="text/css" media="all">
          @import url("../style/maven-base.css");
          
          @import url("../style/maven-theme.css");</style><link rel="stylesheet" href="../style/print.css" type="text/css" media="print"></link><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta><meta name="author" content="Allan Jones Batista de Castro"></meta><meta name="email" content="allanjones@dev.java.net"></meta><meta name="author" content="Michael Nascimento Santos"></meta><meta name="email" content="mister__m@dev.java.net"></meta></head><body class="composite"><div id="banner"><a href="https://genesis.dev.java.net/" id="projectLogo"><img alt="SOL Genesis" src="../genesis.gif"></img></a><div class="clear"><hr></hr></div></div><div id="breadcrumbs"><div class="xleft">Last published: 12 May 2009
                <span class="separator">|</span> Doc for  3.2
                </div><div class="xright">
        
        <a href="../index.html">genesis</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-aspect/index.html">genesis-aspect</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-client/index.html">genesis-client</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-server/index.html">genesis-server</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-shared/index.html">genesis-shared</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../tags/genesis-tags.html">genesis-xdoclet</a>
      </div><div class="clear"><hr></hr></div></div><div id="leftColumn"><div id="navcolumn"><div id="menugenesis"><h5>genesis</h5><ul><li class="none"><a href="../pt-BR/index.html">Visão geral</a></li><li class="none"><a href="../pt-BR/download.html">Downloads</a></li><li class="none"><a href="../pt-BR/release_notes.html">Notas de versão</a></li></ul></div><div id="menuDocumentação"><h5>Documentação</h5><ul><li class="expanded"><a href="../pt-BR/documentation_intro.html">Manual do usuário</a><ul><li class="none"><a href="../pt-BR/documentation_intro.html">Introdução</a></li><li class="none"><a href="../pt-BR/annotations.html">Usando anotações</a></li><li class="none"><a href="../pt-BR/startup.html">Inicializando o genesis</a></li><li class="expanded"><a href="../pt-BR/remoting.html">Funcionalidades básicas</a><ul><li class="none"><a href="../pt-BR/remoting.html">Remotabilidade transparente</a></li><li class="none"><a href="../pt-BR/transactions.html">Suporte a transações</a></li><li class="none"><a href="../pt-BR/hibernate_integration.html">Integração com o Hibernate</a></li><li class="none"><a href="../pt-BR/binding.html">Binding</a></li><li class="none"><a href="../pt-BR/actions.html">Implementando ações mistas</a></li></ul></li><li class="expanded"><a href="../pt-BR/thinlet_binding.html">Funcionalidades específicas para Thinlet</a><ul><li class="none"><a href="../pt-BR/thinlet_binding.html">Binding Thinlet</a></li><li class="none"><a href="../pt-BR/customizing_widgets_creation.html">Customizando a criação de componentes</a></li></ul></li><li class="expanded"><a href="../pt-BR/configuring_swt.html">Funcionalidades específicas para SWT</a><ul><li class="none"><a href="../pt-BR/configuring_swt.html">Configurando as bibliotecas do SWT</a></li></ul></li><li class="expanded"><a href="../pt-BR/conditions.html">Funcionalidades adicionais</a><ul><li class="none"><a href="../pt-BR/conditions.html">Trabalhando com condições</a></li><li class="none"><strong><a href="../pt-BR/populating_with_dataproviders.html">Populando combos, listas e tabelas</a></strong></li><li class="none"><a href="../pt-BR/binding_toggle_buttons.html">Binding de botões de rádio e caixas de seleção</a></li><li class="none"><a href="../pt-BR/binding_strategy.html">Mudando a estratégia de binding</a></li><li class="none"><a href="../pt-BR/formatting.html">Formatando os dados</a></li><li class="none"><a href="../pt-BR/handling_errors.html">Tratando erros</a></li><li class="none"><a href="../pt-BR/validating_data.html">Validando os dados</a></li><li class="none"><a href="../pt-BR/configuring_messages.html">Configurando as mensagens</a></li><li class="none"><a href="../pt-BR/paging_and_dynamic_search.html">Paginação e pesquisas dinâmicas</a></li></ul></li><li class="none"><a href="../pt-BR/quick_reference.html">Guia de referência rápida de anotações</a></li></ul></li><li class="expanded"><a href="../pt-BR/empty_project.html">Desenvolvendo com o genesis</a><ul><li class="none"><a href="../pt-BR/empty_project.html">Para desktops</a></li><li class="none"><a href="../pt-BR/empty_web_project.html">Para web</a></li></ul></li><li class="none"><a href="../pt-BR/useradmin_sample.html">Usando o exemplo UserAdmin</a></li><li class="expanded"><a href="../pt-BR/advanced_introduction.html">Guia avançado</a><ul><li class="none"><a href="../pt-BR/xdoclet_extensions.html">Extensões do XDoclet</a></li><li class="none"><a href="../pt-BR/aspects.html">Aspectos do genesis</a></li><li class="none"><a href="../pt-BR/generic_scripting.html">Suporte a linguagens de script</a></li><li class="none"><a href="../pt-BR/lookup_strategy.html">Estratégias de pesquisa de componentes gráficos</a></li><li class="none"><a href="../pt-BR/widget_binder.html">Customizando o binding de componentes gráficos</a></li></ul></li><li class="none"><a href="../pt-BR/faq.html">FAQ</a></li><li class="none"><a href="http://wiki.java.net/bin/view/Projects/GenesisRoadmap" class="externalLink" title="External Link">Roadmap</a></li><li class="none"><a href="http://wiki.java.net/bin/view/Projects/Genesis" class="externalLink" title="External Link">Wiki</a></li></ul></div><div id="menuProject_Documentation"><h5>Project Documentation</h5><ul><li class="none"><a href="../index.html">About</a></li><li class="collapsed"><a href="../project-info.html">Project Info</a></li><li class="collapsed"><a href="../maven-reports.html">Project Reports</a></li><li class="none"><a href="http://maven.apache.org/development-process.html" class="externalLink" title="External Link">Development Process</a></li></ul></div><div id="menujava_net"><h5>java.net</h5><ul><li class="none"><a href="https://genesis.dev.java.net" class="externalLink" title="External Link">genesis.dev.java.net</a></li><li class="none"><a href="http://java.net" class="externalLink" title="External Link"><img title="java.net member" style="border: 1px" src="../java_dot_net_member.bmp" alt="java.net member"></img></a></li></ul></div><div id="legend"><h5>Legend</h5><ul><li class="externalLink">External Link</li><li class="newWindow">Opens in a new window</li></ul></div><a href="http://maven.apache.org/" title="Built by Maven" id="poweredBy"><img alt="Built by Maven" src="../images/logos/maven-button-1.png"></img></a></div></div><div id="bodyColumn"><div class="contentBox"><div class="section"><a name="Populando_combos__listas_e_tabelas"></a><h2>Populando combos, listas e tabelas</h2>
      <p>As opções disponíveis em um combo box podem variar de acordo com os
      dados preenchidos pelo usuário ou outras regras de negócio. O conteúdo de
      uma tabela pode precisar ser preenchido dinamicamente em resposta a um
      critério de filtro especificado pelo usuário, por exemplo. Para lidar com
      tais situações, existe uma anotação chamada <code>@DataProvider</code>,
      cuja sintaxe é:</p>

    <div class="source"><pre>
@DataProvider(objectField="nomeCampoObjeto",
              indexField="nomeCampoIndice",
              widgetName="nomeCampo",
              callOnInit=valorBooleano
              resetSelection=valorBooleano)
</pre></div>
  
      <p>Esta anotação deve ser colocada em métodos que retornam uma
      <code>java.util.List</code> ou uma array de <code>Object</code>s. O 
      retorno dos métodos será utilizado para popular a combobox, lista ou 
      tabela.</p>
      <p><code>objectField</code> deve receber o nome da propriedade em seu 
      form, se houver, que guardará a instância (ou instâncias, em caso de 
      múltipla seleção) selecionada no widget. Deve ser do mesmo tipo ou uma 
      superclasse do tipo retornado no método anotado, uma array do tipo ou uma
      <code>Collection</code>.</p>
      <p><code>indexField</code> é o nome da propriedade em
      seu form que guardará os índices dos elementos selecionados no widget.
      Deve ser um <code>int</code> ou um <code>Integer</code>, uma array de um 
      desses tipos ou uma <code>Collection</code>.</p>
      <p><code>widgetName</code>, se utilizado, deve receber o nome do 
      componente gráfico - lista, combo ou tabela - que receberá os valores 
      retornados pelo método anotado. No caso do Thinlet, o 
      <code>widgetName</code> deve ser o <code>name</code> do widget definido no 
      xml da view. No caso do Swing, o <code>widgetName</code> deve ser igual ao 
      valor retornado por <code>getName()</code> para o <code>Component</code>
      desejado. No caso do SWT, o <code>widgetName</code> deve ser igual ao 
      valor retornado por <code>getData()</code>
      para o <code>Widget</code> desejado.</p>
      <p><b>Pelo menos uma dessas três propriedades deve ser informada</b>.</p>
      <p>O <code>name</code> do widget que será populado pelo 
      <code>@DataProvider</code> é igual ao valor da primeira propriedade que
      estiver definida, na seguinte ordem de prioridade: 
      <code>widgetName</code>, <code>objectField</code>, 
      <code>indexField</code>.</p>
      <p>Como mencionado acima, <code>objectField</code> e
      <code>indexField</code> recebem o nome de uma propriedade cujo tipo pode
      ser um bean, uma array ou uma <code>Collection</code>. Vejamos exatamente
      quando cada tipo poderá ser utilizado de acordo com o modo de seleção do
      widget:</p>
      <div class="subsection"><a name="Seleção_Única"></a><h3>Seleção Única</h3>
        <table class="bodyTable">
          <tr class="a">
            <th>Tipo de Retorno do Método anotado</th>
            <th>objectField</th>
            <th>indexField</th>
          </tr>
          <tr class="b">
            <td><code>java.util.List</code> ou array de objetos</td>
            <td>Qualquer classe (não pode ser tipo primitivo)</td>
            <td><code>Integer</code> ou tipo primitivo <code>int</code></td>
          </tr>
        </table>
      </div>
      <div class="subsection"><a name="Seleção_Múltipla"></a><h3>Seleção Múltipla</h3>
        <table class="bodyTable">
          <tr class="a">
            <th>Tipo de Retorno do Método anotado</th>
            <th>objectField</th>
            <th>indexField</th>
          </tr>
          <tr class="b">
            <td><code>java.util.List</code> ou array de objetos</td>
            <td>Array de qualquer classe (não pode ser de tipo primitivo) ou
            <code>Collection</code> de qualquer classe</td>
            <td>Array de <code>Integer</code>s (ou de tipo primitivo
            <code>int</code>) ou <code>Collection</code> de
            <code>Integer</code>s</td>
          </tr>
        </table>
      </div>
      <p>Abaixo teremos um exemplo do uso da anotação em vários cenários 
      possíveis:</p>

    <div class="source"><pre>
public class Estado {
   private String sigla;
   private String descricao;

   // getters e setters para as propriedades
}
</pre></div>
  

    <div class="source"><pre>
@Form
public class ExemploDataProviderForm {
   private Estado estado;

   public Estado getEstado() {
      return estado;
   }

   public void setEstado(Estado estado) {
      this.estado = estado;
   }

   @DataProvider(objectField="estado")
   public List populaEstados() {
      // retorna uma List contendo instâncias de Estado
   }

   // ...
}
</pre></div>
  
      <p>Considerando o código fonte do form mostrado acima, criaremos 
      interfaces gráficas com as diferentes APIs e componentes gráficos:</p>
      <p><b>Thinlet</b>
        <ul>
          <li><a href="#ThinletComboBox">ComboBox</a></li>
          <li><a href="#ThinletList">List</a></li>
          <li><a href="#ThinletTable">Table</a></li>
        </ul>
      </p>
      <p><b>Swing</b>
        <ul>
          <li><a href="#SwingComboBox">ComboBox</a></li>
          <li><a href="#SwingList">List</a></li>
          <li><a href="#SwingTable">Table</a></li>
        </ul>
      </p>
      <p><b>SWT</b>
        <ul>
          <li><a href="#SWTComboBox">ComboBox</a></li>
          <li><a href="#SWTList">List</a></li>
          <li><a href="#SWTTable">Table</a></li>
        </ul>
      </p>
      <div class="subsection"><a name="Thinlet"></a><h3>Thinlet</h3>
        <h5><a name="ThinletComboBox">ComboBox</a></h5>

    <div class="source"><pre>

&lt;panel gap="5"&gt;
   &lt;label text="Estado:" /&gt;
   &lt;combobox name="estado" property="key=sigla;value=descricao" /&gt;
&lt;/panel&gt;

</pre></div>
  
          <p>Acima vemos o xml da tela que exibe um <code>label</code> e um 
          <code>combobox</code> que conterá os estados em tempo de execução. A 
          propriedade <code>name</code> possui o mesmo valor que o atributo
          <code>objectField</code> da anotação <code>@DataProvider</code>. 
          Pode-se notar alguns valores configurados no atributo 
          <code>property</code>. Os seguintes valores são utilizados no caso de 
          comboboxes:</p>
          <ul>
            <li><b>key</b>: nome da propriedade, cujo valor é único por 
            instância, do bean que será utilizado para popular o componente.
            Se essa propriedade não for definida, o valor retornado pelo 
            formatador será usado como chave.</li>
            <li><b>value</b>: nome da propriedade utilizada para exibir o bean. 
            Se essa propriedade não for definida, o formatador registrado ou o
            formatador padrão é utilizado.</li>
            <li><b>blank</b>: inclui uma linha em branco como primeira opção da
            combobox. Não é requerida e tem como valor padrão 
            <code>false</code>.</li>
            <li><b>blankLabel</b>: define o texto a ser exibido na linha em 
            branco. Não é requerida, tem como valor padrão uma 
            <code>String</code> vazia e só é usada quando 
            <code>blank=true</code>.</li>
          </ul>
          <p>Conforme indicado pelo valor do atributo <code>objectField</code>, 
          a propriedade de nome <code>estado</code> do form conterá a instância 
          de <code>Estado</code> correspondente à opção da combo escolhida pelo 
          usuário.</p>
        <h5><a name="ThinletList">List</a></h5>

    <div class="source"><pre>

&lt;panel gap="5"&gt;
   &lt;label text="Estado:" /&gt;
   &lt;list name="estado" property="key=sigla;value=descricao" /&gt;
&lt;/panel&gt;

</pre></div>
  
          <p>No caso de uma <code>list</code>, os requerimentos são similares 
          aos do <a href="#ThinletComboBox">combobox</a>.</p>
        <h5><a name="ThinletTable">Table</a></h5>

    <div class="source"><pre>

&lt;panel gap="5"&gt;
   &lt;table name="estado"&gt;
      &lt;header&gt;
         &lt;column name="sigla" text="Sigla" /&gt;
         &lt;column name="descricao" text="Descrição" /&gt;
      &lt;/header&gt;
   &lt;/table&gt;
&lt;/panel&gt;

</pre></div>
  
          <p>Os requerimentos para popular uma table são um pouco 
          diferentes.</p>
          <p>Com base no exemplo acima, podemos observar que o valor de 
          <code>name</code> na tabela precisa ser igual ao valor do atributo
          <code>objectField</code>, exceto quando for especificado o atributo
          <code>widgetName</code> na anotação, e nesse caso o valor de 
          <code>widgetName</code> deve ser o nome do componente. Cada linha da 
          tabela representará uma instância e cada coluna será preenchida com a 
          propriedade do bean cujo nome é o valor de <code>name</code> em cada 
          uma delas.</p>
      </div>
      <div class="subsection"><a name="Swing"></a><h3>Swing</h3>
        <h5><a name="SwingComboBox">ComboBox</a></h5>

    <div class="source"><pre>

private JComboBox estadoComboBox;
  ...
  private initComponents() {
     ...
     estadoComboBox = new JComboBox();
     estadoComboBox.setName("estado");
     estadoComboBox.putClientProperty(SwingBinder.KEY_PROPERTY, "sigla");
     estadoComboBox.putClientProperty(SwingBinder.VALUE_PROPERTY, "descricao");
     estadoComboBox.setRenderer(new KeyValueListCellRenderer(estadoComboBox));
  }

</pre></div>
  
          <p>Acima vemos o código da tela que exibe um <code>combobox</code>
          que conterá os estados em tempo de execução. O nome do componente
          (<code>estadoComboBox.setName("estado")</code>) possui o mesmo valor
          que o atributo <code>objectField</code> da anotação 
          <code>@DataProvider</code>. Para que os valores sejam mostrados 
          corretamente ao usuário ao popular o <code>JComboBox</code>, é 
          necessário configurar algumas propriedades do componente e utilizar a 
          classe <code>net.java.dev.genesis.ui.swing.renderers.KeyValueListCellRenderer</code>
          como renderer do componente. Esta classe verifica os valores 
          configurados como propriedades do componente para determinar qual 
          propriedade do bean deve ser visível para o usuário. Os valores das 
          propriedades são configurados através do método 
          <code>putClientProperty(Object chave, Object valor)</code> do 
          componente. As seguintes propriedades são utilizadas no caso de 
          comboboxes:</p>
          <ul>
            <li><b>SwingBinder.KEY_PROPERTY</b>: nome da propriedade, cujo valor 
            é único por instância, do bean que será utilizado para popular o 
            componente. Se essa propriedade não for definida, o valor retornado 
            pelo formatador será usado como chave.</li>
            <li><b>SwingBinder.VALUE_PROPERTY</b>: nome da propriedade utilizada 
            para exibir o bean. Se essa propriedade não for definida, o formatador
            registrado ou o formatador padrão é utilizado.</li>
            <li><b>SwingBinder.BLANK_PROPERTY</b>: inclui uma linha em branco 
            como primeira opção da combobox. Não é requerida e tem como valor 
            padrão <code>false</code>.</li>
            <li><b>SwingBinder.BLANK_LABEL_PROPERTY</b>: define o texto a ser 
            exibido na linha em branco. Não é requerida, tem como valor padrão 
            uma <code>String</code> vazia e só é usada quando 
            <code>blank=true</code>.</li>
          </ul>
          <p>Conforme indicado pelo valor do atributo <code>objectField</code>, 
          a propriedade de nome <code>estado</code> do form conterá a instância 
          de <code>Estado</code> correspondente à opção da combo escolhida pelo 
          usuário.</p>
          <p>Para facilitar a construção do widget, pode-se utilizar métodos 
          estáticos da classe 
          <code>net.java.dev.genesis.ui.swing.factory.SwingFactory</code>. O 
          código para criação e configuração do <code>JComboBox</code> 
          seria:</p>

    <div class="source"><pre>

private SwingBinder binder;
private JComboBox estadoComboBox;
  ...
  private initComponents() {
     ...
     estadoComboBox = SwingFactory.createComboBox(binder, "estado", "sigla", "descricao");
  }

</pre></div>
  
          <p>No código acima, construímos um <code>JComboBox</code> passando 
          como parâmetros o binder, o nome do componente, o nome da propriedade 
          chave (<code>SwingBinder.KEY_PROPERTY</code>) e o nome da propriedade 
          value (<code>SwingBinder.VALUE_PROPERTY</code>).</p>
        <h5><a name="SwingList">List</a></h5>

    <div class="source"><pre>

private JList estadoList;
  ...
  private initComponents() {
     ...
     estadoList = new JList();
     estadoList.setName("estado");
     estadoList.putClientProperty(SwingBinder.KEY_PROPERTY, "sigla");
     estadoList.putClientProperty(SwingBinder.VALUE_PROPERTY, "descricao");
     estadoList.setCellRenderer(new KeyValueListCellRenderer(estadoList));
  }

</pre></div>
  
          <p>No caso de uma <code>JList</code>, os requerimentos são similares 
          aos do <a href="#SwingComboBox">JComboBox</a>.</p>
        <h5><a name="SwingTable">Table</a></h5>

    <div class="source"><pre>

private JTable estadoTable;
  ...
  private initComponents() {
     ...

     TableColumnModel columnModel = new DefaultTableColumnModel();
     TableModel model = new DefaultTableModel();

     TableColumn siglaColumn = new TableColumn(0);
     siglaColumn.setIdentifier("sigla");
     siglaColumn.setHeaderValue("Sigla");
     columnModel.addColumn(siglaColumn);

     TableColumn descricaoColumn = new TableColumn(1);
     descricaoColumn.setIdentifier("descricao");
     descricaoColumn.setHeaderValue("Descrição");
     columnModel.addColumn(descricaoColumn);

     estadoTable = new JTable(model, columnModel);
     estadoTable.setName("estado");
  }

</pre></div>
  
          <p>Os requerimentos para popular uma table são um pouco 
          diferentes.</p>
          <p>Com base no exemplo acima, podemos observar que o valor do nome
          do componente (<code>estadoTable.setName("estado")</code>) na tabela 
          precisa ser igual ao valor do atributo <code>objectField</code>, 
          exceto quando for especificado o atributo <code>widgetName</code> na 
          anotação, e nesse caso o valor de <code>widgetName</code> deve ser o 
          nome do componente. Cada linha da tabela representará uma instância e 
          cada coluna será preenchida com a propriedade do bean cujo nome é o 
          valor do <code>identifier</code> (ex: 
          <code>descricaoColumn.setIdentifier("descricao")</code>) de cada uma 
          delas. É possível definir o identifier de cada coluna de outra forma
          mais fácil, através do método <code>putClientProperty</code>:</p>

    <div class="source"><pre>

private JTable estadoTable;
  ...
  private initComponents() {
     ...
     estadoTable = new JTable(new DefaultTableModel(new String[] {"Sigla", "Descrição"}, 0));
     estadoTable.setName("estado");
     estadoTable.putClientProperty(SwingBinder.COLUMN_NAMES, new String[] {"sigla", "descricao"});
  }

</pre></div>
  
          <p>Para facilitar a construção do widget, pode-se utilizar métodos 
          estáticos da classe 
          <code>net.java.dev.genesis.ui.swing.factory.SwingFactory</code>.
          O código para criação e configuração da <code>JTable</code> seria:</p>

    <div class="source"><pre>

private SwingBinder binder;
private JTable estadoTable;
  ...
  private initComponents() {
     ...
     estadoTable = SwingFactory.createTable(binder, "estado",
          new String[] {"sigla", "descricao" },
          new String[] {"Sigla", "Descrição" });
  }

</pre></div>
  
          <p>No código acima, construímos um <code>JTable</code> passando como 
          parâmetros o binder, o nome do componente, um array dos 
          <code>identifier</code>s de cada coluna e um array para os textos 
          visíveis para cada coluna.</p>
      </div>
      <div class="subsection"><a name="SWT"></a><h3>SWT</h3>
        <h5><a name="SWTComboBox">ComboBox</a></h5>

    <div class="source"><pre>

private Combo estadoComboBox;
  ...
  private initComponents() {
     ...
     estadoComboBox = new Combo(shell, SWT.NONE);
     estadoComboBox.setData("estado");
     estadoComboBox.setData(SWTBinder.KEY_PROPERTY, "sigla");
     estadoComboBox.setData(SWTBinder.VALUE_PROPERTY, "descricao");
  }

</pre></div>
  
          <p>Acima vemos o código da tela que exibe um <code>combobox</code>
          que conterá os estados em tempo de execução. O nome do componente
          (<code>estadoComboBox.setData("estado")</code>) possui o mesmo valor 
          que o atributo <code>objectField</code> da anotação 
          <code>@DataProvider</code>. Para que os valores sejam mostrados 
          corretamente ao usuário ao popular o <code>Combo</code>, é 
          necessário configurar algumas propriedades do componente. Os valores 
          configurados como propriedades do componente são verificados 
          para determinar qual propriedade do bean deve ser visível para o 
          usuário. Os valores das  propriedades são configurados através do 
          método <code>setData(Object chave, Object valor)</code> do 
          componente. As seguintes propriedades são utilizadas no caso de 
          comboboxes:</p>
          <ul>
            <li><b>SWTBinder.KEY_PROPERTY</b>: nome da propriedade, cujo valor 
            é único por instância, do bean que será utilizado para popular o 
            componente. Se essa propriedade não for definida, o valor retornado 
            pelo formatador será usado como chave.</li>
            <li><b>SWTBinder.VALUE_PROPERTY</b>: nome da propriedade utilizada 
            para exibir o bean. Se essa propriedade não for definida, o formatador
            registrado ou o formatador padrão é utilizado.</li>
            <li><b>SWTBinder.BLANK_PROPERTY</b>: inclui uma linha em branco 
            como primeira opção da combobox. Não é requerida e tem como valor 
            padrão <code>false</code>.</li>
            <li><b>SWTBinder.BLANK_LABEL_PROPERTY</b>: define o texto a ser 
            exibido na linha em branco. Não é requerida, tem como valor padrão 
            uma <code>String</code> vazia e só é usada quando 
            <code>blank=true</code>.</li>
          </ul>
          <p>Conforme indicado pelo valor do atributo <code>objectField</code>, 
          a propriedade de nome <code>estado</code> do form conterá a instância 
          de <code>Estado</code> correspondente à opção da combo escolhida pelo 
          usuário.</p>
        <h5><a name="SWTList">List</a></h5>

    <div class="source"><pre>

private List estadoList;
  ...
  private initComponents() {
     ...
     estadoList = new List(shell, SWT.NONE);
     estadoList.setData("estado");
     estadoList.setData(SwingBinder.KEY_PROPERTY, "sigla");
     estadoList.setData(SwingBinder.VALUE_PROPERTY, "descricao");
  }

</pre></div>
  
          <p>No caso de uma <code>List</code>, os requerimentos são similares 
          aos do <a href="#SWTComboBox">ComboBox</a>.</p>
        <h5><a name="SWTTable">Table</a></h5>

    <div class="source"><pre>

private Table estadoTable;
  ...
  private initComponents() {
     ...

     Table estadoTable = new Table(shell, SWT.NONE);
     estadoTable.setData("estado");
     estadoTable.setHeaderVisible(true);

     TableColumn siglaColumn = new TableColumn(estadoTable, SWT.NONE);
     siglaColumn.setData(SWTBinder.TABLE_COLUMN_IDENTIFIER, "sigla");
     siglaColumn.setText("Sigla");
     siglaColumn.setWidth(100);

     TableColumn descricaoColumn = new TableColumn(estadoTable, SWT.NONE);
     descricaoColumn.setData(SWTBinder.TABLE_COLUMN_IDENTIFIER, "descricao");
     descricaoColumn.setText("Descrição");
     descricaoColumn.setWidth(200);
  }

</pre></div>
  
          <p>Os requerimentos para popular uma table são um pouco 
          diferentes.</p>
          <p>Com base no exemplo acima, podemos observar que o valor do nome
          do componente (<code>estadoTable.setData("estado")</code>)
          na tabela precisa ser igual ao valor do atributo 
          <code>objectField</code>, exceto quando for especificado o atributo 
          <code>widgetName</code> na anotação, e nesse caso o valor de 
          <code>widgetName</code> deve ser o nome do componente. Cada linha da 
          tabela representará uma instância e cada coluna será preenchida com a 
          propriedade do bean cujo nome é o valor do 
          <code>SWTBinder.TABLE_COLUMN_IDENTIFIER</code> (ex: 
          <code>descricaoColumn.setData(SWTBinder.TABLE_COLUMN_IDENTIFIER, 
          "descricao")</code>) de cada uma delas. É possível definir o 
          identificador de cada coluna de outra forma mais fácil, através do 
          método <code>setData</code> da própria tabela:</p>

    <div class="source"><pre>
private Table estadoTable;
  ...
  private initComponents() {
     ...
     Table estadoTable = new Table(shell, SWT.NONE);
     estadoTable.setData("estado");
     estadoTable.setData(SWTBinder.COLUMN_NAMES, new String[] {"sigla", 
           "descricao"});
     estadoTable.setHeaderVisible(true);

     TableColumn siglaColumn = new TableColumn(estadoTable, SWT.NONE);
     siglaColumn.setText("Sigla");
     siglaColumn.setWidth(100);

     TableColumn descricaoColumn = new TableColumn(estadoTable, SWT.NONE);
     descricaoColumn.setText("Descrição");
     descricaoColumn.setWidth(200);
  }
</pre></div>
  
      </div>
    </div><div class="section"><a name="Entendendo_callOnInit_e_resetSelection"></a><h2>Entendendo callOnInit e resetSelection</h2>
      <p>Uma variação no comportamento desta anotação ocorre com a utilização do 
      atributo <code>callOnInit</code>. Suponha que o combobox ou a tabela dos 
      exemplos acima não deveriam ser preenchidas na inicialização da janela em 
      questão. Neste caso, a anotação deveria ser reescrita da seguinte 
      forma:</p>

    <div class="source"><pre>
   // ...

   @DataProvider(objectField="estado", callOnInit=false)
   public List populaEstados() {
      // retorna uma Collection contendo instâncias de Estado
         }
    
   // ...
</pre></div>
  
      <p>Desta forma, na inicialização da janela, o combobox, list e tabela
      estarão vazios. O preenchimento dos mesmos poderá ser acionado mediante
      a anotação <code>@CallWhen</code>, usada em conjunto com 
      <code>@DataProvider</code> para indicar sob que condição a tabela, lista e 
      combo serão repopulados. <code>@Action</code> pode ser usado no mesmo 
      método caso este também possa ser acionado por um botão (como "Pesquisar", 
      por exemplo) e, quando isso ocorrer, o uso de <code>@EnabledWhen</code> e
      <code>@VisibleWhen</code> também será possível.</p>
      <p>O atributo <code>resetSelection</code> determina se os elementos serão
      desselecionados quando o método for invocado. Este é o comportamento
      padrão, ou seja, se omitido, o valor desse atributo é considerado
      <code>true</code>. Quando o valor informado é <code>false</code>, a
      seleção é mantida com respeito a <b>posição</b> dos ítens, o que torna
      essa funcionalidade mais útil quando algo está sendo adicionado ao final
      da <code>java.util.List</code> ou array cada vez que o método é
      executado.</p>
      <p>Para informações adicionais, consulte a referência da anotação <a href="quick_reference.html#@DataProvider">@DataProvider</a>.</p>
    </div></div></div><div class="clear"><hr></hr></div><div id="footer"><div class="xright">© 2004-2009, Summa Technologies do Brasil Ltda.</div><div class="clear"><hr></hr></div></div></body></html>