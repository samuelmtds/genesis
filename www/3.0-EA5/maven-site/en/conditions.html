<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><title>Working with conditions - genesis</title><style type="text/css" media="all">
          @import url("../style/maven-base.css");
          
          @import url("../style/maven-theme.css");</style><link rel="stylesheet" href="../style/print.css" type="text/css" media="print"></link><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta><meta name="author" content="Allan Jones Batista de Castro"></meta><meta name="email" content="allanjones@dev.java.net"></meta><meta name="author" content="Michael Nascimento Santos"></meta><meta name="email" content="mister__m@dev.java.net"></meta></head><body class="composite"><div id="banner"><a href="https://genesis.dev.java.net/" id="projectLogo"><img alt="SOL Genesis" src="../genesis.gif"></img></a><div class="clear"><hr></hr></div></div><div id="breadcrumbs"><div class="xleft">Last published: 13 December 2006
                <span class="separator">|</span> Doc for  3.0-EA5
                </div><div class="xright">
        
        <a href="../index.html">genesis</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-aspect/index.html">genesis-aspect</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-client/index.html">genesis-client</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-server/index.html">genesis-server</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-shared/index.html">genesis-shared</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../tags/genesis-tags.html">genesis-xdoclet</a>
      </div><div class="clear"><hr></hr></div></div><div id="leftColumn"><div id="navcolumn"><div id="menugenesis"><h5>genesis</h5><ul><li class="none"><a href="../en/index.html">Overview</a></li><li class="none"><a href="../en/download.html">Downloads</a></li><li class="none"><a href="../en/release_notes.html">Release notes</a></li></ul></div><div id="menuDocumentation"><h5>Documentation</h5><ul><li class="expanded"><a href="../en/documentation_intro.html">User manual</a><ul><li class="none"><a href="../en/documentation_intro.html">Introduction</a></li><li class="none"><a href="../en/annotations.html">Using annotations</a></li><li class="none"><a href="../en/startup.html">Configuring genesis at startup</a></li><li class="expanded"><a href="../en/remoting.html">Basic features</a><ul><li class="none"><a href="../en/remoting.html">Transparent remoting</a></li><li class="none"><a href="../en/transactions.html">Transaction support</a></li><li class="none"><a href="../en/hibernate_integration.html">Hibernate integration</a></li><li class="none"><a href="../en/binding.html">Binding</a></li><li class="none"><a href="../en/actions.html">Implementing mixed actions</a></li></ul></li><li class="expanded"><a href="../en/thinlet_binding.html">Thinlet-specific features</a><ul><li class="none"><a href="../en/thinlet_binding.html">Thinlet Binding</a></li><li class="none"><a href="../en/customizing_widgets_creation.html">Customizing widget creation</a></li></ul></li><li class="expanded"><a href="../en/configuring_swt.html">SWT-specific features</a><ul><li class="none"><a href="../en/configuring_swt.html">Configuring SWT libraries</a></li></ul></li><li class="expanded"><strong><a href="../en/conditions.html">Additional features</a></strong><ul><li class="none"><strong><a href="../en/conditions.html">Working with conditions</a></strong></li><li class="none"><a href="../en/populating_with_dataproviders.html">Populating comboboxes, lists and tables</a></li><li class="none"><a href="../en/formatting.html">Formatting data</a></li><li class="none"><a href="../en/handling_errors.html">Handling errors</a></li><li class="none"><a href="../en/validating_data.html">Validating data</a></li><li class="none"><a href="../en/configuring_messages.html">Configuring messages</a></li><li class="none"><a href="../en/paging_and_dynamic_search.html">Paging and dynamic queries</a></li></ul></li><li class="none"><a href="../en/quick_reference.html">Annotation quick reference guide</a></li></ul></li><li class="expanded"><a href="../en/empty_project.html">Developing with genesis</a><ul><li class="none"><a href="../en/empty_project.html">For desktops</a></li><li class="none"><a href="../en/empty_web_project.html">For web</a></li></ul></li><li class="none"><a href="../en/useradmin_sample.html">Using the UserAdmin sample</a></li><li class="expanded"><a href="../en/advanced_introduction.html">Advanced guide</a><ul><li class="none"><a href="../en/xdoclet_extensions.html">XDoclet extensions</a></li><li class="none"><a href="../en/aspects.html">genesis aspects</a></li><li class="none"><a href="../en/generic_scripting.html">Generic scripting support</a></li><li class="none"><a href="../en/lookup_strategy.html">Widget lookup strategies</a></li><li class="none"><a href="../en/widget_binder.html">Customizing widget binding</a></li></ul></li><li class="none"><a href="../en/faq.html">FAQ</a></li><li class="none"><a href="http://wiki.java.net/bin/view/Projects/GenesisRoadmap" class="externalLink" title="External Link">Roadmap</a></li><li class="none"><a href="http://wiki.java.net/bin/view/Projects/Genesis" class="externalLink" title="External Link">Wiki</a></li></ul></div><div id="menuProject_Documentation"><h5>Project Documentation</h5><ul><li class="none"><a href="../index.html">About</a></li><li class="collapsed"><a href="../project-info.html">Project Info</a></li><li class="collapsed"><a href="../maven-reports.html">Project Reports</a></li><li class="none"><a href="http://maven.apache.org/development-process.html" class="externalLink" title="External Link">Development Process</a></li></ul></div><div id="menujava_net"><h5>java.net</h5><ul><li class="none"><a href="https://genesis.dev.java.net" class="externalLink" title="External Link">genesis.dev.java.net</a></li><li class="none"><a href="http://java.net" class="externalLink" title="External Link"><img title="java.net member" style="border: 1px" src="../java_dot_net_member.bmp" alt="java.net member"></img></a></li></ul></div><div id="legend"><h5>Legend</h5><ul><li class="externalLink">External Link</li><li class="newWindow">Opens in a new window</li></ul></div><a href="http://maven.apache.org/" title="Built by Maven" id="poweredBy"><img alt="Built by Maven" src="../images/logos/maven-button-1.png"></img></a></div></div><div id="bodyColumn"><div class="contentBox"><div class="section"><a name="Working_with_conditions"></a><h2>Working with conditions</h2>
      <p>A powerful concept in genesis is support for conditions. This support
      is the basis for several features, such as controlling the enabled state 
      of a widget, its visibility, automatically clearing fields and 
      automatically calling a method. All these things are done 
      declaratively in the form, with no need to deal with the graphical API
      used for views.</p>
      <div class="subsection"><a name="Enabling_and_disabling_components"></a><h3>Enabling and disabling components</h3>
        <p>It's fairly common in UI development to find a situation where a 
        certain field or button can only be enabled if a certain condition is 
        true. In order to simplify implementing such cases, genesis provides an 
        annotation called <code>@EnabledWhen</code>. This annotation can be used 
        in attributes and actions. A practical usage example is shown below:</p>

    <div class="source"><pre>
@Form
public class EnabledWhenFormExample {
   private boolean married;
   private String spouseName;

   public boolean isMarried() {
      return married;
   }

   public void setMarried(boolean married) {
      this.married = married;
   }

   @EnabledWhen("form.married")
   public String getSpouseName() {
      return spouseName;
   }

   public void setSpouseName(String spouseName) {
      this.spouseName = spouseName;
   }
}
</pre></div>
  
        <p>In the example above, it will be possible to enter the spouse's name 
        only when the widget representing property <code>married</code> is
        <code>true</code> .</p>
      </div>
      <div class="subsection"><a name="Controlling_visibility"></a><h3>Controlling visibility</h3>
        <p>It's possible to hide or show widgets conditionally using the
        <code>@VisibleWhen</code> annotation . Its syntax is similar to the one
        for <code>@EnabledWhen</code> and it also may be used to annotate
        attributes or actions. A usage example in an action is shown below:</p>

    <div class="source"><pre>
@Form
public class VisibleWhenFormExample {
   private int dependantNumber;

   public int getDependantNumber() {
      return dependantNumber;
   }

   public void setDependantNumber(int dependantNumber) {
      this.dependantNumber = dependantNumber;
   }

   @Action
   @VisibleWhen("form.dependantNumber &gt; 0")
   public void calculateAdditionalTaxes() {
      // ...
   }

   // ...
}
</pre></div>
  
        <p>The button representing <code>calculateAdditionalTaxes()</code> will
        be visible only when <code>dependantNumber</code> is greater than zero.
        </p>
      </div>
      <div class="subsection"><a name="Widget_groups"></a><h3>Widget groups</h3>
        <p>In many cases, some operations need to be executed for a group of 
        widgets. For example, it might be necessary to make a whole group 
        visible or enabled at once. In order to understand how to achieve that, 
        let's examine a pratical example. Below, we have the same user interface 
        coded in Thinlet, Swing and SWT:</p>

    <div class="source"><pre>

...
&lt;label text="Current Date:" font="bold"/&gt;
&lt;panel width="10" height="1" /&gt;
&lt;textfield name="currentDate" /&gt;
...

</pre></div>
  

    <div class="source"><pre>

//..
getContentPane().setLayout(new GridLayout(1, 2, 10, 0));

JLabel currentDateLabel = new JLabel();
currentDateLabel.setText("Current Date:");
getContentPane().add(currentDateLabel);

JTextField currentDate = new javax.swing.JTextField();
currentDate.setName("currentDate");
getContentPane().add(currentDate);

//..

</pre></div>
  

    <div class="source"><pre>

//..
shell = new Shell(SWT.TITLE | SWT.CLOSE);

Label currentDateLabel = new Label(shell, SWT.NONE);
currentDateLabel.setText("Current Date:");

Text currentDate = new Text(shell, SWT.BORDER);
currentDate.setData("currentDate");

//..

</pre></div>
  
        <p>For all interfaces above, the developer's intention is to show the 
        "Current Date" field only if certain conditions are matched. To make 
        it happen, the <code>@VisibleWhen</code> annotation is used as the 
        following code snippet shows:</p>

    <div class="source"><pre>
@VisibleWhen("certainConditions")
public Date getCurrentDate() {
   ...
}
</pre></div>
  
        <p>However, what actually happens is that only the text field
        (<code>textfield</code>/<code>JTextField</code>/<code>Text</code>)
        will become invisible (if conditions are not satisfied). Notice that the
        <code>label</code>/<code>JLabel</code>/<code>Label</code>
        and the <code>panel</code> (used for spacing in Thinlet) will not become 
        invisible - clearly, this is not what was originally intended. All three 
        controls should follow the same visibility rules.</p>
        <p>In order to fix it, we need to use the <code>widgetGoup</code>
        property of the <code>textfield</code> thinlet xml attribute - see
        the following usage:</p>

    <div class="source"><pre>

...
&lt;label name="currentDateLabel" text="Current Date:" font="bold"/&gt;
&lt;panel name="currentDateSpace" width="10" height="1" /&gt;
&lt;textfield name="currentDate"
      property="widgetGroup=currentDateLabel,currentDateSpace"/&gt;
...

</pre></div>
  
        <p>Notice that the widgets <code>label</code> and <code>panel</code>
        are now named and referred by the <code>widgetGroup</code> property,
        separated by a comma.</p>
        <p>For Swing, we should define a <code>clientProperty</code> named
        <code>SwingBinder.WIDGET_GROUP_PROPERTY</code> and for SWT,
        we should define a metadata (<code>data</code>) named
        <code>SWTBinder.WIDGET_GROUP_PROPERTY</code> as shown below:</p>

    <div class="source"><pre>

//..
getContentPane().setLayout(new GridLayout(1, 2, 10, 0));

JLabel currentDateLabel = currentDateLabel = new JLabel();
currentDateLabel.setName("currentDateLabel");
currentDateLabel.setText("Current Date:");
getContentPane().add(currentDateLabel);

JTextField currentDate = new javax.swing.JTextField();
currentDate.setName("currentDate");
currentDate.putClientProperty(SwingBinder.WIDGET_GROUP_PROPERTY, "currentDateLabel");
getContentPane().add(currentDate);

//..

</pre></div>
  

    <div class="source"><pre>

//..
shell = new Shell(SWT.TITLE | SWT.CLOSE);

Label currentDateLabel = new Label(shell, SWT.NONE);
currentDateLabel.setText("Data Corrente:");

Text currentDate = new Text(shell, SWT.BORDER);
currentDate.setData("dataCorrente");
currentDate.setData(SWTBinder.WIDGET_GROUP_PROPERTY, "currentDateLabel");
//..

</pre></div>
  
        <p>Notice that the value of the 
        <code>clientProperty</code>/<code>data</code> is the 
        <code>name</code>/<code>data</code> of the 
        <code>JLabel</code>/<code>Label</code> instance. If there were
        additional components, their names should be comma-separated or a 
        <code>String</code> array could be used instead. Other valid values for
        <code>clientProperty</code>/<code>data</code> would be the component 
        itself or a collection/array of components, as shown below:</p>

    <div class="source"><pre>
//..
getContentPane().setLayout(new GridLayout(1, 2, 10, 0));

JLabel currentDateLabel = currentDateLabel = new JLabel();
currentDateLabel.setName("currentDateLabel");
currentDateLabel.setText("Data Corrente:");
getContentPane().add(currentDateLabel);

JTextField currentDate = new javax.swing.JTextField();
currentDate.setName("currentDate");
currentDate.putClientProperty(SwingBinder.WIDGET_GROUP_PROPERTY, <b>currentDateLabel</b>);
getContentPane().add(currentDate);

//..
</pre></div>
  

    <div class="source"><pre>
//..
shell = new Shell(SWT.TITLE | SWT.CLOSE);

Label currentDateLabel = new Label(shell, SWT.NONE);
currentDateLabel.setText("Data Corrente:");

Text currentDate = new Text(shell, SWT.BORDER);
currentDate.setData("currentDate");
currentDate.setData(SWTBinder.WIDGET_GROUP_PROPERTY, <b>currentDateLabel</b>);
//..
</pre></div>
  
        <p>By defining this property, all widgets will follow the visibility 
        rule defined by the annotation above.</p>
        <p>Besides the <code>widgetGroup</code> property, there are two more
        specific properties, <code>enabledWidgetGroup</code>
        and <code>visibleWidgetGroup</code>, that define independent groups for 
        enabling/disabling and visible/invisible rules. These properties are 
        provided because it is common to have different groups for these rules. 
        For example:</p>

    <div class="source"><pre>

...
&lt;label name="clientLabel" text="Client:" font="bold"/&gt;
&lt;panel name="clientSpace1" width="10" height="1" /&gt;
&lt;textfield name="clientCode" ... /&gt;
&lt;panel name="clientSpace2" width="10" height="1" /&gt;
&lt;textfield name="clientName"
      property="enabledWidgetGroup=clientCode;
            visibleWidgetGroup=clientLabel,clientSpace1,
                               clientCode,clientSpace2"/&gt;
...

</pre></div>
  
        <p>By using these properties, it is possible to define a 
        enabling/disabling rule that will affect only <code>clientCode</code> 
        and <code>clientName</code> and a visibility rule that will affect the 
        whole group, including the label and all panels for spacing.</p>
        <p>For Swing, <code>SwingBinder.ENABLED_GROUP_PROPERTY</code> and
        <code>SwingBinder.VISIBLE_GROUP_PROPERTY</code> can be used as 
        <code>clientProperty</code>s.
        For SWT,
        <code>SWTBinder.ENABLED_GROUP_PROPERTY</code> and
        <code>SWTBinder.VISIBLE_GROUP_PROPERTY</code>
        can be used as metadata (<code>data</code>s).</p>
      </div>
      <div class="subsection"><a name="Clearing_field_content"></a><h3>Clearing field content</h3>
        <p>Under many conditions it is necessary to clear the content of some 
        fields. genesis can do that automatically for the programmer if the
        <code>@ClearOn</code> annotation is used. Although its syntax is similar 
        to <code>@EnabledWhen</code> and <code>@VisibleWhen</code> syntax, this
        annotation can only be used for attributes and not for actions (since
        actions do not have content). A previous example may be modified to 
        become more correct:</p>

    <div class="source"><pre>
@Form
public class ClearOnFormExample {
   private boolean married;
   private String spouseName;

   public boolean isMarried() {
      return married;
   }

   public void setMarried(boolean married) {
      this.married = married;
   }

   @EnabledWhen("form.married")
   @ClearOn("!form.married")
   public String getSpouseName() {
      return spouseName;
   }

   public void setSpouseName(String spouseName) {
      this.spouseName = spouseName;
   }
}
</pre></div>
  
        <p>When property <code>married</code> is <code>false</code>,
        <code>spouseName</code> will be automatically reset to
        <code>null</code>.</p>
        <p>The value used for resetting is defined by <code>@EmptyValue</code>.
        This annotation should be used for the attribute whose empty value is
        being specified. Its syntax is:</p>

    <div class="source"><pre>
@EmptyValue("value")
</pre></div>
  
        <p>If <code>@EmptyValue</code> is not specified, a default value is used
        instead - <code>false</code> for booleans, zero for numeric types and
        <code>null</code> otherwise.</p>
        <p>The annotation <code>@ClearOn</code> can be used together with
        <code>@DataProvider</code> annotation. The DataProviders widgets will
        be cleaned and the form properties that store selected values will be
        automatically reset to <code>null</code> when script condition is satisfied.
        See the following usage:</p>

    <div class="source"><pre>
   @DataProvider(objectField="state")
   @ClearOn("&lt;some script condition&gt;")
   public List populateStates() {
      ...
   }
</pre></div>
  
      </div>
      <div class="subsection"><a name="Automatically_invoking_methods"></a><h3>Automatically invoking methods</h3>
        <p>Some methods need to be called every time certain conditions are
        true. Instead of forcing programmers to do that manually - what can lead
        to the so-called "spaghetti" code -, genesis defines the
        <code>@CallWhen</code> annotation. With a syntax similar to previous
        annotations, it can be used only for actions and not for attributes.</p>
        <p>A previous example can be modified to show how to use this annotation
        in practice:</p>

    <div class="source"><pre>
@Form
public class CallWhenFormExample {
   private int dependantNumber;

   public int getDependantNumber() {
      return dependantNumber;
   }

   public void setDependantNumber(int dependantNumber) {
      this.dependantNumber = dependantNumber;
   }

   @Action
   @CallWhen("form.dependantNumber &gt; 0")
   public void calculateAdditionalTaxes() {
      // ...
   }
}
</pre></div>
  
        <p>Differently from the original <code>@VisibleWhen</code> example,
        <code>calculateAdditionalTaxes()</code> will be invoked automatically by
        genesis whenever <code>dependantNumber</code> is greater than zero.</p>
      </div>
      <div class="subsection"><a name="Declaring_conditions"></a><h3>Declaring conditions</h3>
        <p>Although all anotations that have script conditions as arguments are
        capable of handling any type of expression, certain conditions may be
        used repeatedly in the code or as part of another expression. Due to
        that fact, genesis makes it possible to declare these conditions and 
        export them as variables that may be referenced in other points of code.
        The <code>@Condition</code> annotation is used to declare a condition
        and its syntax is:</p>

    <div class="source"><pre>
@Condition("conditionName=scriptExpression")
</pre></div>
  
        <p>The variable named <code>conditionName</code> is exported in order to
        represent the expression <code>scriptExpression</code> in other points
        in the code. How to reference such a variable in script expressions is
        language-dependent.</p>
        <p>This annotation may be used at class level, in an attribute getter or
        in a method annotated as <code>@Action</code>. Its scope will always be
        class-wide, no matter where it's declared. Obviously, this annotation is
        useful only when used together with another conditional annotation that
        references the exported variable, as the ones mentioned above.</p>
      </div>
    </div><div class="section"><a name="Determining_if_a_field_is_empty"></a><h2>Determining if a field is empty</h2>
      <p>In order to perform or not to perform some operations, genesis needs to
      determine whether a field is empty. Besides that, whether a field is
      filled or empty is usually used to define a condition for some genesis'
      annotations. Interface <code>EmptyResolver</code>, defined on
      <code>net.java.dev.genesis.resolvers</code> is used for that.</p>
      <p>This interface exposes a single method ,<code>isEmpty(Object)</code>,
      that returns a <code>boolean</code>. To specify which
      <code>EmptyResolver</code> implementation should be used for a certain 
      attribute, it should be annotationed with <code>@EmptyResolver</code>. Its 
      syntax is:</p>

    <div class="source"><pre>
@EmptyResolver(value=&lt;classThatImplementsInterface&gt;,
               properties=&lt;attributes&gt;)
</pre></div>
  
      <p>In order to avoid requiring the definition of an 
      <code>EmptyResolver</code> implementation for every attribute in each form 
      in an application, genesis has a mechanism for determining which 
      implementation should be used based on the type of the attribute.
      The <code>EmptyResolverRegistry</code> class keeps a registry of default
      <code>EmptyResolver</code> implementations per class. The following
      implementations are initially set up:</p>
      <ul>
        <li><code>MapEmptyResolver</code> is registered for
        <code>java.util.Map</code> instances. Returns <code>true</code> when the
        value is null or when <code>java.util.Map.isEmpty()</code> returns 
        <code>true</code>.</li>
        <li><code>CollectionEmptyResolver</code> is the default implementation
        for <code>java.util.Collection</code>. It uses the same principle that
        <code>MapEmptyResolver</code> does in order to determine whether an
        instance is empty or not.</li>
        <li>The default implementation for <code>String</code> is
        <code>StringEmptyResolver</code>. Instances are considered empty if they
        are null or have zero length after spaces are removed, i.e., 
        <code>s == null || s.trim().length() == 0</code>.</li>
        <li>For the remaining cases, a <code>DefaultEmptyResolver</code> 
        instance is registered. This implementation considers as empty null 
        instances or zero-element arrays.</li>
      </ul>
      <p>These default implementations should work fine for most cases. As an 
      example of how to customize if necessary, let's consider how to use the 
      annotation in a form attribute for which empty spaces are actually 
      relevant:</p>

    <div class="source"><pre>
@EmptyResolver(properties="trim=false")
public String getAttribute() {
   return attribute;
}
</pre></div>
  
      <p>Since <code>String</code> has a <code>EmptyResolver</code> instance
      registered default for it, <code>StringEmptyResolver</code>, and this 
      implementation exposes an attribute that allows one to configure
      whether spaces should be removed or not, it's not necessary to specify the
      name of the interface implementation class and defining 
      property <code>trim</code> as <code>false</code> solves the problem. If 
      using the default instance weren't suitable, another implementation could 
      be used instead, as shown here:</p>

    <div class="source"><pre>
@EmptyResolver(com.company.package.EmptyResolverImplementation.class)
public String getAttribute() {
   return attribute;
}
</pre></div>
  
      <div class="subsection"><a name="Verifying_if_a_field_is_empty_in_conditional_______expressions"></a><h3>Verifying if a field is empty in conditional       expressions</h3>
        <p>As already mentioned, it's usual to define conditions that are based 
        on a field being empty or not. genesis exposes script
        auxiliary functions that may be used in conditions in order to make this
        task easier: <code>isEmpty(any)</code> and 
        <code>isNotEmpty(any)</code>.</p>
        <p>When the argument is a form property, the <code>EmptyResolver</code>
        instance configured for the property - determined as explained above - 
        is used to evaluate the return value. If the argument is a variable or a 
        constant, a <code>EmptyResolver</code> implementation for the expression 
        type is obtained from <code>EmptyResolverRegistry</code> and used for
        evaluation. These functions may be used with 
        <a href="generic_scripting.html">Javascript</a> as shown below:</p>

    <div class="source"><pre>
public String getAttribute() {
   return attribute;
}

public void setAttribute(String attribute) {
   this.attribute = attribute;
}

@EnabledWhen("genesis.isNotEmpty('form:attribute')")
public String getDependantAttribute() {
   return dependantAttribute;
}

public void setDependantAttribute(String dependantAttribute) {
   this.dependantAttribute = dependantAttribute;
}
</pre></div>
  
        <p>Notice that <code>'form:attribute'</code> is informed as the function 
        parameter. This is required in order to use the value of 
        <code>attribute</code> instead of the <code>'attribute'</code> literal 
        as an argument.</p>
        <p>Which syntax to use for this function for other programming languages
        can be checked at the <a href="quick_reference.html#genesis_script_functions">annotation quick 
        reference guide</a>.</p>
      </div>
    </div><div class="section"><a name="Comparing_values"></a><h2>Comparing values</h2>
      <p>Both the framework and developers ocasionally need to check if a field
      value has been changed or if its value is equal to some constant or
      another field's value. Interface <code>EqualityComparator</code> contained
      in the <code>net.java.dev.genesis.equality</code> package is implemented 
      by classes that are capable of making such a decision.</p>
      <p>This interface defines the <code>equals(Object,Object)</code> method 
      that returns a <code>boolean</code> indicating whether compared instances 
      are equal or not. The annotation with the same name, 
      <code>@EqualityComparator</code>, can be used to explicitly define the 
      implementation to be used for an attribute. Its syntax is similar to 
      <code>@EmptyResolver</code>'s one:</p>

    <div class="source"><pre>
@EqualityComparator(value=&lt;classThatImplementsInterface&gt;,
                    properties=&lt;attributes&gt;)
</pre></div>
  
      <p>Usually it won't be necessary to use this annotation since genesis also
      has a default mechanism for determining which interface implementation
      should be used for a given attribute. The mapping between class and 
      implementation is kept by <code>EqualityComparatorRegistry</code>. The 
      implementations registered by default are:</p>
      <ul>
        <li><code>BigDecimalEqualityComparator</code> considers two
        <code>java.math.BigDecimal</code> instances equal if both are null or
        if calling <code>compareTo(BigDecimal)</code> for one of them returns 
        zero.</li>
        <li><code>StringEqualityComparator</code> considers null or zero-length
        trimmed <code>String</code>s equal. They'll also be considered equal if
        <code>s1.trim().equals(s2.trim())</code>.</li>
        <li>All the remaining cases are handled by 
        <code>DefaultEqualityComparator</code>, that considers two instances to 
        be equal if both are null or if <code>o1.equals(o2)</code> returns 
        <code>true</code>.</li>
      </ul>
      <div class="subsection"><a name="Verifying_field_value_changes_and_doing_comparisson_in___________conditional_expressions"></a><h3>Verifying field value changes and doing comparisson in           conditional expressions</h3>
        <p>Some script functions are exported by genesis in order to help
        developers in common tasks:</p>
        <ul>
          <li><code>hasChanged(property)</code> and
          <code>hasNotChanged(property)</code> verify whether a field value
          has changed or not.</li>
          <li><code>equals(any,any)</code> and
          <code>notEquals(any,any)</code> compare two values - that may be
          constants, form properties or variables - and return the comparisson
          result.</li>
        </ul>
        <p>genesis internally keeps track of what fields had their value changed 
        in the current iteraction. This list is checked by functions
        <code>hasChanged(property)</code> and
        <code>hasNotChanged(property)</code>. To determine whether a value
        has been changed or not and to populate this internal list, the
        framework uses the <code>EqualityComparator</code> instance configured
        for the property.</p>
        <p>Functions <code>equals(any,any)</code> and
        <code>notEquals(any,any)</code> also make use of
        <code>EqualityComparator</code> instances to determine their output.
        However, the actual process used for that is a bit more complicated, as
        explained below:</p>
        <ul>
          <li>First, which <code>EqualityComparator</code> instance to use for 
          each parameter is determined. If the parameter is a form property, 
          the implementation configured for it will be used. Otherwise, the 
          implementation registered in <code>EqualityComparatorRegistry</code> 
          for the type will be picked up.</li>
          <li>If comparators for both parameters are the same, the first one of
          them will be used to do the comparisson.</li>
          <li>If the first parameter type is assignable to the second parameter
          type, its <code>EqualityComparator</code> instance will be used for
          performing the comparisson.</li>
          <li>If the second parameter type is assignable to the first parameter 
          type, its <code>EqualityComparator</code> instance will be used for 
          performing the comparisson.</li>
          <li>If none of the above conditions is true, <code>false</code> will
          be returned.</li>
        </ul>
        <p>Let's see how to use one function of each pair using <a href="generic_scripting.html">Javascript</a>:</p>

    <div class="source"><pre>
public BigDecimal getTax() {
   return tax;
}

public void setTax(BigDecimal tax) {
   this.taxa = tax;
}

@Action
@CallWhen("genesis.hasChanged('form:tax')")
public void recalculateValues() {
   // logic for recalculating
}
</pre></div>
  

    <div class="source"><pre>
public BigDecimal getDebt() {
   return debt;
}

public void setDebt(BigDecimal debt) {
   this.debt = debt;
}

public BigDecimal getPaidAmount() {
   return paidAmount;
}

public void setPaidAmount(BigDecimal paidAmount) {
   this.paidAmount = paidAmount;
}

@Action
@CallWhen("genesis.notEquals('form:debt', 'form:paidAmount')")
public void calculateRemainingAmount() {
   // logic for calculating amount
}
</pre></div>
  
      </div>
      <div class="subsection"><a name="Changing_the_way_values_are_cloned"></a><h3>Changing the way values are cloned</h3>
         <p>In previous releases, property values were just copied as part of 
         form state, what limited the way change detection worked. For example, 
         if the value of a property was a JavaBean and one of its own properties 
         changed, it was not possible to detect this change by using 
         <code>genesis.hasChanged('form:property')</code>, since both the 
         previous state copy that genesis hold and the current value would point 
         to the same instance in memory.</p>
         <p>Starting from release 2.3, a new API has been introduced that allows
         to control how genesis generates a copy of the previous value of a 
         property. The <code>net.java.dev.genesis.cloning.Cloner</code> 
         interface has a single <code>clone(Object)</code> method that returns 
         the value genesis is suposed to keep as a copy of the value used as an
         argument to the call. The default implementation of that interface - 
         provided by <code>net.java.dev.genesis.cloning.DefaultCloner</code> - 
         simply returns the value used as a parameter, thus preserving backwards 
         compatibility.</p>
         <p>In a way similar to <code>EqualityComparator</code>, there is a 
         registry, <code>net.java.dev.genesis.cloning.ClonerRegistry</code>, 
         that associates <code>Cloner</code> implementations with the classes 
         used for properties, as well as an annotation, <code>@Cloner</code>, 
         that allows <code>Cloner</code> implementations to be overridden on a 
         property basis.</p>
         <p>The following code shows how to override the <code>Cloner</code> 
         implementation both globally and for a specific bean property:</p>

    <div class="source"><pre>
ClonerRegistry.getInstance().register(User.class, new BeanUtilsCloner());
</pre></div>
  

    <div class="source"><pre>
@Form
public class ClonerFormExample {
   @Cloner(net.java.dev.genesis.cloning.BeanUtilsCloner.class)
   public User getUser() {
      // ...
   }

   // ...
}
</pre></div>
  
         <p>The class used in both examples above,  
         <code>net.java.dev.genesis.cloning.BeanUtilsCloner</code>, is the other 
         implementation provided by genesis that clones the value using the 
         Commons BeanUtils API.</p>
      </div>
    </div></div></div><div class="clear"><hr></hr></div><div id="footer"><div class="xright">© 2004-2006, Summa Tecnologies do Brasil Ltda.</div><div class="clear"><hr></hr></div></div></body></html>