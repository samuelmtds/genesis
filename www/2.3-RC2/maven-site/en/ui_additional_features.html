<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><title>User interface component model - genesis</title><style type="text/css" media="all">
          @import url("../style/maven-base.css");
          
          @import url("../style/maven-theme.css");</style><link rel="stylesheet" href="../style/print.css" type="text/css" media="print"></link><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta><meta name="author" content="Michael Nascimento Santos"></meta><meta name="email" content="mister__m@dev.java.net"></meta></head><body class="composite"><div id="banner"><a href="https://genesis.dev.java.net/" id="projectLogo"><img alt="SOL Genesis" src="../genesis.gif"></img></a><div class="clear"><hr></hr></div></div><div id="breadcrumbs"><div class="xleft">Last published: 14 December 2005
                <span class="separator">|</span> Doc for  2.3-RC2
                </div><div class="xright">
        
        <a href="../index.html">genesis</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-server/index.html">genesis-server</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-client/index.html">genesis-client</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-shared/index.html">genesis-shared</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-aspect/index.html">genesis-aspect</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../tags/genesis-tags.html">genesis-xdoclet</a>
      </div><div class="clear"><hr></hr></div></div><div id="leftColumn"><div id="navcolumn"><div id="menugenesis"><h5>genesis</h5><ul><li class="none"><a href="../en/index.html">Overview</a></li><li class="none"><a href="../en/screenshots.html">Screenshots</a></li><li class="none"><a href="../en/download.html">Downloads</a></li><li class="none"><a href="../en/release_notes.html">Release notes</a></li></ul></div><div id="menuDocumentation"><h5>Documentation</h5><ul><li class="expanded"><a href="../en/documentation_intro.html">User manual</a><ul><li class="none"><a href="../en/documentation_intro.html">Introduction</a></li><li class="expanded"><a href="../en/ui_basic_concepts.html">UI component model</a><ul><li class="none"><a href="../en/ui_basic_concepts.html">Basic concepts</a></li><li class="none"><strong><a href="../en/ui_additional_features.html">Additional features</a></strong></li></ul></li><li class="none"><a href="../en/business_component_model.html">Business component model</a></li><li class="none"><a href="../en/quick_reference.html">Annotation quick reference guide</a></li><li class="none"><a href="../en/xdoclet_extensions.html">XDoclet extensions</a></li></ul></li><li class="none"><a href="../en/jars_explained.html">Understanding genesis jars</a></li><li class="none"><a href="../en/empty_project.html">Developing with genesis</a></li><li class="none"><a href="../en/useradmin_sample.html">Using the UserAdmin sample</a></li><li class="collapsed"><a href="../en/advanced_introduction.html">Advanced guide</a></li><li class="none"><a href="../en/faq.html">FAQ</a></li><li class="none"><a href="http://wiki.java.net/bin/view/Projects/GenesisRoadmap" class="externalLink" title="External Link">Roadmap</a></li><li class="none"><a href="http://wiki.java.net/bin/view/Projects/Genesis" class="externalLink" title="External Link">Wiki</a></li></ul></div><div id="menuProject_Documentation"><h5>Project Documentation</h5><ul><li class="none"><a href="../index.html">About</a></li><li class="collapsed"><a href="../project-info.html">Project Info</a></li><li class="collapsed"><a href="../maven-reports.html">Project Reports</a></li><li class="none"><a href="http://maven.apache.org/development-process.html" class="externalLink" title="External Link">Development Process</a></li></ul></div><div id="menujava_net"><h5>java.net</h5><ul><li class="none"><a href="https://genesis.dev.java.net" class="externalLink" title="External Link">genesis.dev.java.net</a></li><li class="none"><a href="http://java.net" class="externalLink" title="External Link"><img title="java.net member" style="border: 1px" src="../java_dot_net_member.bmp" alt="java.net member"></img></a></li></ul></div><div id="legend"><h5>Legend</h5><ul><li class="externalLink">External Link</li><li class="newWindow">Opens in a new window</li></ul></div><a href="http://maven.apache.org/" title="Built by Maven" id="poweredBy"><img alt="Built by Maven" src="../images/logos/maven-button-1.png"></img></a></div></div><div id="bodyColumn"><div class="contentBox"><div class="section"><a name="UI_components_additional_features"></a><h2>UI components additional features</h2>
      <p>The following features and/or concepts are explained below:
      <ul>
        <li><a href="#Using_POJOs_to_handle_events">Using POJOs to handle
        events</a></li>
        <li><a href="#Handling_errors">Handling errors</a></li>
        <li><a href="#Conditionally_controlling_a_form_and_a_UI">Conditionally controlling a form and a UI</a></li>
        <li><a href="#Determining_if_a_field_is_empty">Determining if a field is
        empty</a></li>
        <li><a href="#Comparing_values">Comparing values</a></li>
        <li><a href="#Populating_comboboxes__lists_and_tables">Populating
        comboboxes, lists and tables</a>
        </li>
        <li><a href="#Formatting">Formatting</a></li>
        <li><a href="#Customizing_how_components_are_created">Customizing how 
        components are created</a></li>
        <li><a href="#Validating_data">Validating data</a></li>
        <li><a href="#Configuring_messages">Configuring messages</a>
        </li>
        <li><a href="#Working_with_dynamic_searches">Working with dynamic
        searches</a></li>
      </ul>
      </p>
    </div><div class="section"><a name="Using_POJOs_to_handle_events"></a><h2>Using POJOs to handle events</h2>
      <p>The Thinlet API allows arbritary objects (POJOs) to be used to handle
      events produced by the graphical interface, by using the
      <code>parse(.., Object handler)</code> method. Since this is a native
      Thinlet method, nothing is needed to take advantage of this feature in
      genesis.</p>
      <p>However, in some architectures it would be nice to use these objects
      not only for handling Thinlet events, but also to implement methods
      annotated as <code>@BeforeAction</code> and/or
      <code>@AfterAction</code>. To allow that, a new annotation,
      <code>@ViewHandler</code>, has been introduced since release 2.1 and
      should be used in the class containing these methods. New overloaded
      versions of the <code>bind(..)</code> and <code>prepareBinder(..)</code>
      have been created, receiving as an additional parameter the object that
      will be used to handle events.</p>
      <p>This feature may be used as shown below:</p>

    <div class="source"><pre>
public class ViewHandlerExampleView extends BaseDialogThinlet {
   public ViewHandlerExampleView(Frame frame) throws Exception {
      super(frame);

      // code for view setup

      Object handler = new ViewHandlerExample(this);
      add(parse("view.xml", handler));

      bind(this, new ViewHandlerExampleForm(), handler);
   }
}
</pre></div>
  


    <div class="source"><pre>
/**
 * @Form
 */
public class ViewHandlerExampleForm {
   /**
    * @Action
    */
   public void remove() {
      // removal logic
   }
}
</pre></div>
  


    <div class="source"><pre>
/**
 * @ViewHandler
 */
public class ViewHandlerExample {
   private final ViewHandlerExampleView view;

   public ViewHandlerExample(ViewHandlerExampleView view) {
      this.view = view;
   }

   /**
    * @BeforeAction
    */
    public boolean remove() {
       return OptionDialog.displayYesNo(view, "Confirmation",
             "Are you sure you want to remove it?") == OptionDialog.Option.YES;
    }
}
</pre></div>
  
    </div><div class="section"><a name="Handling_errors"></a><h2>Handling errors</h2>
      <p>Thinlet has got a method for handling errors, <code>
      handleException(Throwable)</code>, so <code>BaseThinlet</code> overrides
      this method in order to implement custom error handling. We've been
      careful while developing genesis so that any error that happens get
      redirected to this single point, centralizing error handling.</p>
      <p>The default error handling implementation in genesis works in a case-
      by-case basis, as explained below:</p>
      <ul>
        <li>If the error is an instance of <code>ScreenNotFoundException</code>
        (that is thrown when a UI xml file is not found), the error is handled
        using <code>handleException(String, Throwable)</code>.</li>
        <li>If a <code>ValidationException</code> has happened, it is handled by
        <code>showValidationErrors(ValidationException)</code>.</li>
        <li>When the error is a <code>UIException</code>, it's handled by <code>
        handleUIException(UIException)</code>.</li>
        <li>If all previous checks fail, the exception is passed to
        <code>handleCustomException(Throwable)</code> that returns a
        <code>boolean</code> indicating whether the error has been handled or
        not.</li>
        <li>When an error hasn't been handled,
        <code>handleUnknownException(Throwable)</code> gets invoked, ending the
        error handling chain.</li>
      </ul>
      <p>For most users, it's enough to know how each error will be handled by
      the framework. However, any of the above described methods can be
      overridden if there is a need to customize error handling. Each method's
      default behaviour is described below:</p>
      <ul>
         <li><code>handleException(String, Throwable)</code> uses
         <code>ErrorReporterDialog</code> to display the error. The message
         returned by <code>getErrorMessage()</code> is used as the window title,
         whose default is the constant "Error".</li>
         <li><code>showValidationErrors(ValidationException)</code> extracts
         errors from <code>ValidationException</code>, formats them by putting a
         <code>\n</code> - used for breaking lines - between them and finally
         displays them with a <code>MessageDialog</code>. The window title will
         be the String value for <code>validation.errors.title</code> in the
         <a href="#Configuring_messages">resource file</a>.</li>
         <li><code>handleUIException(UIException)</code> displays the error
         using a <code>MessageDialog</code>. Title and message will be extracted
         from the exception itself.</li>
         <li><code>handleCustomException(Throwable)</code> checks if the error
         has another exception as its cause by invoking <code>getCause()</code>
         in the exception instance. If it has got a cause, this cause will be
         forwarded to <code>handleException(Throwable)</code>. Otherwise,
         <code>false</code> will be returned to indicate the error cannot be
         handled.</li>
         <li><code>handleUnknownException(Throwable)</code> simply forwards the
         error to <code>handleException(String, Throwable)</code> using the
         constant "Unexpected error occurred" as the error message.</li>
      </ul>
    </div><div class="section"><a name="Conditionally_controlling_a_form_and_a_UI"></a><h2>Conditionally controlling a form and a UI</h2>
      <p>A powerful concept in genesis is support for conditions. This supprt
      allows implementation of a variety of features, such as controlling the
      enabled state of a widget, its visibility, automatically clearing fields
      and automatically calling a method. All these things are done
      declaratively on the form, with no need to deal with the graphical API
      used for views.</p>
      <p>Conditional expressions are interpreted using <a href="http://jakarta.apache.org/commons/jxpath" class="externalLink" title="External Link">JXPath</a>. Support for other
      script languages is expected for release 3.0. For now, subsections below
      explain how to use these expression and to explore genesis features
      related to them.</p>
      <div class="subsection"><a name="Declaring_conditions"></a><h3>Declaring conditions</h3>
        <p>Although all anotations that have JXPath conditions as arguments are
        capable of handling any type of expression, certain conditions may be
        used repeatedly in the code or as part of another expression. Due to
        that, genesis makes it possible to declare these conditions and export
        them as variables that may be referenced in other points of the code.
        The annotation <code>@Condition</code> is used to declare a condition,
        whose syntax is:</p>

    <div class="source"><pre>
@Condition conditionName=jxpathExpression
</pre></div>
  
        <p>The variable named <code>conditionName</code> is exported in order to
        represent the expression <code>jxpathExpression</code> in other points
        in the code. As every other JXPath variable, when it's used on a
        expression its name should be preceeded by <code>$</code>. In the
        example above, the variable should be referenced in a conditional
        expression as <code>$conditionName</code>.</p>
        <p>This annotation may be used at class level, in an attribute getter or
        in a method annotated as <code>@Action</code>. Its scope will always be
        class-wide, no matter where it's declared. Obviously, this annotation is
        useful only when used together with another conditional annotation that
        references the exported variable, as the ones mentioned below.</p>
      </div>
      <div class="subsection"><a name="Enabling_and_disabling_components"></a><h3>Enabling and disabling components</h3>
        <p>It's fairly common in UI development situations when a certain field
        or button can only be enabled when a certain condition is true. In order
        to simplify these cases, genesis has an annotation called
        <code>@EnabledWhen</code>. This annotation may be used in attributes and
        actions. A practical usage example is shown below:</p>

    <div class="source"><pre>
/**
 * @Form
 */
public class EnabledWhenFormExample {
   private boolean married;
   private String spouseName;

   public boolean isMarried() {
      return married;
   }

   public void setMarried(boolean married) {
      this.married = married;
   }

   /**
    * @EnabledWhen married=true()
    */
   public String getSpouseName() {
      return spouseName;
   }

   public void setSpouseName(String spouseName) {
      this.spouseName = spouseName;
   }
}
</pre></div>
  
        <p>In the example above, only when the widget representing property
        <code>married</code> has a value of <code>true</code> it will be
        possible to enter the spouse's name.</p>
      </div>
      <div class="subsection"><a name="Controlling_visibility"></a><h3>Controlling visibility</h3>
        <p>It's possible to hide or show widgets conditionally using the
        <code>@VisibleWhen</code> annotation . Its syntax is similar to the one
        for <code>@EnabledWhen</code> and it also may be used to annotate
        attributes and actions. A usage example in an action is shown below:</p>

    <div class="source"><pre>
/**
 * @Form
 */
public class VisibleWhenFormExample {
   private int dependantNumber;

   public int getDependantNumber() {
      return dependantNumber;
   }

   public void setDependantNumber(int dependantNumber) {
      this.dependantNumber = dependantNumber;
   }

   /**
    * @Action
    * @VisibleWhen dependantNumber &gt; 0
    */
   public void calculateAdditionalTaxes() {
      // ...
   }

   // ...
}
</pre></div>
  
        <p>The button representing <code>calculateAdditionalTaxes()</code> will
        be visible only when <code>dependantNumber</code> is greater than zero.
        </p>
      </div>
      <div class="subsection"><a name="Widget_groups"></a><h3>Widget groups</h3>
        <p>In many cases, certain operations need to be executed for a group
        of widgets. An example of this situation is to make a whole group
        visible or enabled - see the Thinlet code below:</p>

    <div class="source"><pre>

...
&lt;label text="Current Date:" font="bold"/&gt;
&lt;panel width="10" height="1" /&gt;
&lt;textfield name="currentDate" /&gt;
...

</pre></div>
  
        <p>In the xml above, the developer intention is to show the field
        "Current Date" under certain conditions. To make this happen, the
        <code>@VisibleWhen</code> annotation is used as the following
        code shows:</p>

    <div class="source"><pre>
/**
 * @VisibleWhen certainConditions
 */
public Date getCurrentDate() {
   ...
}
</pre></div>
  
        <p>However, in this case, what happens is that only the
        <code>textfield</code> will become invisible (in case those
        conditions are not satisfied). Notice that the <code>label</code>
        and the <code>panel</code> used for spacing will not become
        invisible - this clearly is not what was originally intented. All three
        controls should follow just the same conditions for visibility.</p>
        <p>To make this occur, we need to use the <code>widgetGoup</code>
        property of the <code>textfield</code> thinlet xml attribute - see
        the following usage:</p>

    <div class="source"><pre>

...
&lt;label name="currentDateLabel" text="Current Date:" font="bold"/&gt;
&lt;panel name="currentDateSpace" width="10" height="1" /&gt;
&lt;textfield name="currentDate"
      property="widgetGroup=currentDateLabel,currentDateSpace"/&gt;
...

</pre></div>
  
        <p>Notice that the widgets <code>label</code> and <code>panel</code>
        are now named and referred inside the <code>widgetGroup</code>,
        separated by a comma. This way, all three widgets will follow
        the same visibility rule annoted in the <code>form</code> code
        earlier.</p>
        <p>Besides the regular widgetGroup property, there are two more
        specific properties: <code>enabledWidgetGroup</code>
        and <code>visibleWidgetGroup</code>. They define different widget
        groups that will follow enable/disable and visible/invisible rules.
        Those properties will mostly be used because the group of widgets in
        each case is different. For example:</p>

    <div class="source"><pre>

...
&lt;label name="clientLabel" text="Client:" font="bold"/&gt;
&lt;panel name="clientSpace1" width="10" height="1" /&gt;
&lt;textfield name="clientCode" ... /&gt;
&lt;panel name="clientSpace2" width="10" height="1" /&gt;
&lt;textfield name="clientName"
      property="enabledWidgetGroup=clientCode;
            visibleWidgetGroup=clientLabel,clientSpace1,
                               clientCode,clientSpace2"/&gt;
...

</pre></div>
  
        <p>This way, enabling/disabling rule will only affect
        <code>clientCode</code> and <code>clientName</code> widgets only.
        On another hand, visibility rule will affect the whole group, including
        the label and all panels for spacing.</p>
      </div>
      <div class="subsection"><a name="Clearing_field_content"></a><h3>Clearing field content</h3>
        <p>Under many conditions it is necessary to clean field content. genesis
        can do that automatically for the programmer through the
        <code>@ClearOn</code> annotation. Although its syntax is similar to
        <code>@EnabledWhen</code> and <code>@VisibleWhen</code> one's, this
        annotation may only be used for attributes and not for actions (since
        actions do not have content). A previous example may be modified to be
        more accurate:</p>

    <div class="source"><pre>
/**
 * @Form
 */
public class ClearOnFormExample {
   private boolean married;
   private String spouseName;

   public boolean isMarried() {
      return married;
   }

   public void setMarried(boolean married) {
      this.married = married;
   }

   /**
    * @EnabledWhen married=true()
    * @ClearOn married=false()
    */
   public String getSpouseName() {
      return spouseName;
   }

   public void setSpouseName(String spouseName) {
      this.spouseName = spouseName;
   }
}
</pre></div>
  
        <p>When property <code>married</code> is <code>false</code>,
        <code>spouseName</code> will be automatically reset to
        <code>null</code>.</p>
        <p>The value used for resetting is defined by <code>@EmptyValue</code>.
        This annotation should be used for the attribute whose empty value is
        being specified. Its syntax is:</p>

    <div class="source"><pre>
@EmptyValue valueAsString
</pre></div>
  
        <p>If <code>@EmptyValue</code> is not specified, a default value is used
        instead - <code>false</code> for booleans, zero for numeric types and
        <code>null</code> otherwise.</p>
        <p>The annotation <code>@ClearOn</code> can be used together with
        <code>@DataProvider</code> annotation. The DataProviders widgets will
        be cleaned and the form properties that store selected values will be
        automatically reset to <code>null</code> when JXPath condition is satisfied.
        See the following usage:</p>

    <div class="source"><pre>
   /**
    * @DataProvider objectField=state
    * @ClearOn &lt;some jxpath condition&gt;
    */
   public List populateStates() {
      ...
   }
</pre></div>
  
      </div>
      <div class="subsection"><a name="Automatically_invoking_methods"></a><h3>Automatically invoking methods</h3>
        <p>Some methods need to be called every time certain conditions are
        true. Instead of forcing programmers to do that manually - what can lead
        to the so-called "spaghetti" code -, genesis defines the
        <code>@CallWhen</code> annotation. With a syntax similar to previous
        annotations, this one may be only used for actions and not for
        attributes.</p>
        <p>A previous example can be modified to show how to use this annotation
        in practice:</p>

    <div class="source"><pre>
/**
 * @Form
 */
public class CallWhenFormExample {
   private int dependantNumber;

   public int getDependantNumber() {
      return dependantNumber;
   }

   public void setDependantNumber(int dependantNumber) {
      this.dependantNumber = dependantNumber;
   }

   /**
    * @Action
    * @CallWhen dependantNumber &gt; 0
    */
   public void calculateAdditionalTaxes() {
      // ...
   }
}
</pre></div>
  
        <p>Differently from the original <code>@VisibleWhen</code> example,
        <code>calculateAdditionalTaxes()</code> will be invoked automatically by
        genesis whenever <code>dependantNumber</code> is greater than zero.</p>
      </div>
    </div><div class="section"><a name="Determining_if_a_field_is_empty"></a><h2>Determining if a field is empty</h2>
      <p>In order to perform or not to perform some operations, genesis needs to
      determine whether a field is empty. Besides that, the fact a field is
      filled or not is usually as a way to define a condition for some genesis'
      annotations. Interface <code>EmptyResolver</code>, defined on
      <code>net.java.dev.genesis.resolvers</code> is used for that.</p>
      <p>This interface exposes a single method <code>isEmpty(Object)</code>,
      that returns a <code>boolean</code>. To specify which
      <code>EmptyResolver</code> to use for a certain attribute,
      annotation <code>@EmptyResolver</code> can be used. Its syntax is:</p>

    <div class="source"><pre>
@EmptyResolver &lt;fullQualifiedNameForClassImplementingEmptyResolver&gt;
               &lt;attributes&gt;
</pre></div>
  
      <p>It is not necessary to actually insert a line break when defining the
      annotation; it's ok to separate class name from attributes with a space.
      </p>
      <p>In order to avoid being required to specify which
      <code>EmptyResolver</code> implementation should be used for every
      attribute in each form in an application, genesis has a mechanism for
      determining which implementation to use based on the type of an attribute.
      Class <code>EmptyResolverRegistry</code> keeps a registry of default
      <code>EmptyResolver</code> implementations per class. The following
      implementations are initially set up:</p>
      <ul>
        <li><code>MapEmptyResolver</code> is registered for
        <code>java.util.Map</code> instances. It considers as empty null
        instances or the ones that return <code>true</code> for
        <code>isEmpty()</code>.</li>
        <li><code>CollectionEmptyResolver</code> is the default implementation
        for <code>java.util.Collection</code>. It uses the same principle that
        <code>MapEmptyResolver</code> does in order to determine whether an
        instance is empty or not.</li>
        <li>The default implementation for <code>String</code> is
        <code>StringEmptyResolver</code>. Instances considered empty are the
        ones that are null or that have a zero length after spaces are removed,
        i.e., <code>s == null || s.trim().length() == 0</code>.</li>
        <li>For remaining cases, a <code>DefaultEmptyResolver</code> instance is
        registered. This implementation considers as empty null instances or
        zero-element arrays.</li>
      </ul>
      <p>These default implementations should be satisfactory for most cases. As
      an example of how customization might be done, let's consider how to use
      the annotation in a form attribute for which empty spaces are actually
      relevant:</p>

    <div class="source"><pre>
/**
 * @EmptyResolver trim=false
 */
public String getAttribute() {
   return attribute;
}
</pre></div>
  
      <p>Since <code>String</code> already has a registered default
      <code>EmptyResolver</code> instance, <code>StringEmptyResolver</code>, and
      this implementation exposes an attribute that allows one to configure
      whether spaces should be removed or not, it's not necessary to specify the
      name of the interface implementation class and it's enough to define
      property <code>trim</code> as <code>false</code>. If it wasn't possible to
      configure the default instance, another implementation could be used
      instead as following:</p>

    <div class="source"><pre>
/**
 * @EmptyResolver com.company.package.EmptyResolverImplementation
 */
public String getAttribute() {
   return attribute;
}
</pre></div>
  
      <div class="subsection"><a name="Verifying_if_a_field_is_empty_in_conditional_______expressions"></a><h3>Verifying if a field is empty in conditional       expressions</h3>
        <p>As already mentioned, it's very common to determine conditions that
        are based on the fact a field is empty or not. genesis exposes JXPath
        auxiliary functions that may be used in conditions in order to make this
        task easier: <code>g:isEmpty(any)</code> and
        <code>g:isNotEmpty(any)</code>.</p>
        <p>When the argument is a form property, the <code>EmptyResolver</code>
        instance configured for it - determined as explained above - is used to
        determine the return value. If the argument is a variable or a constant,
        a default <code>EmptyResolver</code> instance for the expression type is
        obtained from <code>EmptyResolverRegistry</code> and used for
        evaluation. These functions may be used as shown below:</p>

    <div class="source"><pre>
public String getAttribute() {
   return attribute;
}

public void setAttribute(String attribute) {
   this.attribute = attribute;
}

/**
 * @EnabledWhen g:isNotEmpty(attribute)
 */
public String getDependantAttribute() {
   return dependantAttribute;
}

public void setDependantAttribute(String dependantAttribute) {
   this.dependantAttribute = dependantAttribute;
}
</pre></div>
  
      </div>
    </div><div class="section"><a name="Comparing_values"></a><h2>Comparing values</h2>
      <p>Both the framework and developers need sometimes to check if a field
      value has been changed or if its value is equal to some constant or
      another field value. Interface <code>EqualityComparator</code> contained
      in <code>net.java.dev.genesis.equality</code> is implemented by classes
      that are capable of making this decision.</p>
      <p>This interface defines <code>equals(Object,Object)</code> that returns
      a <code>boolean</code> indicating whether compared instances are equals or
      not. The annotation with the same name, <code>@EqualityComparator</code>
      may be used to explicitly define the implementation used for a certain
      attribute. Its syntax is similar to <code>@EmptyResolver</code>'s one:</p>

    <div class="source"><pre>
@EqualityComparator &lt;fullQualifiedNameForClassImplementingEmptyResolver&gt;
                    &lt;attributes&gt;
</pre></div>
  
      <p>Usually it won't be necessary to use this annotation since genesis also
      has a default mechanism for determining which interface implementation
      should be used for a given attribute. The class / implementation map is
      kept by <code>EqualityComparatorRegistry</code>. Default registered
      implementations are:</p>
      <ul>
        <li><code>BigDecimalEqualityComparator</code> considers two
        <code>java.math.BigDecimal</code> instances equals if both are null or
        if <code>compareTo(BigDecimal)</code>'s return for one of them is zero.
        </li>
        <li><code>StringEqualityComparator</code> considers null or zero-length
        trimmed<code>String</code>s equals. They'll also be considered equals if
        <code>s1.trim().equals(s2.trim())</code>.</li>
        <li>Remaining cases are handled by <code>DefaultEqualityComparator</code>, that considers two instances to be equals if both are null or if
        <code>o1.equals(o2)</code> returns true.</li>
      </ul>
      <div class="subsection"><a name="Verifying_field_value_changes_and_doing_comparisson_in___________conditional_expressions"></a><h3>Verifying field value changes and doing comparisson in           conditional expressions</h3>
        <p>Four JXPath functions are exported by genesis in order to help
        developers in common tasks:</p>
        <ul>
          <li><code>g:hasChanged(property)</code> and
          <code>g:hasNotChanged(property)</code> verify whether a field value
          has changed or not.</li>
          <li><code>g:equals(any,any)</code> and
          <code>g:notEquals(any,any)</code> compare two values - that may be
          constants, form properties or variables - and return the comparisson
          result.</li>
        </ul>
        <p>genesis internally keeps control of fields that have their value
        changed in the current iteraction. This list is checked by functions
        <code>g:hasChanged(propriedade)</code> and
        <code>g:hasNotChanged(propriedade)</code>. To determine whether a value
        has been changed or not and to populate this internal list, the
        framework uses the <code>EqualityComparator</code> instance configured
        for the property.</p>
        <p>Functions <code>g:equals(any,any)</code> and
        <code>g:notEquals(any,any)</code> also make use of
        <code>EqualityComparator</code> instances to determine their output.
        However, the actual process used for that is a bit more complicated, as
        explained below:</p>
        <ul>
          <li>An instance of <code>EqualityComparator</code> for each parameter
          is determined. If the parameter is a form property, its configured
          implementation will be used. Otherwise, the default implementation
          registered in <code>EqualityComparatorRegistry</code> will be picked
          up.</li>
          <li>If comparators for both parameters are the same, the first one of
          them will be used to do the comparisson.</li>
          <li>If the first parameter type is an instance of the second parameter
          type, its <code>EqualityComparator</code> instance will be used for
          performing the comparisson.</li>
          <li>If the second parameter type is an instance of the second
          parameter type, its <code>EqualityComparator</code> instance will be
          used for performing the comparisson.</li>
          <li>If none of the above conditions is true, <code>false</code> will
          be returned.</li>
        </ul>
        <p>There are examples of how to use each function pair below:</p>

    <div class="source"><pre>
public BigDecimal getTax() {
   return tax;
}

public void setTax(BigDecimal tax) {
   this.taxa = tax;
}

/**
 * @Action
 * @CallWhen g:hasChanged(tax)
 */
public void recalculateValues() {
   // logic for recalculating
}
</pre></div>
  

    <div class="source"><pre>
public BigDecimal getDebt() {
   return debt;
}

public void setDebt(BigDecimal debt) {
   this.debt = debt;
}

public BigDecimal getPaidAmount() {
   return paidAmount;
}

public void setPaidAmount(BigDecimal paidAmount) {
   this.paidAmount = paidAmount;
}

/**
 * @Action
 * @CallWhen g:notEquals(debt,paidAmount)
 */
public void calculateRemainingAmount() {
   // logic for calculating amount
}
</pre></div>
  
      </div>
      <div class="subsection"><a name="Changing_the_way_values_are_cloned"></a><h3>Changing the way values are cloned</h3>
         <p>In previous releases, old property values were merely copied as 
         part of form state, what implied in some limitations on how change 
         detecction worked. For example, if the value of a property was a 
         JavaBean and one of its properties was changed, it was not possible to
         detect this change by using <code>g:hasChanged(property)</code>, 
         since both the previous state copy that genesis hold and the current 
         value would point to the same instance in memory.</p>
         <p>Starting from release 2.3, a new API has been introduced that allows
         to control how genesis generates a copy of the previous value of a 
         property. The <code>net.java.dev.genesis.cloning.Cloner</code> 
         interface has a single <code>clone(Object)</code> method that returns 
         the value genesis is suposed to keep as a copy of the value used as an
         argument to the call. The default implementation of that interface - 
         provided by <code>net.java.dev.genesis.cloning.DefaultCloner</code> - 
         simply returns the value used as a parameter, preserving backwards 
         compatibility.</p>
         <p>Similar to <code>EqualityComparator</code>, there is a registry that
         associates <code>Cloner</code> implementations with the class used in
         the property, <code>net.java.dev.genesis.cloning.ClonerRegistry</code>, 
         as well as an annotation that allows the <code>Cloner</code> 
         implementation to be used to be overridden on a property basis, 
         <code>@Cloner</code>.</p>
         <p>The following code shows how to override the <code>Cloner</code> 
         implementation that is going to be used both globally and for a 
         specific bean property:</p>

    <div class="source"><pre>
ClonerRegistry.getInstance().register(User.class, new BeanUtilsCloner());
</pre></div>
  

    <div class="source"><pre>
/**
 * @Form
 */
public class ClonerFormExample {
   /**
    * @Cloner net.java.dev.genesis.cloning.BeanUtilsCloner
    */
   public User getUser() {
      // ...
   }
   
   // ...
}
</pre></div>
  
         <p>The class used in both examples above,  
         <code>net.java.dev.genesis.cloning.BeanUtilsCloner</code>, is the other 
         implementation provided by genesis that clones the value using the 
         Commons BeanUtils API.</p>
      </div>
    </div><div class="section"><a name="Populating_comboboxes__lists_and_tables"></a><h2>Populating comboboxes, lists and tables</h2>
      <p>Options available in a combobox may vary depending on data inputted by
      the user or other business rules. A table's content may need to be
      dynamically filled in response to a user-specified filter criteria, for
      example. To cope with these situations, there is an annotation called
      <code>@DataProvider</code>, whose syntax is:</p>

    <div class="source"><pre>
@DataProvider &lt;objectField=nameObjectField&gt;
              &lt;indexField=nameIndexField&gt;
              &lt;widgetName=nameObjectField&gt;
              &lt;callOnInit=booleanValue&gt;
              &lt;resetSelection=booleanValue&gt;
</pre></div>
  
      <p>This annotation may be used in methods returning either a
      <code>java.util.List</code> or an array of <code>Object</code>s. Values
      returned by the method will be used to populate a combobox, list or table.
      <code>objectField</code>, if specified, should receive as a parameter the
      name of a property that will hold the instance selected on the widget.
      This property should be of the same type or a superclass of the type
      returned by the annotated method, an array of this type or a
      <code>Collection</code>. <code>indexField</code> is the property that
      will hold indexes for the selected elements on the widget. It must be an
      <code>int</code> or an <code>Integer</code>, an array of one of these
      types or a <code>Collection</code>.
      In case <code>widgetName</code> is used, its value must be the name of a
      widget defined in the view xml file. This widget will be the one to receive
      the data provided by the annotated method.
      <b>At least one of these three parameters must be
      informed</b>.</p>
      <p>The widget <code>name</code> is equal to the value specified for
      <code>widgetName</code>, <code>objectField</code> or <code>indexField</code>
      in that order.</p>
      <p>As mentioned earlier, both <code>objectField</code> and
      <code>indexField</code> receive as parameter the name of a property that
      might be a bean, an array or a <code>Collection</code>. Let's
      examine when to use each type:</p>
      <table class="bodyTable">
        <tr class="b">
          <th>Return type and Usage</th>
          <th>objectField</th>
          <th>indexField</th>
        </tr>
        <tr class="a">
          <td>Bean: always used with comboboxes or lists/tables with single
          selection mode</td>
          <td>Any Java class (cannot be a primitive type)</td>
          <td><code>Integer</code> or <code>int</code></td>
        </tr>
        <tr class="b">
          <td><code>Collection</code> or array: used for lists/tables with
          multiple selection enabled</td>
          <td>Array of any Java class (cannot be of a primitive type) or
          <code>Collection</code> of any Java class</td>
          <td>Array of <code>Integer</code>s or of <code>int</code>s or
          <code>Collection</code> of <code>Integer</code>s</td>
        </tr>
      </table>
      <p>An example of how to use this annotation is shown below:</p>

    <div class="source"><pre>

&lt;panel gap="5"&gt;
   &lt;label text="State:" /&gt;
   &lt;combobox name="state" property="key=acronym;value=description" /&gt;
&lt;/panel&gt;

</pre></div>
  

    <div class="source"><pre>
public class State {
   private String acronym;
   private String description;

   // getters and setters for properties
}
</pre></div>
  

    <div class="source"><pre>
/**
 * @Form
 */
public class DataProviderFormExample {
   private State state;

   public State getState() {
      return state;
   }

   public void setState(State state) {
      this.state = state;
   }

   /**
    * @DataProvider objectField=state
    */
   public List populateStates() {
      // returns a Collection containing State instances
   }

   // ...
}
</pre></div>
  
      <p>In the first block we can see the interface xml that displays a
      <code>label</code> and a <code>combobox</code> that will hold states in
      runtime. The combobox <code>name</code> property is equal to the value for
      <code>objectField</code> in annotation <code>@DataProvider</code> from the
      third block. A few values are configured for combobox <code>property</code>. The following values may be used for this kind of widget:</p>
      <ul>
        <li><b>key</b>: name of the property bean that will be used for
        populating the component, whose value is unique per instance.Always
        required.</li>
        <li><b>value</b>: name of the property used for displaying the bean. It
        is required when the bean is not a subclass of
        <code>net.java.dev.reusablecomponents.lang.Enum</code>.</li>
        <li><b>blank</b>: includes a blank line as the first combobox option.
        It's not required and its default value is <code>false</code>.</li>
        <li><b>blankLabel</b>: defines the text to be displayed for the blank
        line. It's not required, its default value is an empty
        <code>String</code> and it's only meaningful when
        <code>blank=true</code>.</li>
      </ul>
      <p>As indicated by <code>objectField</code> value, property
      <code>state</code> will contain the selected <code>State</code> instance
      that corresponds to the combox option choosen by the user.</p>
      <p>Working with <code>lists</code> is quite similar to
      <code>comboboxes</code>, as shown in the below example:</p>

    <div class="source"><pre>

&lt;panel gap="5"&gt;
   &lt;label text="State:" /&gt;
   &lt;list name="state" property="key=acronym;value=description" /&gt;
&lt;/panel&gt;

</pre></div>
  
      <p>Requirements for populating a table are slightly different. To display
      the states of the previous example in a table, the interface xml could be
      like:</p>

    <div class="source"><pre>

&lt;panel gap="5"&gt;
   &lt;table name="state"&gt;
      &lt;header&gt;
         &lt;column name="acronym" text="Acronym" /&gt;
         &lt;column name="description" text="Description" /&gt;
      &lt;/header&gt;
   &lt;/table&gt;
&lt;/panel&gt;

</pre></div>
  
      <p>As shown above, we can observe that table <code>name</code> must be
      equal to <code>objectField</code> value. Each row will represent an
      instance and each column will be filled with a bean property whose name is
      their <code>name</code>.</p>
      <p>There is a variation for this annotation which happens with the use
      of the <code>callOnInit</code> property. Imagine the above
      <code>combobox</code> or the <code>table</code> widgets <b> are not
      supposed</b> to be filled at the dialog startup. In this case, to
      accomplish this requirement in a easier way, we only have to rewrite
      the annotation as the following code indicates:</p>

    <div class="source"><pre>
   // ...

   /**
    * @DataProvider objectField=state callOnInit=false
    */
   public List populateStates() {
      // returns a Collection containing State instances
   }

   // ...
</pre></div>
  
      <p>This way, at dialog startup, the <code>combobox</code>
      or <code>list</code> or
      <code>table</code> widgets will be empty. In order to populate them
      a <code>@CallWhen</code> annotation can be added and used together.
      That is, <code>@CallWhen</code> annotation may be used together with
      <code>@DataProvider</code> to indicate when a table/list/combo will be
      automatically populate again. <code>@Action</code> may also be used in
      these methods if they need to be triggered by a button (such as Search,
      for example) and, when that is true, using <code>@EnabledWhen</code> and
      <code>@VisibleWhen</code> is also allowed.</p>
      <p><code>resetSelection</code> determines whether selected elements will
      be unselected when the method is invoked. This is the default behaviour,
      i.e., if this property has no value, it is considered <code>false</code>.
      When the value informed is <code>true</code>, the selection is kept
      relative to the <b>position</b> of the itens, what makes this feature
      more useful when something is being added to the end of the
      <code>java.util.List</code> instance or array each time the method gets
      executed.</p>
      <div class="subsection"><a name="Invoking_actions_within_a_form"></a><h3>Invoking actions within a form</h3>
        <p>In order to have a form re-populated with the data returned by
        a <code>@DataProvider</code> annotated method, genesis must be aware of
        its execution. This can be done by calling
        <code>invokeFormAction(...)</code> as described
        <a href="ui_basic_concepts.html#Implementing_actions_in_forms_and_views">
        here</a>.</p>
        <p>Another way to do this within the form (without the use of a view)
        is to use the <code>ActionInvoker</code> and <code>BaseForm</code>
        classes.</p>
        <p>The <code>ActionInvoker</code> class has two static methods:
        <ul>
          <li><code>invoke(form, actionName)</code>: executes an action
          from the given form.</li>
          <li><code>refresh(form)</code>: updates the information being
          displayed by the given form instance.</li>
        </ul>
        </p>
        <p>The <code>BaseForm</code> class might be used as a parent class of
        forms. It defines two similar methods:
        <ul>
          <li><code>invoke(actionName)</code>: executes an action in the
          current form instance.</li>
          <li><code>refresh()</code>: updates the information being
          displayed by the current form instance.</li>
        </ul>
        To be more specific, these methods are shortcuts to the methods defined
        in <code>ActionInvoker</code>. However, extending <code>BaseForm</code>
        limits form inheritance possibilities and may not be suitable.</p>
        <p>Although using these classes makes the form more self-contained,
        it will make code more strongly coupled to genesis.</p>
        <p>Reusing the same logic from
        <a href="ui_basic_concepts.html#Implementing_actions_in_forms_and_views">
        <code>invokeFormAction(...)</code></a> example and rewriting it to use
        <code>ActionInvoker</code>, we'll have:</p>

    <div class="source"><pre>
/**
 * @Form
 */
public class InvokeFormActionFormExample {
   private BigDecimal index;
   // ...

   public BigDecimal getIndex() {
      return index;
   }

   public void setIndex(BigDecimal index) {
      this.index = index;
      ActionInvoker.invoke(this, "recalculateTotals");
   }

   /**
    * @DataProvider objectField=totals
    */
   public void recalculateTotals() {
      // business logic to manipulate several other properties
   }
}
</pre></div>
  

    <div class="source"><pre>
/**
 * @Form
 */
public class InvokeFormActionFormExample extends BaseForm {
   private BigDecimal index;
   // ...

   public BigDecimal getIndex() {
      return index;
   }

   public void setIndex(BigDecimal index) {
      this.index = index;
      invoke("recalculateTotals");
   }

   /**
    * @DataProvider objectField=totals
    */
   public void recalculateTotals() {
      // business logic to manipulate several other properties
   }
}
</pre></div>
  
      </div>
    </div><div class="section"><a name="Formatting"></a><h2>Formatting</h2>
      <p>Since formatting information so it can be displayed on the screen is a
      very important part of any graphic application, it's expected doing so is
      easy and also configurable. The API used for this purpose on genesis is
      implemented in <code>net.java.dev.genesis.text</code>.</p>
      <p>In this package resides an interface called <code>Formatter</code>,
      that defines a <code>format(Object)</code> method. This methods converts
      its argument to a formatted String. Similarly to what happens to other
      common framework components, there's a registry of default interface
      implementations per class, the <code>FormatterRegistry</code> class. The
      following implementations are initially registered in this class:</p>
      <ul>
        <li><code>EnumFormatter</code> converts
        <code>net.java.dev.reusablecomponents.lang.Enum</code> instances by
        looking up in the
        <a href="#Configuring_messages"><code>ResourceBundle</code></a> the
        message configured by a key formed by class name without package + '.' +
        constant name. If this message is not found, a message will be logged as
        INFO and the instance converted by using <code>toString()</code>.</li>
        <li><code>DefaultFormatter</code> is registered for all remaining types
        and converts instances using <code>toString()</code> - except when they
        are <code>null</code>, when it returns a zero-length String.</li>
      </ul>
      <p>To register a new formatter for a class the method
      <code>register(Class,Formatter)</code> from <code>FormatterRegistry</code>
      may be used.</p>
      <p>However, the ability of registering a formatter instance per class
      may not be enough for some situations. For example, when a
      <code>boolean</code> property is displayed as text, it may be necessary
      to display a custom text instead of the <code>true</code> and
      <code>false</code> constants. genesis has an API that allows a specific
      formatter instance to be used to display a field. Some steps are required
      to use this feature:</p>
      <ol>
        <li>Instead of calling some version of the <code>bind(..)</code>
        method, a <code>ThinletBinder</code> instance should be prepared by
        calling either <code>prepareBinder(form)</code> or
        <code>prepareBinder(widget,form)</code>, both methods defined in
        <code>net.java.dev.genesis.ui.thinlet.BaseThinlet</code>.</li>
        <li>The formatter instance can be registered using the
        <code>registerFormatter(String,Formatter)</code> method specified by
        <code>net.java.dev.genesis.ui.thinlet.ThinletBinder</code>. The
        <code>String</code> argument value should be the name of the property
        whose formatter will be overridden. The property name should be:
          <ul>
            <li>If it is a simple property, returned by a getter method, it is
            a simple property name.</li>
            <li>If the formatter instance should be used for combobox or list
            items or for a column in a table, the property name should be
            composed as
            <code>widgetName.nameOfThePropertyOfTheObjectBeingDisplayed</code>.
            </li>
          </ul>
        </li>
        <li>Optionally, if the property whose formatter has been overridden
        needs to be converted by genesis to its original type and the custom
        generated format is not supported by the default converter, the
        converter must be overriden by calling the
        <code>registerConverter(String,Converter)</code> method.
        <code>org.apache.commons.beanutils.Converter</code> is part of
        Jakarta Commons BeanUtils. Please refer to this framework documentation
        if this interface must be overridden.</li>
        <li>Finally, the binding should be manually performed by calling the
        <code>bind()</code> method.</li>
      </ol>
      <p>A short example of these steps can be seen below:</p>

    <div class="source"><pre>
ThinletBinder binder = prepareBinder(form);
binder.registerFormatter("property", new Formatter() {
   public String format(Object o) {
      return "Custom format";
   }
});
binder.bind();
</pre></div>
  
      <p>The value of <code>property</code> to be displayed on the screen
      will be the <code>Custom format</code> constant, no matter what its
      value on the form is.</p>
      <div class="subsection"><a name="Virtual_properties"></a><h3>Virtual properties</h3>
        <p>Since release 2.2, it is possible to work with virtual properties,
        i.e., properties that don't exist in the object being displayed. These
        properties have their display value determined by a specific formatter,
        that must be registered in the <code>ThinletBinder</code> instance.</p>
        <p>The process for defining and displaying a virtual property is
        basically the same of a regular property, except for the following
        things:</p>
        <ul>
           <li>Only table cells and values displayed in comboboxes or lists can
           be virtual properties.</li>
           <li>Virtual properties can be defined for comboboxes and lists by
           adding to the <code>property</code> element in the xml definition a
           <code>virtual=true</code> token. Since table columns do not have
           a <code>property</code> attribute, the value of its attribute
           <code>name</code> must be prefixed with <code>virtual:</code>
           .</li>
           <li>The <code>Formatter</code> instance will receive the whole bean
           being displayed as a parameter to the <code>format(Object)</code>,
           since the property being displayed does not actually exist in the
           instance.</li>
        </ul>
        <p>An example of how to define and use a virtual property is shown
        below, both for comboboxes and tables:</p>

    <div class="source"><pre>

&lt;panel gap="5"&gt;
   &lt;combobox name="widget"
             property="key=uniqueProperty;value=virtualValue;virtual=true" /&gt;
&lt;/panel&gt;

</pre></div>
  

    <div class="source"><pre>

&lt;panel gap="5"&gt;
   &lt;table name="widget"&gt;
      &lt;header&gt;
         &lt;column name="uniqueProperty" text="#" /&gt;
         &lt;column name="virtual:virtualValue" text="Virtual" /&gt;
      &lt;/header&gt;
   &lt;/table&gt;
&lt;/panel&gt;

</pre></div>
  

    <div class="source"><pre>
ThinletBinder binder = prepareBinder(form);
binder.registerFormatter("widget.virtualValue", new Formatter() {
   public String format(Object o) {
      return o == null ? "0" : String.valueOf(o.hashCode());
   }
});
binder.bind();
</pre></div>
  
        <p>It is important to notice that although the name of the column is
        prefixed with <code>virtual:</code>, this does not affect how the
        property name is composed for registering the formatter.</p>
      </div>
    </div><div class="section"><a name="Customizing_how_components_are_created"></a><h2>Customizing how components are created</h2>
      <p>Starting from release 2.3, it is possible to customize how componentes
      are created by using the 
      <code>net.java.dev.genesis.ui.thinlet.WidgetFactory</code> interface and 
      its related support classes. It is possible to do so based on either the
      class of the data for which the widget will be created or for a specific
      widget.</p>
      <p>For instance, in order to make both table cells and list and comboboxes 
      itens right-aligned when their content is a <code>java.lang.Number</code>
      class, an instance of <code>WidgetFactory</code> should be registered in
      <code>net.java.dev.genesis.ui.thinlet.WidgetFactoryRegistry</code> 
      before any code that creates widgets is executed. This can be done as 
      shown below:</p>

    <div class="source"><pre>
public class NumberWidgetFactory extends DefaultWidgetFactory {
   public Object create(BaseThinlet thinlet, String name, String value,
         Object bean, BaseThinlet.ItemType type) {
      Object widget = super.create(thinlet, name, value, bean, type);
      Thinlet.setChoice(widget, BaseThinlet.ALIGNMENT, BaseThinlet.RIGHT);
      return widget;
   }
}
</pre></div>
  

    <div class="source"><pre>
// Code for registering the instance, probably at the main(String[]) method
WidgetFactoryRegistry.getInstance().register(Number.class, new NumberWidgetFactory());
</pre></div>
  
      <p>As shown above, most implementations of <code>WidgetFactory</code> will
      extend <code>DefaultWidgetFactory</code>, a class that implements the 
      basic behaviour used by genesis. The arguments used as parameters for 
      invoking the
      <code>create(BaseThinlet, String, String, Object, BaseThinlet.ItemType)</code>
      method are, in order:</p>
      <ul>
         <li><b>thinlet</b>: the instance of the <code>BaseThinlet</code> 
         subclass the widget will be added to.</li>
         <li><b>name</b>: property value to be used as the component name. It 
         might be ignored, but that is usually not advisable.</li>
         <li><b>value</b>: the text value to be used in the component. It 
         might be ignored, but that is usually not advisable.</li>
         <li><b>property</b>: the property that has been formatted to produce 
         the <code>value</code> argument. It might be useful in some specific 
         cases, such as when creating a tooltip based on another property of a
         bean.</li>
         <li><b>type</b>: the type of the widget to be created, according to the
         enum <code>BaseThinlet.ItemType</code>.</li>
      </ul>
      <p>In order to use an instance of <code>WidgetFactory</code> to create 
      some specific widget, it should be registered in the 
      <code>ThinletBinder</code> instance by invoking the 
      <code>registerWidgetFactory(String,WidgetFactory)</code> method, using the
      same naming rule explained in the <a href="#Formatting">Formatting</a> 
      section, as shown below:</p>

    <div class="source"><pre>

&lt;panel gap="5"&gt;
   &lt;table name="widget"&gt;
      &lt;header&gt;
         &lt;column name="regularProperty" text="Regular" /&gt;
         &lt;column name="specificProperty" text="Specific" /&gt;
      &lt;/header&gt;
   &lt;/table&gt;
&lt;/panel&gt;

</pre></div>
  

    <div class="source"><pre>
ThinletBinder binder = prepareBinder(form);
binder.registerFormatter("widget.specificProperty", new NumberWidgetFactory());
binder.bind();
</pre></div>
  
    </div><div class="section"><a name="Validating_data"></a><h2>Validating data</h2>
      <p>Data validation is critical for system integrity, especially when data
      is entered by users, as is the case for UI applications. Support for
      validation in genesis is implemented by using one of Jakarta project's
      components, <a href="http://jakarta.apache.org/commons/validator/" class="externalLink" title="External Link">commons-validator</a>.
      Several other open-source framework use commons-validator as a foundation
      for their own validation, including Struts, what increases chances you are
      already used to it. Otherwise, we recommend reading the docs from their
      own project site.</p>
      <p>Annotation <code>@ValidateBefore</code> may be used in actions that can
      only be executed when validation succeeds. If a validation error occurs a
      <code>net.java.dev.genesis.ui.ValidationException</code> will be thrown -
      an exception that is <a href="#Handling_errors">handled by default</a> by
      genesis so errors are displayed in a properly formatted way to users.</p>
      <p>Several default validators are implemented in
      <code>BasicValidator</code>, contained in
      <code>net.java.dev.genesis.ui</code>. Most of these validators are similar
      to the ones provided with Struts, what makes understanding them easier.
      They are:</p>
      <ul>
        <li><code><b>byte</b>, <b>short</b>, <b>int</b>, <b>long</b>,
        <b>float</b> and <b>double</b></code>: check if data can be converted to
        one of these types without any overflow.</li>
        <li><code><b>bigDecimal</b></code>: checks if data can be converted to
        <code>java.math.BigDecimal</code> using the default <a href="http://jakarta.apache.org/commons/beanutils" class="externalLink" title="External Link">BeanUtils</a> converter
        registered for it. genesis provides a custom implementation of this
        converter, <code>BigDecimalConverter</code> in
        <code>net.java.dev.genesis.commons.beanutils.converters</code>, since
        the implementations that come with BeanUtils do not work as expected for
        Locale pt-BR.</li>
        <li><code><b>date</b></code>: implements data validation. It may use
        variable <code>pattern</code> as a valid data pattern. This pattern is
        compatible to the ones specified for <code>java.text.DateFormat</code>.
        </li>
        <li><code><b>email</b></code>: only accepts content that can be
        considered a syntatically valid email.</li>
        <li><code><b>required</b></code>: asserts the field is not empty.</li>
        <li><code><b>requiredif</b></code>: compatible with the version that
        comes with Struts, it implements a somewhat weak validation. Its use is
        not recommended and it is provided just as a way to ease migration from
        Struts users. Use <code><b>jxpath</b></code> instead.</li>
        <li><code><b>mask</b></code>: implements validation based on a regular
        expression for a mask. Requires the definition of a <code>mask</code>
        variable containg the regular expression.</li>
        <li><code><b>minlength</b> and <b>maxlength</b></code>: guarantee that
        informed data has a number of characteres not lesser and not greater,
        respectively, than a character count number defined by
        <code>minlength</code> or <code>maxlength</code> variables.</li>
        <li><code><b>min</b></code>: checks if the informed number is greater or 
        equal  to the value defined by the <code>min</code> variable.</li>
        <li><code><b>max</b></code>: checks if the informed number is lesser or 
        equal to the value defined by the <code>max</code> variable.</li>
        <li><code><b>longRange</b>, <b>doubleRange</b> and <b>bigDecimalRange</b></code>: check if the informed number is part of an expected interval,
        defined by variables <code>min</code> and <code>max</code>.</li>
        <li><code><b>jxpath</b></code>: the most flexible validator provided
        with genesis. It considers data as valid if evaluating the JXPath
        expression defined by <code>jxpath</code> returns a value different from
        <code>java.lang.Boolean.FALSE</code>.</li>
      </ul>
      <p>As it is true for Struts validators, all the ones provided with genesis
      except for <code>jxpath</code> are only triggered if the field is filled.
      This means that <b>even if you configure a validator properly, it will be
      invoked only when the user puts something in the field</b>. If you intend
      to run your validator every time,  <code>required</code> should also be
      configured for the field.</p>
      <p>Data to be validated is passed in a String format to validators. It's
      important to remember that when coding JXPath expressions or using a
      custom validator.</p>
      <p>The class that actually integrates commons-validator with genesis,
      <code>net.java.dev.genesis.ui.ValidationUtils</code>, expects that two
      configuration files are available on the classpath:
      <code>validation-rules.xml</code> and <code>validation.xml</code>. These
      files must be compatible with the commons-validator 1.1  DTD. A default
      configuration for <code>validation-rules.xml</code> is provided with
      genesis-client jar as shown below:</p>

    <div class="source"><pre>

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE form-validation PUBLIC 
   '-//Apache Software Foundation//DTD Commons Validator Rules Configuration 1.1//EN' 
   'http://jakarta.apache.org/commons/dtds/validator_1_1.dtd'&gt;
&lt;form-validation&gt;
    &lt;global&gt;
        &lt;validator name="byte" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateByte" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.byte"/&gt;
        &lt;validator name="short" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateShort" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.short"/&gt;	
        &lt;validator name="int" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateInt" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.int"/&gt;
        &lt;validator name="long" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateLong" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.long"/&gt;
        &lt;validator name="float" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateFloat" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.float"/&gt;
        &lt;validator name="double" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateDouble" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.double"/&gt;
        &lt;validator name="bigDecimal" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateBigDecimal" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.bigdecimal"/&gt;
        &lt;validator name="required" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateRequired" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.required"/&gt;
        &lt;validator name="requiredif" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateRequiredIf" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field,org.apache.commons.validator.Validator" 
                msg="errors.requiredif"/&gt;
        &lt;validator name="mask" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateMask" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.mask"/&gt;
        &lt;validator name="email" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateEmail" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.email"/&gt;
        &lt;validator name="date" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateDate" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.date"/&gt;			
        &lt;validator name="minlength" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateMinLength" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.minlength"/&gt;			
        &lt;validator name="maxlength" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateMaxLength" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.maxlength"/&gt;			
        &lt;validator name="min" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateMin" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.min"/&gt;	
        &lt;validator name="max" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateMax" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.max"/&gt;	
        &lt;validator name="longRange" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateLongRange" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.longRange"/&gt;			
        &lt;validator name="doubleRange" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateDoubleRange" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.doubleRange"/&gt;		
        &lt;validator name="bigDecimalRange" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateBigDecimalRange" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.bigDecimalRange"/&gt;	
        &lt;validator name="jxpath" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateJXPath" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.jxpath"/&gt;			
    &lt;/global&gt;
&lt;/form-validation&gt;

</pre></div>
  
      <p>For most cases, a practical way to configure form validation is using
      <a href="http://xdoclet.sf.net" class="externalLink" title="External Link">XDoclet</a>. A validation configuration
      example from sample useradmin is the <code>InsertUpdateForm</code> class,
      from package <code>net.java.dev.genesis.samples.useradmin.ui</code>,
      partially shown below:</p>

    <div class="source"><pre>
/**
 * @Form
 * @genesis.form
 */
public class InsertUpdateForm {
   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.birthday"
    *
    * @genesis.validator type="date"
    * @genesis.validator-var name="pattern" value="MM/dd/yyyy"
    */
   public void setBirthday(Date birthday) {
      this.birthday = birthday;
   }

   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.country"
    */
   public void setCountry(Country country) {
      this.country = country;
   }

   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.email"
    *
    * @genesis.validator type="email"
    * @genesis.validator-args arg0resource="User.email"
    */
   public void setEmail(String email) {
      this.email = email;
   }

   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.role"
    */
   public void setRole(Role role) {
      this.role = role;
      setRoleCode(role == null ? null : role.getCode());
   }

   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.login"
    *
    * @genesis.validator type="minlength" arg1value="${var:minlength}"
    * @genesis.validator-var name="minlength" value="4"
    */
   public void setLogin(String login) {
      this.login = login;
   }

   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.name"
    */
   public void setName(String name) {
      this.name = name;
   }

   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.password"
    *
    * @genesis.validator type="minlength" arg1value="${var:minlength}"
    * @genesis.validator-var name="minlength" value="6"
    *
    * @genesis.validator type="maxlength" arg1value="${var:maxlength}"
    * @genesis.validator-var name="maxlength" value="8"
    */
   public void setPassword(String password) {
      this.password = password;
   }

   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.address"
    */
   public void setAddress(String address) {
      this.address = address;
   }

   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.state"
    */
   public void setState(State state) {
      this.state = state;
   }

   /**
    * @Action
    * @ValidateBefore
    */
   public void save() throws Exception {
      final User user = new User();
      PropertyUtils.copyProperties(user, this);
      if (getId() == null) {
         new UserCreateCommand().createUser(user);
      } else {
         new UserUpdateCommand().updateUser(user);
      }
   }

   // ...
}
</pre></div>
  
      <p>Before invoking <code>save()</code>, validation is executed based on
      the rules defined by the generated file and eventual errors will prevent
      the method from being executed. For those not used to XDoclet, below there
      is a transcription from a <code>validation.xml</code> file generated
      during build execution:</p>

    <div class="source"><pre>

&lt;?xml version="1.0" encoding="ISO-8859-1" ?&gt;
&lt;!DOCTYPE form-validation PUBLIC
   '-//Apache Software Foundation//DTD Commons Validator Rules Configuration
   1.1//EN'
   'http://jakarta.apache.org/commons/dtds/validator_1_1.dtd'&gt;
&lt;form-validation&gt;
  &lt;!--
    Define global validation config in validation-global.xml
  --&gt;
  &lt;formset&gt;
      &lt;form name="net.java.dev.genesis.samples.useradmin.ui.InsertUpdateForm"&gt;
              &lt;field property="birthday"
                     depends="required,date"&gt;
                  &lt;arg position="0"
                       key="User.birthday"
                  /&gt;
                  &lt;var&gt;
                    &lt;var-name&gt;pattern&lt;/var-name&gt;
                    &lt;var-value&gt;MM/dd/yyyy&lt;/var-value&gt;
                  &lt;/var&gt;
              &lt;/field&gt;
              &lt;field property="country"
                     depends="required"&gt;
                  &lt;arg position="0"
                       key="User.country"
                  /&gt;
              &lt;/field&gt;
              &lt;field property="email"
                     depends="required,email"&gt;
                  &lt;arg position="0"
                       key="User.email"
                  /&gt;
              &lt;/field&gt;
              &lt;field property="role"
                     depends="required"&gt;
                  &lt;arg position="0"
                       key="User.role"
                  /&gt;
              &lt;/field&gt;
              &lt;field property="login"
                     depends="required,minlength"&gt;
                  &lt;arg position="0"
                       key="User.login"
                  /&gt;
                  &lt;arg position="1"
                       name="minlength"
                       key="${var:minlength}"
                       resource="false"
                  /&gt;
                  &lt;var&gt;
                    &lt;var-name&gt;minlength&lt;/var-name&gt;
                    &lt;var-value&gt;4&lt;/var-value&gt;
                  &lt;/var&gt;
              &lt;/field&gt;
              &lt;field property="name"
                     depends="required"&gt;
                  &lt;arg position="0"
                       key="User.name"
                  /&gt;
              &lt;/field&gt;
              &lt;field property="password"
                     depends="required,minlength,maxlength"&gt;
                  &lt;arg position="0"
                       key="User.password"
                  /&gt;
                  &lt;arg position="1"
                       name="minlength"
                       key="${var:minlength}"
                       resource="false"
                  /&gt;
                  &lt;arg position="1"
                       name="maxlength"
                       key="${var:maxlength}"
                       resource="false"
                  /&gt;
                  &lt;var&gt;
                    &lt;var-name&gt;minlength&lt;/var-name&gt;
                    &lt;var-value&gt;6&lt;/var-value&gt;
                  &lt;/var&gt;
                  &lt;var&gt;
                    &lt;var-name&gt;maxlength&lt;/var-name&gt;
                    &lt;var-value&gt;8&lt;/var-value&gt;
                  &lt;/var&gt;
              &lt;/field&gt;
              &lt;field property="address"
                     depends="required"&gt;
                  &lt;arg position="0"
                       key="User.address"
                  /&gt;
              &lt;/field&gt;
              &lt;field property="state"
                     depends="required"&gt;
                  &lt;arg position="0"
                       key="User.state"
                  /&gt;
              &lt;/field&gt;
      &lt;/form&gt;
  &lt;/formset&gt;
&lt;/form-validation&gt;

</pre></div>
  
      <p>A resource file is also used to configure messages, as explained below.
      </p>
    </div><div class="section"><a name="Configuring_messages"></a><h2>Configuring messages</h2>
      <p>Several messages may be externalized by configuring them in a
      <code>java.util.ResourceBundle</code>. A <code>ResourceBundle</code>
      allows one to keep a name/value property dictionary - similar to a
      <code>Properties</code> instance -, supporting multiple
      <code>java.util.Locale</code> instances. In a simplified way, it is
      possible to configure different messages depending on the language being
      used.</p>
      <p>genesis uses a <code>ResourceBundle</code> named <code>messages</code>,
      what means that a <code>messages.properties</code> file should be
      available on classpath. Class <code>net.java.dev.genesis.ui.UIUtils</code>
      keeps this <code>ResourceBundle</code> instance in runtime.</p>
      <p>In the resource file messages relative to the following things are
      configured:
      </p>
      <ul>
        <li>Validation</li>
        <li>Disply values for <code>Enum</code> constants (in a
        <code>ClassName.CONSTANT=Display value</code> format)</li>
        <li>Messages for the default views provided with genesis, such as the
        one used for <code>OptionDialog</code></li>
        <li>Any user-defined text that need to be externalized</li>
      </ul>
      <p>There is an example of how to configure a <code>ResourceBundle</code>
      from the useradmin sample below:</p>

    <div class="source"><pre>
# 1. Validation-related configuration
errors.byte=The {0} field is not a byte.
errors.short=The {0} field is not a short.
errors.int=The {0} field is not an integer.
errors.long=The {0} field is not a long.
errors.float=The {0} field is not a float.
errors.double=The {0} field is not a double.
errors.bigdecimal=The {0} field is not a big decimal.
errors.required=The {0} field is required.
errors.requiredif=The {0} field is required.
errors.mask=The {0} field is not valid.
errors.email=The {0} field is not a valid email.
errors.date=The {0} field is not a valid date.
errors.min={0} must be greater or equal to {1}.
errors.max={0} must be lesser or equal to {1}.
errors.minlength=The {0} field can not be less than {1} characters.
errors.maxlength=The {0} field can not be greater than {1} characters.
errors.longRange={0} is not in the range {1} through {2}.
errors.doubleRange={0} is not in the range {1} through {2}.
errors.bigDecimalRange={0} is not in the range {1} through {2}.
errors.jxpath=The {0} field is not valid.
validation.errors.title=Validation errors

# 2. Messages for default views
MessageDialog.close=Close
Option.YES=Yes
Option.NO=No
Option.CANCEL=Cancel
ErrorReporterDialog.ok=OK
ErrorReporterDialog.stackTrace=Stack Trace:

# 3. Used defined configurations
InsertRoleView.title=Insert Role
InsertView.title=Insert User
UpdateView.title=Update User
RoleListView.title=Role List
UserListView.title=Users Administration

button.ok=Ok
button.add=Add
button.remove=Remove
button.cancel=Cancel
button.save=Save
button.search=Search
button.reset=Reset
button.newUser=New User
button.updateUser=Update User
button.removeUser=Remove User

User.name=Name
User.login=Login
User.password=Password
User.email=e-mail
User.birthday=Birthday
User.address=Address
User.country=Country
User.state=State
User.role=Role

Role.label=Label
Role.code=Code
</pre></div>
  
      <p>For more information on how to work with resource files, see the
      Javadoc for class <code>java.util.ResourceBundle</code>.</p>
    </div><div class="section"><a name="Working_with_dynamic_searches"></a><h2>Working with dynamic searches</h2>
      <p>genesis makes it easy to build dynamic searches - those in which
      selection criteria change in runtime, not just values for them -
      integrating this feature both in UI components and business components.</p>
      <p>On the client-side, in order to use only filled properties in the
      search, one just has to do:</p>

    <div class="source"><pre>
CriteriaPropertyHelper.fillCriteria(hibernateCriteria, form);
</pre></div>
  
      <p>Classe <code>CriteriaPropertyHelper</code> is located at package
      <code>net.java.dev.genesis.helpers</code>. <code>hibernateCriteria</code>
      needs to be compliant with the <a href="business_component_model.html#Dynamic criteria searching">requirements
      for dynamic searching with business components</a> while <code>form</code>
      must be a valid genesis form. Only properties that exist in both beans and
      that are filled according the
      <a href="#Determining_if_a_field_is_empty">rules for determing if a field
      is empty</a>. A call to
      <code>fillCriteria(HibernateCriteria, Object)</code> must be done before
      calling the method annotated with <code>@Criteria</code>.</p>
      <p>To make it even simpler to buld dynamic searches with paged results, two
      helper classes are defined in package
      <code>net.java.dev.genesis.ui.paging</code>: <code>BaseSearchForm</code>
      and <code>BaseCriteriaSearchForm</code>. These abstract classes can be
      extended by forms, minimizing implementation efforts.</p>
      <p><code>BaseSearchForm</code> contains paging-related logic, besides
      abstracting how the query is actually performed. Some of its actions and
      properties may be directly used to assemble the UI:</p>
      <ul>
        <li><code>previousPage()</code> and <code>nextPage()</code> are genesis
        actions that can be bound to buttons that will perform navigation through
        the results. They have <code>@VisibleWhen</code> annotations that will
        hide the widgets whenever it is appropriate.</li>
        <li><code>pageNumber</code> is a property that contains the number of
        current page.</li>
      </ul>
      <p>This class also defines the abstract <code>performSearch()</code>
      method, that returns a <code>net.java.dev.genesis.paging.Page</code>
      instance, and exposes the <code>runSearch</code> property, that is
      supposed to be used to define the conditional expression for performing
      the search in subclasses. Most of the times it won't be necessary to use
      it directly, since <code>BaseCriteriaSearchForm</code> provides a higher
      abstraction level when the search is performed by a
      <code>HibernateCriteria</code> implementation. In this case, it will only
      be necessary to implement a couple of methods:
      <code>getHibernateCriteria()</code>, that should return the business
      object that will receive the criteria by calling
      <code>CriteriaPropertyHelper</code> and
      <code>performSearch(int pageNumber)</code>. Below there is an example of
      how to use this class extracted from the useradmin sample. First, let's
      see the relevant code snippet for the form:</p>

    <div class="source"><pre>
/**
 * @Form
 */
public class UserListForm extends BaseCriteriaSearchForm {
   private final UserSearchCommand command = new UserSearchCommand();

   // getters and setters for search criteria omitted

   public List getUsers() { /* ... */ }

   public void setUsers(List users) { /* ... */ }

   protected HibernateCriteria getHibernateCriteria() {
      return command;
   }

   protected Page performSearch(int pageNumber) throws Exception {
      return command.getUsers(pageNumber);
   }

   /**
    * @Action
    * @CallWhen runSearch=true()
    * @DataProvider objectField=users callOnInit=false
    */
   public List doSearch() throws Exception {
      search();

      return getPage().getResults();
   }

   // more code
</pre></div>
  
      <p>And now, how to use the built-in actions for the navigation buttons, as
      defined in the UI xml file:</p>

    <div class="source"><pre>

&lt;button name="previousPage" text="&lt;&lt;" font="bold" type="default" alignment="left"/&gt;
&lt;button name="nextPage" text="&gt;&gt;" font="bold" type="default" alignment="right"/&gt;

</pre></div>
  
    </div></div></div><div class="clear"><hr></hr></div><div id="footer"><div class="xright">© 2004-2005, Summa Tecnologies do Brasil Ltda.</div><div class="clear"><hr></hr></div></div></body></html>