<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><title>Paginação e pesquisas dinâmicas - genesis</title><style type="text/css" media="all">
          @import url("../style/maven-base.css");
          
          @import url("../style/maven-theme.css");</style><link rel="stylesheet" href="../style/print.css" type="text/css" media="print"></link><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta><meta name="author" content="Allan Jones Batista de Castro"></meta><meta name="email" content="allanjones@dev.java.net"></meta><meta name="author" content="Michael Nascimento Santos"></meta><meta name="email" content="mister__m@dev.java.net"></meta></head><body class="composite"><div id="banner"><a href="https://genesis.dev.java.net/" id="projectLogo"><img alt="SOL Genesis" src="../genesis.gif"></img></a><div class="clear"><hr></hr></div></div><div id="breadcrumbs"><div class="xleft">Last published: 23 March 2007
                <span class="separator">|</span> Doc for  3.0-RC1
                </div><div class="xright">
        
        <a href="../index.html">genesis</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-aspect/index.html">genesis-aspect</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-client/index.html">genesis-client</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-server/index.html">genesis-server</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../multiproject/genesis-shared/index.html">genesis-shared</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="../tags/genesis-tags.html">genesis-xdoclet</a>
      </div><div class="clear"><hr></hr></div></div><div id="leftColumn"><div id="navcolumn"><div id="menugenesis"><h5>genesis</h5><ul><li class="none"><a href="../pt-BR/index.html">Visão geral</a></li><li class="none"><a href="../pt-BR/download.html">Downloads</a></li><li class="none"><a href="../pt-BR/release_notes.html">Notas de versão</a></li></ul></div><div id="menuDocumentação"><h5>Documentação</h5><ul><li class="expanded"><a href="../pt-BR/documentation_intro.html">Manual do usuário</a><ul><li class="none"><a href="../pt-BR/documentation_intro.html">Introdução</a></li><li class="none"><a href="../pt-BR/annotations.html">Usando anotações</a></li><li class="none"><a href="../pt-BR/startup.html">Inicializando o genesis</a></li><li class="expanded"><a href="../pt-BR/remoting.html">Funcionalidades básicas</a><ul><li class="none"><a href="../pt-BR/remoting.html">Remotabilidade transparente</a></li><li class="none"><a href="../pt-BR/transactions.html">Suporte a transações</a></li><li class="none"><a href="../pt-BR/hibernate_integration.html">Integração com o Hibernate</a></li><li class="none"><a href="../pt-BR/binding.html">Binding</a></li><li class="none"><a href="../pt-BR/actions.html">Implementando ações mistas</a></li></ul></li><li class="expanded"><a href="../pt-BR/thinlet_binding.html">Funcionalidades específicas para Thinlet</a><ul><li class="none"><a href="../pt-BR/thinlet_binding.html">Binding Thinlet</a></li><li class="none"><a href="../pt-BR/customizing_widgets_creation.html">Customizando a criação de componentes</a></li></ul></li><li class="expanded"><a href="../pt-BR/configuring_swt.html">Funcionalidades específicas para SWT</a><ul><li class="none"><a href="../pt-BR/configuring_swt.html">Configurando as bibliotecas do SWT</a></li></ul></li><li class="expanded"><a href="../pt-BR/conditions.html">Funcionalidades adicionais</a><ul><li class="none"><a href="../pt-BR/conditions.html">Trabalhando com condições</a></li><li class="none"><a href="../pt-BR/populating_with_dataproviders.html">Populando combos, listas e tabelas</a></li><li class="none"><a href="../pt-BR/binding_toggle_buttons.html">Binding de botões de rádio e caixas de seleção</a></li><li class="none"><a href="../pt-BR/binding_strategy.html">Mudando a estratégia de binding</a></li><li class="none"><a href="../pt-BR/formatting.html">Formatando os dados</a></li><li class="none"><a href="../pt-BR/handling_errors.html">Tratando erros</a></li><li class="none"><a href="../pt-BR/validating_data.html">Validando os dados</a></li><li class="none"><a href="../pt-BR/configuring_messages.html">Configurando as mensagens</a></li><li class="none"><strong><a href="../pt-BR/paging_and_dynamic_search.html">Paginação e pesquisas dinâmicas</a></strong></li></ul></li><li class="none"><a href="../pt-BR/quick_reference.html">Guia de referência rápida de anotações</a></li></ul></li><li class="expanded"><a href="../pt-BR/empty_project.html">Desenvolvendo com o genesis</a><ul><li class="none"><a href="../pt-BR/empty_project.html">Para desktops</a></li><li class="none"><a href="../pt-BR/empty_web_project.html">Para web</a></li></ul></li><li class="none"><a href="../pt-BR/useradmin_sample.html">Usando o exemplo UserAdmin</a></li><li class="expanded"><a href="../pt-BR/advanced_introduction.html">Guia avançado</a><ul><li class="none"><a href="../pt-BR/xdoclet_extensions.html">Extensões do XDoclet</a></li><li class="none"><a href="../pt-BR/aspects.html">Aspectos do genesis</a></li><li class="none"><a href="../pt-BR/generic_scripting.html">Suporte a linguagens de script</a></li><li class="none"><a href="../pt-BR/lookup_strategy.html">Estratégias de pesquisa de componentes gráficos</a></li><li class="none"><a href="../pt-BR/widget_binder.html">Customizando o binding de componentes gráficos</a></li></ul></li><li class="none"><a href="../pt-BR/faq.html">FAQ</a></li><li class="none"><a href="http://wiki.java.net/bin/view/Projects/GenesisRoadmap" class="externalLink" title="External Link">Roadmap</a></li><li class="none"><a href="http://wiki.java.net/bin/view/Projects/Genesis" class="externalLink" title="External Link">Wiki</a></li></ul></div><div id="menuProject_Documentation"><h5>Project Documentation</h5><ul><li class="none"><a href="../index.html">About</a></li><li class="collapsed"><a href="../project-info.html">Project Info</a></li><li class="collapsed"><a href="../maven-reports.html">Project Reports</a></li><li class="none"><a href="http://maven.apache.org/development-process.html" class="externalLink" title="External Link">Development Process</a></li></ul></div><div id="menujava_net"><h5>java.net</h5><ul><li class="none"><a href="https://genesis.dev.java.net" class="externalLink" title="External Link">genesis.dev.java.net</a></li><li class="none"><a href="http://java.net" class="externalLink" title="External Link"><img title="java.net member" style="border: 1px" src="../java_dot_net_member.bmp" alt="java.net member"></img></a></li></ul></div><div id="legend"><h5>Legend</h5><ul><li class="externalLink">External Link</li><li class="newWindow">Opens in a new window</li></ul></div><a href="http://maven.apache.org/" title="Built by Maven" id="poweredBy"><img alt="Built by Maven" src="../images/logos/maven-button-1.png"></img></a></div></div><div id="bodyColumn"><div class="contentBox"><div class="section"><a name="Paginação"></a><h2>Paginação</h2>
      <p>O suporte à paginação está implementado no pacote <code>
      net.java.dev.genesis.paging</code>. As duas classes principais são <code>
      Page</code>, que representa uma página de resultados e <code>Pager</code>,
      que é responsável por gerar as páginas.</p>
      <p>As seguintes propriedades estão expostas em <code>Page</code> através
      de getters e setters:
      <ul>
        <li><b>results</b>: uma <code>java.util.List</code> contendo os
        resultados da página atual.</li>
        <li><b>resultsPerPage</b>: número máximo de resultados por página. <b>
        Não contém</b> o número de resultados da página atual; para obter essa
        informação deve-se chamar o método <code>size()</code> em <code>results
        </code>.</li>
        <li><b>pageNumber</b>: número da página atual, baseado em 0.</li>
        <li><b>first</b>: indica se esta é a primeira página. O mesmo que <code>getPageNumber() == 0</code>.</li>
        <li><b>last</b>: indica se esta é a última página. Algumas
        implementações de <code>Pager</code> podem não retornar essa
        propriedade como <code>true</code> quando a última página contiver
        exatamente o número de resultados por página, ou seja, quando
        <code>getResults().size() == getResultsPerPage()</code>.</li>
      </ul></p>
      <p>Enquanto há uma implementação básica para <code>Page</code>
      (<code>PageImpl</code>), não se tem o mesmo para <code>Pager</code>, visto que a
      funcionalidade de um paginador está bastante ligada à origem dos dados que
      este está paginando. Aplicações cliente normalmente não usarão <code>
      PageImpl</code> nem tampouco terão sua própria implementação de <code>Page
      </code>, mas a implementação provida pelo framework pode ser bastante útil
      para implementações específicas de <code>Pager</code>.</p>
      <div class="subsection"><a name="Paginação_de_listas"></a><h3>Paginação de listas</h3>
        <p><code>net.java.dev.genesis.paging.ListPager</code> é uma
        implementação de <code>Pager</code> que pode ser usada para gerar
        páginas a partir de instâncias de <code>java.util.List</code>.</p>
        <p>Existem dois construtores para esta classe: um que aceita somente a
        instância de <code>List</code> e outro que aceita também um parâmetro
        booleano indicando se a propriedade <code>results</code> da instância
        de <code>Page</code> retornada deve ser uma referência direta a uma
        subseção da lista - permitindo assim a modificação da lista original
        pelo código cliente - ou uma nova lista. Caso o primeiro construtor
        seja chamado, o valor dessa propriedade será <code>true</code>, o que
        significa que não será possível alterar o objeto original passado no
        construtor utilizando-se o retorno do método.</p>
        <p>Pode-se utilizar esta classe da seguinte maneira:</p>
        
    <div class="source"><pre>
public class ExemploPaginacaoList {
   public Page getSecao(List lista, int numeroPagina, int resultadosPorPagina)
         throws PagingException {
      return new ListPager(lista).getPage(numeroPagina, resultadosPorPagina);
   }
}
</pre></div>
  
      </div>
      <div class="subsection"><a name="Paginação_com_Hibernate"></a><h3>Paginação com Hibernate</h3>
        <p>Duas implementação de <code>Pager</code> são providas junto com o
        genesis para integração com Hibernate: <code>CriteriaPager</code> e
        <code>QueryPager</code>, implementados em <code>
        net.java.dev.genesis.paging.hibernate</code>. Essas classes podem tanto
        ser usadas diretamente como de forma mais fácil e indireta em uma classe
        que estenda <code>AbstractHibernateCommand</code>. Como ilustração,
        vamos modificar nosso exemplo do Hibernate de modo a executar a consulta
        retornando uma página:</p>
        
    <div class="source"><pre>
public class ExemploPaginacaoHibernate extends AbstractHibernateCommand {
   @Remotable
   public Page getTodos(int numeroPagina, int resultadosPorPagina)
         throws PagingException {
      return getPage(getSession().createQuery("from ClasseMapeada"),
            numeroPagina, resultadosPorPagina);
   }
}
</pre></div>
  
        <p>Para se obter as instâncias de <code>ClasseMapeada</code> de dentro
        da página retornada, basta apenas chamar <code>getResults()</code> no
        objeto <code>Page</code> retornado. Essa <code>List</code> - <code>
        getResults()</code> retorna uma <code>List</code>, conforme explicado
        nas propriedades de <code>Page</code>, logo acima - sempre conterá
        elementos do mesmo tipo que estariam presentes numa chamada a <code>
        query.list()</code> ou <code> criteria.list()</code>.</p>
      </div>
    </div><div class="section"><a name="Trabalhando_com_pesquisas_dinâmicas"></a><h2>Trabalhando com pesquisas dinâmicas</h2>
      <p>O genesis facilita a construção de pesquisas dinâmicas - cujos
      critérios de seleção mudam em tempo de execução, não os valores passados
      para estes - integrando essa funcionalidade tanto com os componentes de
      interface gráfica como com os componentes de negócio. Abaixo, mostraremos
      o suporte a pesquisas dinâmicas com Hibernate, e na seqüência, como é o 
      suporte na parte cliente.</p>
      <div class="subsection"><a name="Pesquisas_dinâmicas_com_Criteria"></a><h3>Pesquisas dinâmicas com Criteria</h3>
        <p>Embora o Hibernate possua suporte a pesquisas dinâmicas, isto é, com
        cláusulas "montadas" ou definidas em tempo de execução através da
        interface <code>Criteria</code>, o uso prático desse suporte básico leva a
        código bastante repetitivo e difícil de manter. O genesis possui suporte a
        pesquisas dinâmicas num nível de abstração mais alto, o que facilita a
        implementação delas. Abordaremos aqui o uso desse suporte com foco na
        camada de negócios.</p>
        <p>Existe uma subinterface de <code>HibernateCommand</code> chamada <code>
        HibernateCriteria</code>. Assim como a <code>Session</code> é injetada
        para instâncias de <code>HibernateCommand</code>, uma instância de
        <code>Criteria</code> é atribuída através do método
        <code>setCriteria(Criteria)</code> para implementações de
        <code>HibernateCriteria</code> nos momentos apropriados. Da mesma forma
        que ocorre com a primeira interface, existe uma classe base para facilitar
        a implementação de <code>HibernateCriteria</code>,
        <code>AbstractHibernateCritcodeeria</code>. Esta classe auxiliar define o
        método <code>getCriteria()</code>, além de outros métodos utilitários.</p>
        <p>O método de negócio que precisa da instância de <code>Criteria</code>
        para sua execução recebe a anotação <code>@Criteria(value=
        &lt;ClasseMapeadaNoHibernate&gt;.class,
        order-by={&lt;propriedades&gt;})</code>.
        Essa anotação implica que o método também é <code>@Remotable</code>,
        mantendo assim a remotabilidade transparente. Antes de invocar este
        método e depois de ter invocado <code>setCriteria(Criteria)</code>, os
        setters das propriedades "preenchidas" do objeto de negócio que tenham
        sido copiadas no cliente (ver documentação do
        <a href="conditions.html#Determinando_se_o_campo_está_vazio">Determinando se o campo está vazio</a>) serão automaticamente chamados
        pelo framework de modo que a recém-injetada instância de
        <code>Criteria</code> possa ser configurada apropriadamente. Finalmente o
        método de negócios será invocado e seu retorno repassado ao código
        cliente.</p>
        <p>Para entender melhor esse conceito, o exemplo abaixo pode ser de ajuda.
        Supondo-se que existe uma classe <code>Pessoa</code> mapeada via
        Hibernate, que, entre outros atributos, possua <code>nome</code> e <code>
        sobrenome</code>, que são os critérios de pesquisa, podemos implementar
        uma pesquisa dinâmica e paginada sobre a classe da seguinte forma:</p>

    <div class="source"><pre>
public class PesquisaPessoa extends AbstractHibernateCriteria {
   public void setNome(String nome) {
      getCriteria().add(Expression.ilike("nome", nome, MatchMode.START));
   }

   public void setSobrenome(String sobrenome) {
      getCriteria().add(Expression.ilike("sobrenome", sobrenome,
            MatchMode.START));
   }

   @Criteria(value=meupacote.Pessoa.class, orderby={"nome", "sobrenome asc"})
   public Page getPessoas(int numeroPagina) throws PagingException {
      return getPage(numeroPagina);
   }
}
</pre></div>
  
        <p>Uma vez tendo copiado as propriedades do formulário para o objeto de
        negócios, a seguinte seqüência de
        eventos ocorre quando o método <code>getPessoas(int)</code> é invocado:
        <ul>
          <li>A instância é transferida pelo servidor através da remotabilidade
          transparente.</li>
          <li>É injetada a sessão do Hibernate através da chamada a <code>
          setSession(Session)</code>, definida em <code>HibernateCommand</code>.
          </li>
          <li>É criado um <code>Criteria</code> tendo como base a entidade
          persistente <code>Pessoa</code>, conforme informado na anotação <code>
          @Criteria</code>.</li>
          <li>A instância de <code>Criteria</code> é injetada através de chamada a
          <code>setCriteria(Criteria)</code>, definido em <code>HibernateCriteria
          </code>.</li>
          <li>Os setters das propriedades que estavam preenchidas no form no
          momento da cópia são chamados. A classe <code>PesquisaPessoa</code> tem
          então a chance de restringir o <code>Criteria</code> somente para os
          campos de busca, sem ter de se preocupar se o campo foi preenchido ou
          não, já que o genesis garante que se o setter foi chamado, o campo foi
          preenchido.</li>
          <li>Finalmente, o método <code>getPessoas(int)</code> é chamado e o
          resultado retornado para o cliente de forma transparente.</li>
        </ul>
        </p>
        <p>Para casos específicos, é possível utilizar a anotação sem informar o 
        nome da classe mapeada no Hibernate. Neste caso, a instância de 
        <code>Criteria</code> não será criada e o valor injetado na classe será 
        <code>null</code>, mas o resto do comportamento descrito acima será 
        mantido. Isto é útil quando é necessário realizar pesquisas dinâmicas 
        complexas que não podem ser implementadas com <code>Criteria</code>.</p>
      </div>
      <div class="subsection"><a name="Pesquisas_dinâmicas_no_codigo_cliente"></a><h3>Pesquisas dinâmicas no codigo cliente</h3>
        <p>Na parte cliente, para permitir que somente as propriedades prenchidas
        sejam utilizadas na busca, basta fazer:</p>

    <div class="source"><pre>
CriteriaPropertyHelper.fillCriteria(hibernateCriteria, form);
</pre></div>
  
        <p>A classe <code>CriteriaPropertyHelper</code> encontra-se no pacote
        <code>net.java.dev.genesis.helpers</code>. <code>hibernateCriteria</code>
        deve obedecer os
        <a href="#Pesquisas_dinâmicas_com_Criteria">requisitos para pesquisas dinâmicas</a>
        explicado anteriormente, enquanto <code>form</code> deve ser um form do genesis válido.
        Serão copiadas as propriedades que existam em ambos os beans e que estejam
        preenchidas no form de acordo com as
        <a href="conditions.html#Determinando_se_o_campo_está_vazio">regras para determinar
        campos vazios</a>. A chamada a <code>fillCriteria(HibernateCriteria,
        Object)</code> deverá ser feita antes da chamada ao método anotado com
        <code>@Criteria</code>.</p>
        <p>Para tornar ainda mais simples a construção de pesquisas dinâmicas com
        resultados paginados, duas classes auxiliares são definidas no pacote
        <code>net.java.dev.genesis.ui.paging</code>: <code>BaseSearchForm</code> e
        <code>BaseCriteriaSearchForm</code>. Estas classes abstratas podem ser
        estendidas pelos forms, diminuindo o esforço de implementação.</p>
        <p><code>BaseSearchForm</code> contém lógica relacionada com a paginação,
        além de abstrair o processo de execução da pesquisa. Algumas ações e
        propriedades podem ser utilizadas diretamente na construção da interface
        gráfica:</p>
        <ul>
          <li><code>previousPage()</code> e <code>nextPage()</code> são ações do
          genesis que podem ser ligadas aos botões na tela que navegarão para a
          página anterior e a próxima página de resultados, respectivamente.
          Possuem anotações <code>@VisibleWhen</code> que ocultarão os widgets
          nas situações corretas.</li>
          <li><code>pageNumber</code> é a propriedade que contém o número da
          página de resultados atual.</li>
        </ul>
        <p>Esta classe também define o método abstrato <code>performSearch()</code>, que retorna uma instância de
        <code>net.java.dev.genesis.paging.Page</code> e expõe a propriedade
        <code>runSearch</code>, que deve ser usada na expressão condicional de
        execução da busca nas subclasses. Normalmente, não será necessário
        utilizá-la diretamente, já que <code>BaseCriteriaSearchForm</code> provê
        um nível de abstração maior quando a pesquisa é realizada por uma
        implementação de <code>HibernateCriteria</code>. Neste caso, bastará
        implementar os métodos <code>getHibernateCriteria()</code> de modo a
        retornar o objeto de negócios - que receberá os critérios de busca através
        de uma  chamada a <code>CriteriaPropertyHelper</code> - e o método
        <code>performSearch(int pageNumber)</code>, que efetuará a pesquisa.
        Abaixo encontra-se um exemplo de seu uso extraído do useradmin. Primeiro,
        vemos o trecho de código relevante do form:</p>

    <div class="source"><pre>
@Form
public class UserListForm extends BaseCriteriaSearchForm {
   private final UserSearchCommand command = new UserSearchCommand();

   // codigo para getters e setters de criterios de pesquisa

   public String getName() { /* ... */ }

   public void setName(String name) { /* ... */ }

   public String getEmail() { /* ... */ }

   public void setEmail(String email) { /* ... */ }
  
   public String getLogin() { /* ... */ }

   public void setLogin(String login) { /* ... */ }
  
   protected HibernateCriteria getHibernateCriteria() {
      return command;
   }

   protected Page performSearch(int pageNumber) throws Exception {
      return command.getUsers(pageNumber);
   }

   @Action
   @CallWhen("form.runSearch")
   @DataProvider(objectField="users", callOnInit=false)
   public List doSearch() throws Exception {
      search();

      return getPage().getResults();
   }

   // codigo restante
</pre></div>
  
        <p>E o uso das ações para os botões de navegação na interface
        gráfica:</p>
        <p><b>Thinlet:</b></p>

    <div class="source"><pre>

&lt;button name="doSearch" halign="right" text="i18n.button.search" font="bold" mnemonic="0" type="default"/&gt;
 
... 
&lt;button name="previousPage" text="&lt;&lt;" font="bold" type="default" alignment="left"/&gt;
&lt;button name="nextPage" text="&gt;&gt;" font="bold" type="default" alignment="right"/&gt;

</pre></div>
  
        <p><b>Swing:</b></p>

    <div class="source"><pre>

searchButton = new JButton(getMessage("button.search"));
searchButton.setName("doSearch");

...  
previousPage = new JButton("&lt;&lt;");
previousPage.setName("previousPage");

...
nextPage = new JButton("&gt;&gt;");
nextPage.setName("nextPage");

</pre></div>
  
        <p><b>SWT:</b></p>

    <div class="source"><pre>

searchButton = new Button(shell, SWT.NONE);
searchButton.setText(getMessage("button.search"));
searchButton.setData("doSearch");

...  
previousPage = new Button(shell, SWT.NONE);
previousPage.setText("&lt;&lt;");
previousPage.setData("previousPage");

...
nextPage = new Button(shell, SWT.NONE);
nextPage.setText("&gt;&gt;");
nextPage.setData("nextPage");

</pre></div>
  
        <p>E a classe de negócio:</p>

    <div class="source"><pre>
public class UserSearchCommand extends AbstractHibernateCriteria {
   public void setEmail(String email) {
      getCriteria().add(Expression.ilike("email", email, MatchMode.START));
   }

   public void setLogin(String login) {
      getCriteria().add(Expression.ilike("login", login, MatchMode.START));
   }

   public void setName(String name) {
      getCriteria().add(Expression.ilike("name", name, MatchMode.START));
   }
   
   @Criteria(value=User.class, orderby="name")
   public Page getUsers(final int pageNumber) throws Exception {
      return getPage(pageNumber);
   }
}
</pre></div>
  
      </div>
    </div></div></div><div class="clear"><hr></hr></div><div id="footer"><div class="xright">© 2004-2007, Summa Tecnologies do Brasil Ltda.</div><div class="clear"><hr></hr></div></div></body></html>