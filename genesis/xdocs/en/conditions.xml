<?xml version="1.0" encoding="ISO-8859-1"?>
<document>
  <properties>
    <title>Working with conditions</title>
    <author email="allanjones@dev.java.net">Allan Jones Batista de Castro</author>
    <author email="mister__m@dev.java.net">Michael Nascimento Santos</author>
  </properties>
  <body>
    <section name="Working with conditions">
      <p>A powerful concept in genesis is support for conditions. This support
      is the basis for several features, such as controlling the enabled state 
      of a widget, its visibility, automatically clearing fields and 
      automatically calling a method. All these things are done 
      declaratively in the form, with no need to deal with the graphical API
      used for views.</p>
      <subsection name="Enabling and disabling components">
        <p>It's fairly common in UI development to find a situation where a 
        certain field or button can only be enabled if a certain condition is 
        true. In order to simplify implementing such cases, genesis provides an 
        annotation called <code>@EnabledWhen</code>. This annotation can be used 
        in attributes and actions. A practical usage example is shown below:</p>
<source>
@Form
public class EnabledWhenFormExample {
   private boolean married;
   private String spouseName;

   public boolean isMarried() {
      return married;
   }

   public void setMarried(boolean married) {
      this.married = married;
   }

   @EnabledWhen("form.married")
   public String getSpouseName() {
      return spouseName;
   }

   public void setSpouseName(String spouseName) {
      this.spouseName = spouseName;
   }
}
</source>
        <p>In the example above, it will be possible to enter the spouse's name 
        only when the widget representing property <code>married</code> is
        <code>true</code> .</p>
      </subsection>
      <subsection name="Controlling visibility">
        <p>It's possible to hide or show widgets conditionally using the
        <code>@VisibleWhen</code> annotation . Its syntax is similar to the one
        for <code>@EnabledWhen</code> and it also may be used to annotate
        attributes or actions. A usage example in an action is shown below:</p>
<source>
@Form
public class VisibleWhenFormExample {
   private int dependantNumber;

   public int getDependantNumber() {
      return dependantNumber;
   }

   public void setDependantNumber(int dependantNumber) {
      this.dependantNumber = dependantNumber;
   }

   @Action
   @VisibleWhen("form.dependantNumber > 0")
   public void calculateAdditionalTaxes() {
      // ...
   }

   // ...
}
</source>
        <p>The button representing <code>calculateAdditionalTaxes()</code> will
        be visible only when <code>dependantNumber</code> is greater than zero.
        </p>
      </subsection>
      <subsection name="Widget groups">
        <p>In many cases, some operations need to be executed for a group of 
        widgets. For example, it might be necessary to make a whole group 
        visible or enabled at once. In order to understand how to achieve that, 
        let's examine a pratical example. Below, we have the same user interface 
        coded in Thinlet and Swing:</p>
<source>
<![CDATA[
...
<label text="Current Date:" font="bold"/>
<panel width="10" height="1" />
<textfield name="currentDate" />
...
]]>
</source>
<source>
<![CDATA[
//..
getContentPane().setLayout(new GridLayout(1, 2, 10, 0));

JLabel currentDateLabel = new JLabel();
currentDateLabel.setText("Current Date:");
getContentPane().add(currentDateLabel);

JTextField currentDate = new javax.swing.JTextField();
currentDate.setName("currentDate");
getContentPane().add(currentDate);

//..
]]>
</source>

        <p>For both interfaces above, the developer's intention is to show the 
        field "Current Date" only if certain conditions are matched. To make 
        this happen, the <code>@VisibleWhen</code> annotation is used as the 
        following code snippet shows:</p>
<source>
@VisibleWhen("certainConditions")
public Date getCurrentDate() {
   ...
}
</source>
        <p>However, what actually happens is that only the text field
        (<code>textfield</code>/<code>JTextField</code>) will become invisible 
        (if conditions are not satisfied). Notice that the
        <code>label</code>/<code>JLabel</code> and the <code>panel</code> (used 
        for spacing in Thinlet) will not become invisible - clearly, this is not 
        what was originally intented. All three controls should follow the same
        visibility rules.</p>
        <p>In order to fix it, we need to use the <code>widgetGoup</code>
        property of the <code>textfield</code> thinlet xml attribute - see
        the following usage:</p>
<source>
<![CDATA[
...
<label name="currentDateLabel" text="Current Date:" font="bold"/>
<panel name="currentDateSpace" width="10" height="1" />
<textfield name="currentDate"
      property="widgetGroup=currentDateLabel,currentDateSpace"/>
...
]]>
</source>
        <p>Notice that the widgets <code>label</code> and <code>panel</code>
        are now named and referred by the <code>widgetGroup</code> property,
        separated by a comma.</p>
        <p>For Swing, we must define a <code>clientProperty</code> named
        <code>SwingBinder.WIDGET_GROUP_PROPERTY</code> as shown below:</p>
<source>
<![CDATA[
//..
getContentPane().setLayout(new GridLayout(1, 2, 10, 0));

JLabel currentDateLabel = currentDateLabel = new JLabel();
currentDateLabel.setName("currentDateLabel");
currentDateLabel.setText("Current Date:");
getContentPane().add(currentDateLabel);

JTextField currentDate = new javax.swing.JTextField();
currentDate.setName("currentDate");
currentDate.putClientProperty(SwingBinder.WIDGET_GROUP_PROPERTY, "currentDateLabel");
getContentPane().add(currentDate);

//..
]]>
</source>
        <p>Notice that the value of the <code>clientProperty</code> is the 
        <code>name</code> of the <code>JLabel</code> instance. If there were
        additional components, their names should be comma-separated or a 
        <code>String</code> array could be used instead. Other valid values for
        <code>clientProperty</code> would be the component itself or a 
        collection/array of components, as shown below:</p>
<source>
//..
getContentPane().setLayout(new GridLayout(1, 2, 10, 0));

JLabel currentDateLabel = currentDateLabel = new JLabel();
currentDateLabel.setName("currentDateLabel");
currentDateLabel.setText("Data Corrente:");
getContentPane().add(currentDateLabel);

JTextField currentDate = new javax.swing.JTextField();
currentDate.setName("currentDate");
currentDate.putClientProperty(SwingBinder.WIDGET_GROUP_PROPERTY, <b>currentDateLabel</b>);
getContentPane().add(currentDate);

//..
</source>
        <p>By defining this property, all widgets will follow the visibility 
        rule defined by the annotation above.</p>
        <p>Besides the <code>widgetGroup</code> property, there are two more
        specific properties, <code>enabledWidgetGroup</code>
        and <code>visibleWidgetGroup</code>, that define independent groups for 
        enabling/disabling and visible/invisible rules. These properties are 
        provided because it is common to have different groups for these rules. 
        For example:</p>
<source>
<![CDATA[
...
<label name="clientLabel" text="Client:" font="bold"/>
<panel name="clientSpace1" width="10" height="1" />
<textfield name="clientCode" ... />
<panel name="clientSpace2" width="10" height="1" />
<textfield name="clientName"
      property="enabledWidgetGroup=clientCode;
            visibleWidgetGroup=clientLabel,clientSpace1,
                               clientCode,clientSpace2"/>
...
]]>
</source>
        <p>By using these properties, it is possible to define a 
        enabling/disabling rule that will affect only <code>clientCode</code> 
        and <code>clientName</code> and a visibility rule that will affect the 
        whole group, including the label and all panels for spacing.</p>
        <p>For Swing, <code>SwingBinder.ENABLED_GROUP_PROPERTY</code> and
        <code>SwingBinder.VISIBLE_GROUP_PROPERTY</code> can be used as 
        <code>clientProperty</code>s.</p>
      </subsection>
      <subsection name="Clearing field content">
        <p>Under many conditions it is necessary to clear the content of some 
        fields. genesis can do that automatically for the programmer if the
        <code>@ClearOn</code> annotation is used. Although its syntax is similar 
        to <code>@EnabledWhen</code> and <code>@VisibleWhen</code> syntax, this
        annotation can only be used for attributes and not for actions (since
        actions do not have content). A previous example may be modified to 
        become more correct:</p>
<source>
@Form
public class ClearOnFormExample {
   private boolean married;
   private String spouseName;

   public boolean isMarried() {
      return married;
   }

   public void setMarried(boolean married) {
      this.married = married;
   }

   @EnabledWhen("form.married")
   @ClearOn("!form.married")
   public String getSpouseName() {
      return spouseName;
   }

   public void setSpouseName(String spouseName) {
      this.spouseName = spouseName;
   }
}
</source>
        <p>When property <code>married</code> is <code>false</code>,
        <code>spouseName</code> will be automatically reset to
        <code>null</code>.</p>
        <p>The value used for resetting is defined by <code>@EmptyValue</code>.
        This annotation should be used for the attribute whose empty value is
        being specified. Its syntax is:</p>
<source>
@EmptyValue("value")
</source>
        <p>If <code>@EmptyValue</code> is not specified, a default value is used
        instead - <code>false</code> for booleans, zero for numeric types and
        <code>null</code> otherwise.</p>
        <p>The annotation <code>@ClearOn</code> can be used together with
        <code>@DataProvider</code> annotation. The DataProviders widgets will
        be cleaned and the form properties that store selected values will be
        automatically reset to <code>null</code> when script condition is satisfied.
        See the following usage:</p>
<source>
   @DataProvider(objectField="state")
   @ClearOn("&lt;some script condition&gt;")
   public List populateStates() {
      ...
   }
</source>
      </subsection>
      <subsection name="Automatically invoking methods">
        <p>Some methods need to be called every time certain conditions are
        true. Instead of forcing programmers to do that manually - what can lead
        to the so-called "spaghetti" code -, genesis defines the
        <code>@CallWhen</code> annotation. With a syntax similar to previous
        annotations, it can be used only for actions and not for attributes.</p>
        <p>A previous example can be modified to show how to use this annotation
        in practice:</p>
<source>
@Form
public class CallWhenFormExample {
   private int dependantNumber;

   public int getDependantNumber() {
      return dependantNumber;
   }

   public void setDependantNumber(int dependantNumber) {
      this.dependantNumber = dependantNumber;
   }

   @Action
   @CallWhen("form.dependantNumber > 0")
   public void calculateAdditionalTaxes() {
      // ...
   }
}
</source>
        <p>Differently from the original <code>@VisibleWhen</code> example,
        <code>calculateAdditionalTaxes()</code> will be invoked automatically by
        genesis whenever <code>dependantNumber</code> is greater than zero.</p>
      </subsection>
      <subsection name="Declaring conditions">
        <p>Although all anotations that have script conditions as arguments are
        capable of handling any type of expression, certain conditions may be
        used repeatedly in the code or as part of another expression. Due to
        that fact, genesis makes it possible to declare these conditions and 
        export them as variables that may be referenced in other points of code.
        The <code>@Condition</code> annotation is used to declare a condition
        and its syntax is:</p>
<source>
@Condition("conditionName=scriptExpression")
</source>
        <p>The variable named <code>conditionName</code> is exported in order to
        represent the expression <code>scriptExpression</code> in other points
        in the code. How to reference such a variable in script expressions is
        language-dependent.</p>
        <p>This annotation may be used at class level, in an attribute getter or
        in a method annotated as <code>@Action</code>. Its scope will always be
        class-wide, no matter where it's declared. Obviously, this annotation is
        useful only when used together with another conditional annotation that
        references the exported variable, as the ones mentioned above.</p>
      </subsection>
    </section>
    <section name="Determining if a field is empty">
      <p>In order to perform or not to perform some operations, genesis needs to
      determine whether a field is empty. Besides that, whether a field is
      filled or empty is usually used to define a condition for some genesis'
      annotations. Interface <code>EmptyResolver</code>, defined on
      <code>net.java.dev.genesis.resolvers</code> is used for that.</p>
      <p>This interface exposes a single method ,<code>isEmpty(Object)</code>,
      that returns a <code>boolean</code>. To specify which
      <code>EmptyResolver</code> implementation should be used for a certain 
      attribute, it should be annotationed with <code>@EmptyResolver</code>. Its 
      syntax is:</p>
<source>
@EmptyResolver(value=&lt;classThatImplementsInterface&gt;,
               properties=&lt;attributes&gt;)
</source>
      <p>In order to avoid requiring the definition of an 
      <code>EmptyResolver</code> implementation for every attribute in each form 
      in an application, genesis has a mechanism for determining which 
      implementation should be used based on the type of the attribute.
      The <code>EmptyResolverRegistry</code> class keeps a registry of default
      <code>EmptyResolver</code> implementations per class. The following
      implementations are initially set up:</p>
      <ul>
        <li><code>MapEmptyResolver</code> is registered for
        <code>java.util.Map</code> instances. Returns <code>true</code> when the
        value is null or when <code>java.util.Map.isEmpty()</code> returns 
        <code>true</code>.</li>
        <li><code>CollectionEmptyResolver</code> is the default implementation
        for <code>java.util.Collection</code>. It uses the same principle that
        <code>MapEmptyResolver</code> does in order to determine whether an
        instance is empty or not.</li>
        <li>The default implementation for <code>String</code> is
        <code>StringEmptyResolver</code>. Instances are considered empty if they
        are null or have zero length after spaces are removed, i.e., 
        <code>s == null || s.trim().length() == 0</code>.</li>
        <li>For the remaining cases, a <code>DefaultEmptyResolver</code> 
        instance is registered. This implementation considers as empty null 
        instances or zero-element arrays.</li>
      </ul>
      <p>These default implementations should work fine for most cases. As an 
      example of how to customize if necessary, let's consider how to use the 
      annotation in a form attribute for which empty spaces are actually 
      relevant:</p>
<source>
@EmptyResolver(properties="trim=false")
public String getAttribute() {
   return attribute;
}
</source>
      <p>Since <code>String</code> has a <code>EmptyResolver</code> instance
      registered default for it, <code>StringEmptyResolver</code>, and this 
      implementation exposes an attribute that allows one to configure
      whether spaces should be removed or not, it's not necessary to specify the
      name of the interface implementation class and defining 
      property <code>trim</code> as <code>false</code> solves the problem. If 
      using the default instance weren't suitable, another implementation could 
      be used instead, as shown here:</p>
<source>
@EmptyResolver(com.company.package.EmptyResolverImplementation.class)
public String getAttribute() {
   return attribute;
}
</source>
      <subsection name="Verifying if a field is empty in conditional
      expressions">
        <p>As already mentioned, it's usual to define conditions that are based 
        on a field being empty or not. genesis exposes script
        auxiliary functions that may be used in conditions in order to make this
        task easier: <code>isEmpty(any)</code> and 
        <code>isNotEmpty(any)</code>.</p>
        <p>When the argument is a form property, the <code>EmptyResolver</code>
        instance configured for the property - determined as explained above - 
        is used to evaluate the return value. If the argument is a variable or a 
        constant, a <code>EmptyResolver</code> implementation for the expression 
        type is obtained from <code>EmptyResolverRegistry</code> and used for
        evaluation. These functions may be used with 
        <a href="generic_scripting.html">Javascript</a> as shown below:</p>
<source>
public String getAttribute() {
   return attribute;
}

public void setAttribute(String attribute) {
   this.attribute = attribute;
}

@EnabledWhen("genesis.isNotEmpty('form:attribute')")
public String getDependantAttribute() {
   return dependantAttribute;
}

public void setDependantAttribute(String dependantAttribute) {
   this.dependantAttribute = dependantAttribute;
}
</source>
        <p>Notice that <code>'form:attribute'</code> is informed as the function 
        parameter. This is required in order to use the value of 
        <code>attribute</code> instead of the <code>'attribute'</code> literal 
        as an argument.</p>
        <p>Which syntax to use for this function for other programming languages
        can be checked at the <a 
        href="quick_reference.html#genesis_script_functions">annotation quick 
        reference guide</a>.</p>
      </subsection>
    </section>
    <section name="Comparing values">
      <p>Both the framework and developers ocasionally need to check if a field
      value has been changed or if its value is equal to some constant or
      another field's value. Interface <code>EqualityComparator</code> contained
      in the <code>net.java.dev.genesis.equality</code> package is implemented 
      by classes that are capable of making such a decision.</p>
      <p>This interface defines the <code>equals(Object,Object)</code> method 
      that returns a <code>boolean</code> indicating whether compared instances 
      are equal or not. The annotation with the same name, 
      <code>@EqualityComparator</code>, can be used to explicitly define the 
      implementation to be used for an attribute. Its syntax is similar to 
      <code>@EmptyResolver</code>'s one:</p>
<source>
@EqualityComparator(value=&lt;classThatImplementsInterface&gt;,
                    properties=&lt;attributes&gt;)
</source>
      <p>Usually it won't be necessary to use this annotation since genesis also
      has a default mechanism for determining which interface implementation
      should be used for a given attribute. The mapping between class and 
      implementation is kept by <code>EqualityComparatorRegistry</code>. The 
      implementations registered by default are:</p>
      <ul>
        <li><code>BigDecimalEqualityComparator</code> considers two
        <code>java.math.BigDecimal</code> instances equal if both are null or
        if calling <code>compareTo(BigDecimal)</code> for one of them returns 
        zero.</li>
        <li><code>StringEqualityComparator</code> considers null or zero-length
        trimmed <code>String</code>s equal. They'll also be considered equal if
        <code>s1.trim().equals(s2.trim())</code>.</li>
        <li>All the remaining cases are handled by 
        <code>DefaultEqualityComparator</code>, that considers two instances to 
        be equal if both are null or if <code>o1.equals(o2)</code> returns 
        <code>true</code>.</li>
      </ul>
      <subsection name="Verifying field value changes and doing comparisson in
          conditional expressions">
        <p>Some script functions are exported by genesis in order to help
        developers in common tasks:</p>
        <ul>
          <li><code>hasChanged(property)</code> and
          <code>hasNotChanged(property)</code> verify whether a field value
          has changed or not.</li>
          <li><code>equals(any,any)</code> and
          <code>notEquals(any,any)</code> compare two values - that may be
          constants, form properties or variables - and return the comparisson
          result.</li>
        </ul>
        <p>genesis internally keeps track of what fields had their value changed 
        in the current iteraction. This list is checked by functions
        <code>hasChanged(property)</code> and
        <code>hasNotChanged(property)</code>. To determine whether a value
        has been changed or not and to populate this internal list, the
        framework uses the <code>EqualityComparator</code> instance configured
        for the property.</p>
        <p>Functions <code>equals(any,any)</code> and
        <code>notEquals(any,any)</code> also make use of
        <code>EqualityComparator</code> instances to determine their output.
        However, the actual process used for that is a bit more complicated, as
        explained below:</p>
        <ul>
          <li>First, which <code>EqualityComparator</code> instance to use for 
          each parameter is determined. If the parameter is a form property, 
          the implementation configured for it will be used. Otherwise, the 
          implementation registered in <code>EqualityComparatorRegistry</code> 
          for the type will be picked up.</li>
          <li>If comparators for both parameters are the same, the first one of
          them will be used to do the comparisson.</li>
          <li>If the first parameter type is assignable to the second parameter
          type, its <code>EqualityComparator</code> instance will be used for
          performing the comparisson.</li>
          <li>If the second parameter type is assignable to the first parameter 
          type, its <code>EqualityComparator</code> instance will be used for 
          performing the comparisson.</li>
          <li>If none of the above conditions is true, <code>false</code> will
          be returned.</li>
        </ul>
        <p>Let's see how to use one function of each pair using <a 
        href="generic_scripting.html">Javascript</a>:</p>
<source>
public BigDecimal getTax() {
   return tax;
}

public void setTax(BigDecimal tax) {
   this.taxa = tax;
}

@Action
@CallWhen("genesis.hasChanged('form:tax')")
public void recalculateValues() {
   // logic for recalculating
}
</source>
<source>
public BigDecimal getDebt() {
   return debt;
}

public void setDebt(BigDecimal debt) {
   this.debt = debt;
}

public BigDecimal getPaidAmount() {
   return paidAmount;
}

public void setPaidAmount(BigDecimal paidAmount) {
   this.paidAmount = paidAmount;
}

@Action
@CallWhen("genesis.notEquals('form:debt', 'form:paidAmount')")
public void calculateRemainingAmount() {
   // logic for calculating amount
}
</source>
      </subsection>
      <subsection name="Changing the way values are cloned">
         <p>In previous releases, property values were just copied as part of 
         form state, what limited the way change detection worked. For example, 
         if the value of a property was a JavaBean and one of its own properties 
         changed, it was not possible to detect this change by using 
         <code>genesis.hasChanged('form:property')</code>, since both the 
         previous state copy that genesis hold and the current value would point 
         to the same instance in memory.</p>
         <p>Starting from release 2.3, a new API has been introduced that allows
         to control how genesis generates a copy of the previous value of a 
         property. The <code>net.java.dev.genesis.cloning.Cloner</code> 
         interface has a single <code>clone(Object)</code> method that returns 
         the value genesis is suposed to keep as a copy of the value used as an
         argument to the call. The default implementation of that interface - 
         provided by <code>net.java.dev.genesis.cloning.DefaultCloner</code> - 
         simply returns the value used as a parameter, thus preserving backwards 
         compatibility.</p>
         <p>In a way similar to <code>EqualityComparator</code>, there is a 
         registry, <code>net.java.dev.genesis.cloning.ClonerRegistry</code>, 
         that associates <code>Cloner</code> implementations with the classes 
         used for properties, as well as an annotation, <code>@Cloner</code>, 
         that allows <code>Cloner</code> implementations to be overridden on a 
         property basis.</p>
         <p>The following code shows how to override the <code>Cloner</code> 
         implementation both globally and for a specific bean property:</p>
<source>
ClonerRegistry.getInstance().register(User.class, new BeanUtilsCloner());
</source>
<source>
@Form
public class ClonerFormExample {
   @Cloner(net.java.dev.genesis.cloning.BeanUtilsCloner.class)
   public User getUser() {
      // ...
   }

   // ...
}
</source>
         <p>The class used in both examples above,  
         <code>net.java.dev.genesis.cloning.BeanUtilsCloner</code>, is the other 
         implementation provided by genesis that clones the value using the 
         Commons BeanUtils API.</p>
      </subsection>
    </section>
  </body>
</document>