<?xml version="1.0" encoding="ISO-8859-1"?>
<document>
  <properties>
    <title>User interface component model</title>
    <author email="mister__m@dev.java.net">Michael Nascimento Santos</author>
  </properties>
  <body>
    <section name="UI components additional features">
      <p>The following features and/or concepts are explained below:
      <ul>
        <li><a href="#Using POJOs to handle events">Using POJOs to handle
        events</a></li>
        <li><a href="#Handling errors">Handling errors</a></li>
        <li><a href="#Conditionally controlling a form and a UI"
        >Conditionally controlling a form and a UI</a></li>
        <li><a href="#Determining if a field is empty">Determining if a field is
        empty</a></li>
        <li><a href="#Comparing values">Comparing values</a></li>
        <li><a href="#Populating comboboxes, lists and tables">Populating
        comboboxes, lists and tables</a>
        </li>
        <li><a href="#Formatting">Formatting</a></li>
        <li><a href="#Customizing how components are created">Customizing how 
        components are created</a></li>
        <li><a href="#Configuring messages">Configuring messages</a>
        </li>
        <li><a href="#Working with dynamic searches">Working with dynamic
        searches</a></li>
      </ul>
      </p>
    </section>
    <section name="Using POJOs to handle events">
      <p>The Thinlet API allows arbritary objects (POJOs) to be used to handle
      events produced by the graphical interface, by using the
      <code>parse(.., Object handler)</code> method. Since this is a native
      Thinlet method, nothing is needed to take advantage of this feature in
      genesis.</p>
      <p>However, in some architectures it would be nice to use these objects
      not only for handling Thinlet events, but also to implement methods
      annotated as <code>@BeforeAction</code> and/or
      <code>@AfterAction</code>. To allow that, a new annotation,
      <code>@ViewHandler</code>, has been introduced since release 2.1 and
      should be used in the class containing these methods. New overloaded
      versions of the <code>bind(..)</code> and <code>prepareBinder(..)</code>
      have been created, receiving as an additional parameter the object that
      will be used to handle events.</p>
      <p>This feature may be used as shown below:</p>
<source>
public class ViewHandlerExampleView extends BaseDialogThinlet {
   public ViewHandlerExampleView(Frame frame) throws Exception {
      super(frame);

      // code for view setup

      Object handler = new ViewHandlerExample(this);
      add(parse("view.xml", handler));

      bind(this, new ViewHandlerExampleForm(), handler);
   }
}
</source>

<source>
/**
 * @Form
 */
public class ViewHandlerExampleForm {
   /**
    * @Action
    */
   public void remove() {
      // removal logic
   }
}
</source>

<source>
/**
 * @ViewHandler
 */
public class ViewHandlerExample {
   private final ViewHandlerExampleView view;

   public ViewHandlerExample(ViewHandlerExampleView view) {
      this.view = view;
   }

   /**
    * @BeforeAction
    */
    public boolean remove() {
       return OptionDialog.displayYesNo(view, "Confirmation",
             "Are you sure you want to remove it?") == OptionDialog.Option.YES;
    }
}
</source>
    </section>
    <section name="Handling errors">
      <p>Thinlet has got a method for handling errors, <code>
      handleException(Throwable)</code>, so <code>BaseThinlet</code> overrides
      this method in order to implement custom error handling. We've been
      careful while developing genesis so that any error that happens get
      redirected to this single point, centralizing error handling.</p>
      <p>The default error handling implementation in genesis works in a case-
      by-case basis, as explained below:</p>
      <ul>
        <li>If the error is an instance of <code>ScreenNotFoundException</code>
        (that is thrown when a UI xml file is not found), the error is handled
        using <code>handleException(String, Throwable)</code>.</li>
        <li>If a <code>ValidationException</code> has happened, it is handled by
        <code>showValidationErrors(ValidationException)</code>.</li>
        <li>When the error is a <code>UIException</code>, it's handled by <code>
        handleUIException(UIException)</code>.</li>
        <li>If all previous checks fail, the exception is passed to
        <code>handleCustomException(Throwable)</code> that returns a
        <code>boolean</code> indicating whether the error has been handled or
        not.</li>
        <li>When an error hasn't been handled,
        <code>handleUnknownException(Throwable)</code> gets invoked, ending the
        error handling chain.</li>
      </ul>
      <p>For most users, it's enough to know how each error will be handled by
      the framework. However, any of the above described methods can be
      overridden if there is a need to customize error handling. Each method's
      default behaviour is described below:</p>
      <ul>
         <li><code>handleException(String, Throwable)</code> uses
         <code>ErrorReporterDialog</code> to display the error. The message
         returned by <code>getErrorMessage()</code> is used as the window title,
         whose default is the constant "Error".</li>
         <li><code>showValidationErrors(ValidationException)</code> extracts
         errors from <code>ValidationException</code>, formats them by putting a
         <code>\n</code> - used for breaking lines - between them and finally
         displays them with a <code>MessageDialog</code>. The window title will
         be the String value for <code>validation.errors.title</code> in the
         <a href="#Configuring messages">resource file</a>.</li>
         <li><code>handleUIException(UIException)</code> displays the error
         using a <code>MessageDialog</code>. Title and message will be extracted
         from the exception itself.</li>
         <li><code>handleCustomException(Throwable)</code> checks if the error
         has another exception as its cause by invoking <code>getCause()</code>
         in the exception instance. If it has got a cause, this cause will be
         forwarded to <code>handleException(Throwable)</code>. Otherwise,
         <code>false</code> will be returned to indicate the error cannot be
         handled.</li>
         <li><code>handleUnknownException(Throwable)</code> simply forwards the
         error to <code>handleException(String, Throwable)</code> using the
         constant "Unexpected error occurred" as the error message.</li>
      </ul>
    </section>
    <section name="Conditionally controlling a form and a UI">
      <p>A powerful concept in genesis is support for conditions. This supprt
      allows implementation of a variety of features, such as controlling the
      enabled state of a widget, its visibility, automatically clearing fields
      and automatically calling a method. All these things are done
      declaratively on the form, with no need to deal with the graphical API
      used for views.</p>
      <subsection name="Declaring conditions">
        <p>Although all anotations that have script conditions as arguments are
        capable of handling any type of expression, certain conditions may be
        used repeatedly in the code or as part of another expression. Due to
        that, genesis makes it possible to declare these conditions and export
        them as variables that may be referenced in other points of the code.
        The annotation <code>@Condition</code> is used to declare a condition,
        whose syntax is:</p>
<source>
@Condition conditionName=scriptExpression
</source>
        <p>The variable named <code>conditionName</code> is exported in order to
        represent the expression <code>scriptExpression</code> in other points
        in the code. As every other script variable, when it's used on a
        expression its name should be preceeded by <code>$</code>. In the
        example above, the variable should be referenced in a conditional
        expression as <code>$conditionName</code>.</p>
        <p>This annotation may be used at class level, in an attribute getter or
        in a method annotated as <code>@Action</code>. Its scope will always be
        class-wide, no matter where it's declared. Obviously, this annotation is
        useful only when used together with another conditional annotation that
        references the exported variable, as the ones mentioned below.</p>
      </subsection>
      <subsection name="Enabling and disabling components">
        <p>It's fairly common in UI development situations when a certain field
        or button can only be enabled when a certain condition is true. In order
        to simplify these cases, genesis has an annotation called
        <code>@EnabledWhen</code>. This annotation may be used in attributes and
        actions. A practical usage example is shown below:</p>
<source>
/**
 * @Form
 */
public class EnabledWhenFormExample {
   private boolean married;
   private String spouseName;

   public boolean isMarried() {
      return married;
   }

   public void setMarried(boolean married) {
      this.married = married;
   }

   /**
    * @EnabledWhen married=true()
    */
   public String getSpouseName() {
      return spouseName;
   }

   public void setSpouseName(String spouseName) {
      this.spouseName = spouseName;
   }
}
</source>
        <p>In the example above, only when the widget representing property
        <code>married</code> has a value of <code>true</code> it will be
        possible to enter the spouse's name.</p>
      </subsection>
      <subsection name="Controlling visibility">
        <p>It's possible to hide or show widgets conditionally using the
        <code>@VisibleWhen</code> annotation . Its syntax is similar to the one
        for <code>@EnabledWhen</code> and it also may be used to annotate
        attributes and actions. A usage example in an action is shown below:</p>
<source>
/**
 * @Form
 */
public class VisibleWhenFormExample {
   private int dependantNumber;

   public int getDependantNumber() {
      return dependantNumber;
   }

   public void setDependantNumber(int dependantNumber) {
      this.dependantNumber = dependantNumber;
   }

   /**
    * @Action
    * @VisibleWhen dependantNumber > 0
    */
   public void calculateAdditionalTaxes() {
      // ...
   }

   // ...
}
</source>
        <p>The button representing <code>calculateAdditionalTaxes()</code> will
        be visible only when <code>dependantNumber</code> is greater than zero.
        </p>
      </subsection>
      <subsection name="Widget groups">
        <p>In many cases, certain operations need to be executed for a group
        of widgets. An example of this situation is to make a whole group
        visible or enabled - see the Thinlet code below:</p>
<source>
<![CDATA[
...
<label text="Current Date:" font="bold"/>
<panel width="10" height="1" />
<textfield name="currentDate" />
...
]]>
</source>
        <p>In the xml above, the developer intention is to show the field
        "Current Date" under certain conditions. To make this happen, the
        <code>@VisibleWhen</code> annotation is used as the following
        code shows:</p>
<source>
/**
 * @VisibleWhen certainConditions
 */
public Date getCurrentDate() {
   ...
}
</source>
        <p>However, in this case, what happens is that only the
        <code>textfield</code> will become invisible (in case those
        conditions are not satisfied). Notice that the <code>label</code>
        and the <code>panel</code> used for spacing will not become
        invisible - this clearly is not what was originally intented. All three
        controls should follow just the same conditions for visibility.</p>
        <p>To make this occur, we need to use the <code>widgetGoup</code>
        property of the <code>textfield</code> thinlet xml attribute - see
        the following usage:</p>
<source>
<![CDATA[
...
<label name="currentDateLabel" text="Current Date:" font="bold"/>
<panel name="currentDateSpace" width="10" height="1" />
<textfield name="currentDate"
      property="widgetGroup=currentDateLabel,currentDateSpace"/>
...
]]>
</source>
        <p>Notice that the widgets <code>label</code> and <code>panel</code>
        are now named and referred inside the <code>widgetGroup</code>,
        separated by a comma. This way, all three widgets will follow
        the same visibility rule annoted in the <code>form</code> code
        earlier.</p>
        <p>Besides the regular widgetGroup property, there are two more
        specific properties: <code>enabledWidgetGroup</code>
        and <code>visibleWidgetGroup</code>. They define different widget
        groups that will follow enable/disable and visible/invisible rules.
        Those properties will mostly be used because the group of widgets in
        each case is different. For example:</p>
<source>
<![CDATA[
...
<label name="clientLabel" text="Client:" font="bold"/>
<panel name="clientSpace1" width="10" height="1" />
<textfield name="clientCode" ... />
<panel name="clientSpace2" width="10" height="1" />
<textfield name="clientName"
      property="enabledWidgetGroup=clientCode;
            visibleWidgetGroup=clientLabel,clientSpace1,
                               clientCode,clientSpace2"/>
...
]]>
</source>
        <p>This way, enabling/disabling rule will only affect
        <code>clientCode</code> and <code>clientName</code> widgets only.
        On another hand, visibility rule will affect the whole group, including
        the label and all panels for spacing.</p>
      </subsection>
      <subsection name="Clearing field content">
        <p>Under many conditions it is necessary to clean field content. genesis
        can do that automatically for the programmer through the
        <code>@ClearOn</code> annotation. Although its syntax is similar to
        <code>@EnabledWhen</code> and <code>@VisibleWhen</code> one's, this
        annotation may only be used for attributes and not for actions (since
        actions do not have content). A previous example may be modified to be
        more accurate:</p>
<source>
/**
 * @Form
 */
public class ClearOnFormExample {
   private boolean married;
   private String spouseName;

   public boolean isMarried() {
      return married;
   }

   public void setMarried(boolean married) {
      this.married = married;
   }

   /**
    * @EnabledWhen married=true()
    * @ClearOn married=false()
    */
   public String getSpouseName() {
      return spouseName;
   }

   public void setSpouseName(String spouseName) {
      this.spouseName = spouseName;
   }
}
</source>
        <p>When property <code>married</code> is <code>false</code>,
        <code>spouseName</code> will be automatically reset to
        <code>null</code>.</p>
        <p>The value used for resetting is defined by <code>@EmptyValue</code>.
        This annotation should be used for the attribute whose empty value is
        being specified. Its syntax is:</p>
<source>
@EmptyValue valueAsString
</source>
        <p>If <code>@EmptyValue</code> is not specified, a default value is used
        instead - <code>false</code> for booleans, zero for numeric types and
        <code>null</code> otherwise.</p>
        <p>The annotation <code>@ClearOn</code> can be used together with
        <code>@DataProvider</code> annotation. The DataProviders widgets will
        be cleaned and the form properties that store selected values will be
        automatically reset to <code>null</code> when script condition is satisfied.
        See the following usage:</p>
<source>
   /**
    * @DataProvider objectField=state
    * @ClearOn &lt;some script condition&gt;
    */
   public List populateStates() {
      ...
   }
</source>
      </subsection>
      <subsection name="Automatically invoking methods">
        <p>Some methods need to be called every time certain conditions are
        true. Instead of forcing programmers to do that manually - what can lead
        to the so-called "spaghetti" code -, genesis defines the
        <code>@CallWhen</code> annotation. With a syntax similar to previous
        annotations, this one may be only used for actions and not for
        attributes.</p>
        <p>A previous example can be modified to show how to use this annotation
        in practice:</p>
<source>
/**
 * @Form
 */
public class CallWhenFormExample {
   private int dependantNumber;

   public int getDependantNumber() {
      return dependantNumber;
   }

   public void setDependantNumber(int dependantNumber) {
      this.dependantNumber = dependantNumber;
   }

   /**
    * @Action
    * @CallWhen dependantNumber > 0
    */
   public void calculateAdditionalTaxes() {
      // ...
   }
}
</source>
        <p>Differently from the original <code>@VisibleWhen</code> example,
        <code>calculateAdditionalTaxes()</code> will be invoked automatically by
        genesis whenever <code>dependantNumber</code> is greater than zero.</p>
      </subsection>
    </section>
    <section name="Determining if a field is empty">
      <p>In order to perform or not to perform some operations, genesis needs to
      determine whether a field is empty. Besides that, the fact a field is
      filled or not is usually as a way to define a condition for some genesis'
      annotations. Interface <code>EmptyResolver</code>, defined on
      <code>net.java.dev.genesis.resolvers</code> is used for that.</p>
      <p>This interface exposes a single method <code>isEmpty(Object)</code>,
      that returns a <code>boolean</code>. To specify which
      <code>EmptyResolver</code> to use for a certain attribute,
      annotation <code>@EmptyResolver</code> can be used. Its syntax is:</p>
<source>
@EmptyResolver &lt;fullQualifiedNameForClassImplementingEmptyResolver&gt;
               &lt;attributes&gt;
</source>
      <p>It is not necessary to actually insert a line break when defining the
      annotation; it's ok to separate class name from attributes with a space.
      </p>
      <p>In order to avoid being required to specify which
      <code>EmptyResolver</code> implementation should be used for every
      attribute in each form in an application, genesis has a mechanism for
      determining which implementation to use based on the type of an attribute.
      Class <code>EmptyResolverRegistry</code> keeps a registry of default
      <code>EmptyResolver</code> implementations per class. The following
      implementations are initially set up:</p>
      <ul>
        <li><code>MapEmptyResolver</code> is registered for
        <code>java.util.Map</code> instances. It considers as empty null
        instances or the ones that return <code>true</code> for
        <code>isEmpty()</code>.</li>
        <li><code>CollectionEmptyResolver</code> is the default implementation
        for <code>java.util.Collection</code>. It uses the same principle that
        <code>MapEmptyResolver</code> does in order to determine whether an
        instance is empty or not.</li>
        <li>The default implementation for <code>String</code> is
        <code>StringEmptyResolver</code>. Instances considered empty are the
        ones that are null or that have a zero length after spaces are removed,
        i.e., <code>s == null || s.trim().length() == 0</code>.</li>
        <li>For remaining cases, a <code>DefaultEmptyResolver</code> instance is
        registered. This implementation considers as empty null instances or
        zero-element arrays.</li>
      </ul>
      <p>These default implementations should be satisfactory for most cases. As
      an example of how customization might be done, let's consider how to use
      the annotation in a form attribute for which empty spaces are actually
      relevant:</p>
<source>
/**
 * @EmptyResolver trim=false
 */
public String getAttribute() {
   return attribute;
}
</source>
      <p>Since <code>String</code> already has a registered default
      <code>EmptyResolver</code> instance, <code>StringEmptyResolver</code>, and
      this implementation exposes an attribute that allows one to configure
      whether spaces should be removed or not, it's not necessary to specify the
      name of the interface implementation class and it's enough to define
      property <code>trim</code> as <code>false</code>. If it wasn't possible to
      configure the default instance, another implementation could be used
      instead as following:</p>
<source>
/**
 * @EmptyResolver com.company.package.EmptyResolverImplementation
 */
public String getAttribute() {
   return attribute;
}
</source>
      <subsection name="Verifying if a field is empty in conditional
      expressions">
        <p>As already mentioned, it's very common to determine conditions that
        are based on the fact a field is empty or not. genesis exposes script
        auxiliary functions that may be used in conditions in order to make this
        task easier: <code>isEmpty(any)</code> and
        <code>isNotEmpty(any)</code>
        (<a href="quick_reference.html#genesis_scripting_auxiliary_functions">more info...</a>).
        </p>
        <p>When the argument is a form property, the <code>EmptyResolver</code>
        instance configured for it - determined as explained above - is used to
        determine the return value. If the argument is a variable or a constant,
        a default <code>EmptyResolver</code> instance for the expression type is
        obtained from <code>EmptyResolverRegistry</code> and used for
        evaluation. These functions may be used with 
        <a href="generic_scripting.html">JXPath</a> as shown below:</p>
<source>
public String getAttribute() {
   return attribute;
}

public void setAttribute(String attribute) {
   this.attribute = attribute;
}

/**
 * @EnabledWhen g:isNotEmpty(attribute)
 */
public String getDependantAttribute() {
   return dependantAttribute;
}

public void setDependantAttribute(String dependantAttribute) {
   this.dependantAttribute = dependantAttribute;
}
</source>
      </subsection>
    </section>
    <section name="Comparing values">
      <p>Both the framework and developers need sometimes to check if a field
      value has been changed or if its value is equal to some constant or
      another field value. Interface <code>EqualityComparator</code> contained
      in <code>net.java.dev.genesis.equality</code> is implemented by classes
      that are capable of making this decision.</p>
      <p>This interface defines <code>equals(Object,Object)</code> that returns
      a <code>boolean</code> indicating whether compared instances are equals or
      not. The annotation with the same name, <code>@EqualityComparator</code>
      may be used to explicitly define the implementation used for a certain
      attribute. Its syntax is similar to <code>@EmptyResolver</code>'s one:</p>
<source>
@EqualityComparator &lt;fullQualifiedNameForClassImplementingEmptyResolver&gt;
                    &lt;attributes&gt;
</source>
      <p>Usually it won't be necessary to use this annotation since genesis also
      has a default mechanism for determining which interface implementation
      should be used for a given attribute. The class / implementation map is
      kept by <code>EqualityComparatorRegistry</code>. Default registered
      implementations are:</p>
      <ul>
        <li><code>BigDecimalEqualityComparator</code> considers two
        <code>java.math.BigDecimal</code> instances equals if both are null or
        if <code>compareTo(BigDecimal)</code>'s return for one of them is zero.
        </li>
        <li><code>StringEqualityComparator</code> considers null or zero-length
        trimmed<code>String</code>s equals. They'll also be considered equals if
        <code>s1.trim().equals(s2.trim())</code>.</li>
        <li>Remaining cases are handled by <code>DefaultEqualityComparator</code
        >, that considers two instances to be equals if both are null or if
        <code>o1.equals(o2)</code> returns true.</li>
      </ul>
      <subsection name="Verifying field value changes and doing comparisson in
          conditional expressions">
        <p>Some script functions are exported by genesis in order to help
        developers in common tasks:</p>
        <ul>
          <li><code>hasChanged(property)</code> and
          <code>hasNotChanged(property)</code> verify whether a field value
          has changed or not.</li>
          <li><code>equals(any,any)</code> and
          <code>notEquals(any,any)</code> compare two values - that may be
          constants, form properties or variables - and return the comparisson
          result.</li>
        </ul>
        <p>genesis internally keeps control of fields that have their value
        changed in the current iteraction. This list is checked by functions
        <code>hasChanged(propriedade)</code> and
        <code>hasNotChanged(propriedade)</code>. To determine whether a value
        has been changed or not and to populate this internal list, the
        framework uses the <code>EqualityComparator</code> instance configured
        for the property.</p>
        <p>Functions <code>equals(any,any)</code> and
        <code>notEquals(any,any)</code> also make use of
        <code>EqualityComparator</code> instances to determine their output.
        However, the actual process used for that is a bit more complicated, as
        explained below:</p>
        <ul>
          <li>An instance of <code>EqualityComparator</code> for each parameter
          is determined. If the parameter is a form property, its configured
          implementation will be used. Otherwise, the default implementation
          registered in <code>EqualityComparatorRegistry</code> will be picked
          up.</li>
          <li>If comparators for both parameters are the same, the first one of
          them will be used to do the comparisson.</li>
          <li>If the first parameter type is an instance of the second parameter
          type, its <code>EqualityComparator</code> instance will be used for
          performing the comparisson.</li>
          <li>If the second parameter type is an instance of the second
          parameter type, its <code>EqualityComparator</code> instance will be
          used for performing the comparisson.</li>
          <li>If none of the above conditions is true, <code>false</code> will
          be returned.</li>
        </ul>
        <p>There are examples (using <a href="generic_scripting.html">JXPath</a>)
        of how to use each function pair below:</p>
<source>
public BigDecimal getTax() {
   return tax;
}

public void setTax(BigDecimal tax) {
   this.taxa = tax;
}

/**
 * @Action
 * @CallWhen g:hasChanged(tax)
 */
public void recalculateValues() {
   // logic for recalculating
}
</source>
<source>
public BigDecimal getDebt() {
   return debt;
}

public void setDebt(BigDecimal debt) {
   this.debt = debt;
}

public BigDecimal getPaidAmount() {
   return paidAmount;
}

public void setPaidAmount(BigDecimal paidAmount) {
   this.paidAmount = paidAmount;
}

/**
 * @Action
 * @CallWhen g:notEquals(debt,paidAmount)
 */
public void calculateRemainingAmount() {
   // logic for calculating amount
}
</source>
      </subsection>
      <subsection name="Changing the way values are cloned">
         <p>In previous releases, old property values were merely copied as 
         part of form state, what implied in some limitations on how change 
         detecction worked. For example, if the value of a property was a 
         JavaBean and one of its properties was changed, it was not possible to
         detect this change by using <code>g:hasChanged(property)</code>, 
         since both the previous state copy that genesis hold and the current 
         value would point to the same instance in memory.</p>
         <p>Starting from release 2.3, a new API has been introduced that allows
         to control how genesis generates a copy of the previous value of a 
         property. The <code>net.java.dev.genesis.cloning.Cloner</code> 
         interface has a single <code>clone(Object)</code> method that returns 
         the value genesis is suposed to keep as a copy of the value used as an
         argument to the call. The default implementation of that interface - 
         provided by <code>net.java.dev.genesis.cloning.DefaultCloner</code> - 
         simply returns the value used as a parameter, preserving backwards 
         compatibility.</p>
         <p>Similar to <code>EqualityComparator</code>, there is a registry that
         associates <code>Cloner</code> implementations with the class used in
         the property, <code>net.java.dev.genesis.cloning.ClonerRegistry</code>, 
         as well as an annotation that allows the <code>Cloner</code> 
         implementation to be used to be overridden on a property basis, 
         <code>@Cloner</code>.</p>
         <p>The following code shows how to override the <code>Cloner</code> 
         implementation that is going to be used both globally and for a 
         specific bean property:</p>
<source>
ClonerRegistry.getInstance().register(User.class, new BeanUtilsCloner());
</source>
<source>
/**
 * @Form
 */
public class ClonerFormExample {
   /**
    * @Cloner net.java.dev.genesis.cloning.BeanUtilsCloner
    */
   public User getUser() {
      // ...
   }
   
   // ...
}
</source>
         <p>The class used in both examples above,  
         <code>net.java.dev.genesis.cloning.BeanUtilsCloner</code>, is the other 
         implementation provided by genesis that clones the value using the 
         Commons BeanUtils API.</p>
      </subsection>
    </section>
    <section name="Populating comboboxes, lists and tables">
      <p>Options available in a combobox may vary depending on data inputted by
      the user or other business rules. A table's content may need to be
      dynamically filled in response to a user-specified filter criteria, for
      example. To cope with these situations, there is an annotation called
      <code>@DataProvider</code>, whose syntax is:</p>
<source>
@DataProvider &lt;objectField=nameObjectField&gt;
              &lt;indexField=nameIndexField&gt;
              &lt;widgetName=nameObjectField&gt;
              &lt;callOnInit=booleanValue&gt;
              &lt;resetSelection=booleanValue&gt;
</source>
      <p>This annotation may be used in methods returning either a
      <code>java.util.List</code> or an array of <code>Object</code>s. Values
      returned by the method will be used to populate a combobox, list or table.
      <code>objectField</code>, if specified, should receive as a parameter the
      name of a property that will hold the instance selected on the widget.
      This property should be of the same type or a superclass of the type
      returned by the annotated method, an array of this type or a
      <code>Collection</code>. <code>indexField</code> is the property that
      will hold indexes for the selected elements on the widget. It must be an
      <code>int</code> or an <code>Integer</code>, an array of one of these
      types or a <code>Collection</code>.
      In case <code>widgetName</code> is used, its value must be the name of a
      widget defined in the view xml file. This widget will be the one to receive
      the data provided by the annotated method.
      <b>At least one of these three parameters must be
      informed</b>.</p>
      <p>The widget <code>name</code> is equal to the value specified for
      <code>widgetName</code>, <code>objectField</code> or <code>indexField</code>
      in that order.</p>
      <p>As mentioned earlier, both <code>objectField</code> and
      <code>indexField</code> receive as parameter the name of a property that
      might be a bean, an array or a <code>Collection</code>. Let's
      examine when to use each type:</p>
      <table>
        <tr>
          <th>Return type and Usage</th>
          <th>objectField</th>
          <th>indexField</th>
        </tr>
        <tr>
          <td>Bean: always used with comboboxes or lists/tables with single
          selection mode</td>
          <td>Any Java class (cannot be a primitive type)</td>
          <td><code>Integer</code> or <code>int</code></td>
        </tr>
        <tr>
          <td><code>Collection</code> or array: used for lists/tables with
          multiple selection enabled</td>
          <td>Array of any Java class (cannot be of a primitive type) or
          <code>Collection</code> of any Java class</td>
          <td>Array of <code>Integer</code>s or of <code>int</code>s or
          <code>Collection</code> of <code>Integer</code>s</td>
        </tr>
      </table>
      <p>An example of how to use this annotation is shown below:</p>
<source>
<![CDATA[
<panel gap="5">
   <label text="State:" />
   <combobox name="state" property="key=acronym;value=description" />
</panel>
]]>
</source>
<source>
public class State {
   private String acronym;
   private String description;

   // getters and setters for properties
}
</source>
<source>
/**
 * @Form
 */
public class DataProviderFormExample {
   private State state;

   public State getState() {
      return state;
   }

   public void setState(State state) {
      this.state = state;
   }

   /**
    * @DataProvider objectField=state
    */
   public List populateStates() {
      // returns a Collection containing State instances
   }

   // ...
}
</source>
      <p>In the first block we can see the interface xml that displays a
      <code>label</code> and a <code>combobox</code> that will hold states in
      runtime. The combobox <code>name</code> property is equal to the value for
      <code>objectField</code> in annotation <code>@DataProvider</code> from the
      third block. A few values are configured for combobox <code>property</code
      >. The following values may be used for this kind of widget:</p>
      <ul>
        <li><b>key</b>: name of the property bean that will be used for
        populating the component, whose value is unique per instance.Always
        required.</li>
        <li><b>value</b>: name of the property used for displaying the bean. It
        is required when the bean is not a subclass of
        <code>net.java.dev.reusablecomponents.lang.Enum</code>.</li>
        <li><b>blank</b>: includes a blank line as the first combobox option.
        It's not required and its default value is <code>false</code>.</li>
        <li><b>blankLabel</b>: defines the text to be displayed for the blank
        line. It's not required, its default value is an empty
        <code>String</code> and it's only meaningful when
        <code>blank=true</code>.</li>
      </ul>
      <p>As indicated by <code>objectField</code> value, property
      <code>state</code> will contain the selected <code>State</code> instance
      that corresponds to the combox option choosen by the user.</p>
      <p>Working with <code>lists</code> is quite similar to
      <code>comboboxes</code>, as shown in the below example:</p>
<source>
<![CDATA[
<panel gap="5">
   <label text="State:" />
   <list name="state" property="key=acronym;value=description" />
</panel>
]]>
</source>
      <p>Requirements for populating a table are slightly different. To display
      the states of the previous example in a table, the interface xml could be
      like:</p>
<source>
<![CDATA[
<panel gap="5">
   <table name="state">
      <header>
         <column name="acronym" text="Acronym" />
         <column name="description" text="Description" />
      </header>
   </table>
</panel>
]]>
</source>
      <p>As shown above, we can observe that table <code>name</code> must be
      equal to <code>objectField</code> value. Each row will represent an
      instance and each column will be filled with a bean property whose name is
      their <code>name</code>.</p>
      <p>There is a variation for this annotation which happens with the use
      of the <code>callOnInit</code> property. Imagine the above
      <code>combobox</code> or the <code>table</code> widgets <b> are not
      supposed</b> to be filled at the dialog startup. In this case, to
      accomplish this requirement in a easier way, we only have to rewrite
      the annotation as the following code indicates:</p>
<source>
   // ...

   /**
    * @DataProvider objectField=state callOnInit=false
    */
   public List populateStates() {
      // returns a Collection containing State instances
   }

   // ...
</source>
      <p>This way, at dialog startup, the <code>combobox</code>
      or <code>list</code> or
      <code>table</code> widgets will be empty. In order to populate them
      a <code>@CallWhen</code> annotation can be added and used together.
      That is, <code>@CallWhen</code> annotation may be used together with
      <code>@DataProvider</code> to indicate when a table/list/combo will be
      automatically populate again. <code>@Action</code> may also be used in
      these methods if they need to be triggered by a button (such as Search,
      for example) and, when that is true, using <code>@EnabledWhen</code> and
      <code>@VisibleWhen</code> is also allowed.</p>
      <p><code>resetSelection</code> determines whether selected elements will
      be unselected when the method is invoked. This is the default behaviour,
      i.e., if this property has no value, it is considered <code>false</code>.
      When the value informed is <code>true</code>, the selection is kept
      relative to the <b>position</b> of the itens, what makes this feature
      more useful when something is being added to the end of the
      <code>java.util.List</code> instance or array each time the method gets
      executed.</p>
      <subsection name="Invoking actions within a form">
        <p>In order to have a form re-populated with the data returned by
        a <code>@DataProvider</code> annotated method, genesis must be aware of
        its execution. This can be done by calling
        <code>invokeFormAction(...)</code> as described
        <a href="ui_basic_concepts.html#Implementing_actions_in_forms_and_views">
        here</a>.</p>
        <p>Another way to do this within the form (without the use of a view)
        is to use the <code>ActionInvoker</code> and <code>BaseForm</code>
        classes.</p>
        <p>The <code>ActionInvoker</code> class has two static methods:
        <ul>
          <li><code>invoke(form, actionName)</code>: executes an action
          from the given form.</li>
          <li><code>refresh(form)</code>: updates the information being
          displayed by the given form instance.</li>
        </ul>
        </p>
        <p>The <code>BaseForm</code> class might be used as a parent class of
        forms. It defines two similar methods:
        <ul>
          <li><code>invoke(actionName)</code>: executes an action in the
          current form instance.</li>
          <li><code>refresh()</code>: updates the information being
          displayed by the current form instance.</li>
        </ul>
        To be more specific, these methods are shortcuts to the methods defined
        in <code>ActionInvoker</code>. However, extending <code>BaseForm</code>
        limits form inheritance possibilities and may not be suitable.</p>
        <p>Although using these classes makes the form more self-contained,
        it will make code more strongly coupled to genesis.</p>
        <p>Reusing the same logic from
        <a href="ui_basic_concepts.html#Implementing_actions_in_forms_and_views">
        <code>invokeFormAction(...)</code></a> example and rewriting it to use
        <code>ActionInvoker</code>, we'll have:</p>
<source>
/**
 * @Form
 */
public class InvokeFormActionFormExample {
   private BigDecimal index;
   // ...

   public BigDecimal getIndex() {
      return index;
   }

   public void setIndex(BigDecimal index) {
      this.index = index;
      ActionInvoker.invoke(this, "recalculateTotals");
   }

   /**
    * @DataProvider objectField=totals
    */
   public void recalculateTotals() {
      // business logic to manipulate several other properties
   }
}
</source>
<source>
/**
 * @Form
 */
public class InvokeFormActionFormExample extends BaseForm {
   private BigDecimal index;
   // ...

   public BigDecimal getIndex() {
      return index;
   }

   public void setIndex(BigDecimal index) {
      this.index = index;
      invoke("recalculateTotals");
   }

   /**
    * @DataProvider objectField=totals
    */
   public void recalculateTotals() {
      // business logic to manipulate several other properties
   }
}
</source>
      </subsection>
    </section>
    <section name="Formatting">
      <p>Since formatting information so it can be displayed on the screen is a
      very important part of any graphic application, it's expected doing so is
      easy and also configurable. The API used for this purpose on genesis is
      implemented in <code>net.java.dev.genesis.text</code>.</p>
      <p>In this package resides an interface called <code>Formatter</code>,
      that defines a <code>format(Object)</code> method. This methods converts
      its argument to a formatted String. Similarly to what happens to other
      common framework components, there's a registry of default interface
      implementations per class, the <code>FormatterRegistry</code> class. The
      following implementations are initially registered in this class:</p>
      <ul>
        <li><code>EnumFormatter</code> converts
        <code>net.java.dev.reusablecomponents.lang.Enum</code> instances by
        looking up in the
        <a href="#Configuring messages"><code>ResourceBundle</code></a> the
        message configured by a key formed by class name without package + '.' +
        constant name. If this message is not found, a message will be logged as
        INFO and the instance converted by using <code>toString()</code>.</li>
        <li><code>DefaultFormatter</code> is registered for all remaining types
        and converts instances using <code>toString()</code> - except when they
        are <code>null</code>, when it returns a zero-length String.</li>
      </ul>
      <p>To register a new formatter for a class the method
      <code>register(Class,Formatter)</code> from <code>FormatterRegistry</code>
      may be used.</p>
      <p>However, the ability of registering a formatter instance per class
      may not be enough for some situations. For example, when a
      <code>boolean</code> property is displayed as text, it may be necessary
      to display a custom text instead of the <code>true</code> and
      <code>false</code> constants. genesis has an API that allows a specific
      formatter instance to be used to display a field. Some steps are required
      to use this feature:</p>
      <ol>
        <li>Instead of calling some version of the <code>bind(..)</code>
        method, a <code>ThinletBinder</code> instance should be prepared by
        calling either <code>prepareBinder(form)</code> or
        <code>prepareBinder(widget,form)</code>, both methods defined in
        <code>net.java.dev.genesis.ui.thinlet.BaseThinlet</code>.</li>
        <li>The formatter instance can be registered using the
        <code>registerFormatter(String,Formatter)</code> method specified by
        <code>net.java.dev.genesis.ui.thinlet.ThinletBinder</code>. The
        <code>String</code> argument value should be the name of the property
        whose formatter will be overridden. The property name should be:
          <ul>
            <li>If it is a simple property, returned by a getter method, it is
            a simple property name.</li>
            <li>If the formatter instance should be used for combobox or list
            items or for a column in a table, the property name should be
            composed as
            <code>widgetName.nameOfThePropertyOfTheObjectBeingDisplayed</code>.
            </li>
          </ul>
        </li>
        <li>Optionally, if the property whose formatter has been overridden
        needs to be converted by genesis to its original type and the custom
        generated format is not supported by the default converter, the
        converter must be overriden by calling the
        <code>registerConverter(String,Converter)</code> method.
        <code>org.apache.commons.beanutils.Converter</code> is part of
        Jakarta Commons BeanUtils. Please refer to this framework documentation
        if this interface must be overridden.</li>
        <li>Finally, the binding should be manually performed by calling the
        <code>bind()</code> method.</li>
      </ol>
      <p>A short example of these steps can be seen below:</p>
<source>
ThinletBinder binder = prepareBinder(form);
binder.registerFormatter("property", new Formatter() {
   public String format(Object o) {
      return "Custom format";
   }
});
binder.bind();
</source>
      <p>The value of <code>property</code> to be displayed on the screen
      will be the <code>Custom format</code> constant, no matter what its
      value on the form is.</p>
      <subsection name="Virtual properties">
        <p>Since release 2.2, it is possible to work with virtual properties,
        i.e., properties that don't exist in the object being displayed. These
        properties have their display value determined by a specific formatter,
        that must be registered in the <code>ThinletBinder</code> instance.</p>
        <p>The process for defining and displaying a virtual property is
        basically the same of a regular property, except for the following
        things:</p>
        <ul>
           <li>Only table cells and values displayed in comboboxes or lists can
           be virtual properties.</li>
           <li>Virtual properties can be defined for comboboxes and lists by
           adding to the <code>property</code> element in the xml definition a
           <code>virtual=true</code> token. Since table columns do not have
           a <code>property</code> attribute, the value of its attribute
           <code>name</code> must be prefixed with <code>virtual:</code>
           .</li>
           <li>The <code>Formatter</code> instance will receive the whole bean
           being displayed as a parameter to the <code>format(Object)</code>,
           since the property being displayed does not actually exist in the
           instance.</li>
        </ul>
        <p>An example of how to define and use a virtual property is shown
        below, both for comboboxes and tables:</p>
<source>
<![CDATA[
<panel gap="5">
   <combobox name="widget"
             property="key=uniqueProperty;value=virtualValue;virtual=true" />
</panel>
]]>
</source>
<source>
<![CDATA[
<panel gap="5">
   <table name="widget">
      <header>
         <column name="uniqueProperty" text="#" />
         <column name="virtual:virtualValue" text="Virtual" />
      </header>
   </table>
</panel>
]]>
</source>
<source>
ThinletBinder binder = prepareBinder(form);
binder.registerFormatter("widget.virtualValue", new Formatter() {
   public String format(Object o) {
      return o == null ? "0" : String.valueOf(o.hashCode());
   }
});
binder.bind();
</source>
        <p>It is important to notice that although the name of the column is
        prefixed with <code>virtual:</code>, this does not affect how the
        property name is composed for registering the formatter.</p>
      </subsection>
    </section>
    <section name="Customizing how components are created">
      <p>Starting from release 2.3, it is possible to customize how componentes
      are created by using the 
      <code>net.java.dev.genesis.ui.thinlet.WidgetFactory</code> interface and 
      its related support classes. It is possible to do so based on either the
      class of the data for which the widget will be created or for a specific
      widget.</p>
      <p>For instance, in order to make both table cells and list and comboboxes 
      itens right-aligned when their content is a <code>java.lang.Number</code>
      class, an instance of <code>WidgetFactory</code> should be registered in
      <code>net.java.dev.genesis.ui.thinlet.WidgetFactoryRegistry</code> 
      before any code that creates widgets is executed. This can be done as 
      shown below:</p>
<source>
public class NumberWidgetFactory extends DefaultWidgetFactory {
   public Object create(BaseThinlet thinlet, String name, String value,
         Object bean, BaseThinlet.ItemType type) {
      Object widget = super.create(thinlet, name, value, bean, type);
      Thinlet.setChoice(widget, BaseThinlet.ALIGNMENT, BaseThinlet.RIGHT);
      return widget;
   }
}
</source>
<source>
// Code for registering the instance, probably at the main(String[]) method
WidgetFactoryRegistry.getInstance().register(Number.class, new NumberWidgetFactory());
</source>
      <p>As shown above, most implementations of <code>WidgetFactory</code> will
      extend <code>DefaultWidgetFactory</code>, a class that implements the 
      basic behaviour used by genesis. The arguments used as parameters for 
      invoking the
      <code>create(BaseThinlet, String, String, Object, BaseThinlet.ItemType)</code>
      method are, in order:</p>
      <ul>
         <li><b>thinlet</b>: the instance of the <code>BaseThinlet</code> 
         subclass the widget will be added to.</li>
         <li><b>name</b>: property value to be used as the component name. It 
         might be ignored, but that is usually not advisable.</li>
         <li><b>value</b>: the text value to be used in the component. It 
         might be ignored, but that is usually not advisable.</li>
         <li><b>property</b>: the property that has been formatted to produce 
         the <code>value</code> argument. It might be useful in some specific 
         cases, such as when creating a tooltip based on another property of a
         bean.</li>
         <li><b>type</b>: the type of the widget to be created, according to the
         enum <code>BaseThinlet.ItemType</code>.</li>
      </ul>
      <p>In order to use an instance of <code>WidgetFactory</code> to create 
      some specific widget, it should be registered in the 
      <code>ThinletBinder</code> instance by invoking the 
      <code>registerWidgetFactory(String,WidgetFactory)</code> method, using the
      same naming rule explained in the <a href="#Formatting">Formatting</a> 
      section, as shown below:</p>
<source>
<![CDATA[
<panel gap="5">
   <table name="widget">
      <header>
         <column name="regularProperty" text="Regular" />
         <column name="specificProperty" text="Specific" />
      </header>
   </table>
</panel>
]]>
</source>
<source>
ThinletBinder binder = prepareBinder(form);
binder.registerFormatter("widget.specificProperty", new NumberWidgetFactory());
binder.bind();
</source>
    </section>
    <section name="Configuring messages">
      <p>Several messages may be externalized by configuring them in a
      <code>java.util.ResourceBundle</code>. A <code>ResourceBundle</code>
      allows one to keep a name/value property dictionary - similar to a
      <code>Properties</code> instance -, supporting multiple
      <code>java.util.Locale</code> instances. In a simplified way, it is
      possible to configure different messages depending on the language being
      used.</p>
      <p>genesis uses a <code>ResourceBundle</code> named <code>messages</code>,
      what means that a <code>messages.properties</code> file should be
      available on classpath. Class <code>net.java.dev.genesis.ui.UIUtils</code>
      keeps this <code>ResourceBundle</code> instance in runtime.</p>
      <p>In the resource file messages relative to the following things are
      configured:
      </p>
      <ul>
        <li>Validation</li>
        <li>Disply values for <code>Enum</code> constants (in a
        <code>ClassName.CONSTANT=Display value</code> format)</li>
        <li>Messages for the default views provided with genesis, such as the
        one used for <code>OptionDialog</code></li>
        <li>Any user-defined text that need to be externalized</li>
      </ul>
      <p>There is an example of how to configure a <code>ResourceBundle</code>
      from the useradmin sample below:</p>
<source>
# 1. Validation-related configuration
errors.byte=The {0} field is not a byte.
errors.short=The {0} field is not a short.
errors.int=The {0} field is not an integer.
errors.long=The {0} field is not a long.
errors.float=The {0} field is not a float.
errors.double=The {0} field is not a double.
errors.bigdecimal=The {0} field is not a big decimal.
errors.required=The {0} field is required.
errors.requiredif=The {0} field is required.
errors.mask=The {0} field is not valid.
errors.email=The {0} field is not a valid email.
errors.date=The {0} field is not a valid date.
errors.min={0} must be greater or equal to {1}.
errors.max={0} must be lesser or equal to {1}.
errors.minlength=The {0} field can not be less than {1} characters.
errors.maxlength=The {0} field can not be greater than {1} characters.
errors.longRange={0} is not in the range {1} through {2}.
errors.doubleRange={0} is not in the range {1} through {2}.
errors.bigDecimalRange={0} is not in the range {1} through {2}.
errors.jxpath=The {0} field is not valid.
validation.errors.title=Validation errors

# 2. Messages for default views
MessageDialog.close=Close
Option.YES=Yes
Option.NO=No
Option.CANCEL=Cancel
ErrorReporterDialog.ok=OK
ErrorReporterDialog.stackTrace=Stack Trace:

# 3. Used defined configurations
InsertRoleView.title=Insert Role
InsertView.title=Insert User
UpdateView.title=Update User
RoleListView.title=Role List
UserListView.title=Users Administration

button.ok=Ok
button.add=Add
button.remove=Remove
button.cancel=Cancel
button.save=Save
button.search=Search
button.reset=Reset
button.newUser=New User
button.updateUser=Update User
button.removeUser=Remove User

User.name=Name
User.login=Login
User.password=Password
User.email=e-mail
User.birthday=Birthday
User.address=Address
User.country=Country
User.state=State
User.role=Role

Role.label=Label
Role.code=Code
</source>
      <p>For more information on how to work with resource files, see the
      Javadoc for class <code>java.util.ResourceBundle</code>.</p>
    </section>
    <section name="Working with dynamic searches">
      <p>genesis makes it easy to build dynamic searches - those in which
      selection criteria change in runtime, not just values for them -
      integrating this feature both in UI components and business components.</p
      >
      <p>On the client-side, in order to use only filled properties in the
      search, one just has to do:</p>
<source>
CriteriaPropertyHelper.fillCriteria(hibernateCriteria, form);
</source>
      <p>Classe <code>CriteriaPropertyHelper</code> is located at package
      <code>net.java.dev.genesis.helpers</code>. <code>hibernateCriteria</code>
      needs to be compliant with the <a href=
      "business_component_model.html#Dynamic criteria searching">requirements
      for dynamic searching with business components</a> while <code>form</code>
      must be a valid genesis form. Only properties that exist in both beans and
      that are filled according the
      <a href="#Determining if a field is empty">rules for determing if a field
      is empty</a>. A call to
      <code>fillCriteria(HibernateCriteria, Object)</code> must be done before
      calling the method annotated with <code>@Criteria</code>.</p>
      <p>To make it even simpler to buld dynamic searches with paged results, two
      helper classes are defined in package
      <code>net.java.dev.genesis.ui.paging</code>: <code>BaseSearchForm</code>
      and <code>BaseCriteriaSearchForm</code>. These abstract classes can be
      extended by forms, minimizing implementation efforts.</p>
      <p><code>BaseSearchForm</code> contains paging-related logic, besides
      abstracting how the query is actually performed. Some of its actions and
      properties may be directly used to assemble the UI:</p>
      <ul>
        <li><code>previousPage()</code> and <code>nextPage()</code> are genesis
        actions that can be bound to buttons that will perform navigation through
        the results. They have <code>@VisibleWhen</code> annotations that will
        hide the widgets whenever it is appropriate.</li>
        <li><code>pageNumber</code> is a property that contains the number of
        current page.</li>
      </ul>
      <p>This class also defines the abstract <code>performSearch()</code>
      method, that returns a <code>net.java.dev.genesis.paging.Page</code>
      instance, and exposes the <code>runSearch</code> property, that is
      supposed to be used to define the conditional expression for performing
      the search in subclasses. Most of the times it won't be necessary to use
      it directly, since <code>BaseCriteriaSearchForm</code> provides a higher
      abstraction level when the search is performed by a
      <code>HibernateCriteria</code> implementation. In this case, it will only
      be necessary to implement a couple of methods:
      <code>getHibernateCriteria()</code>, that should return the business
      object that will receive the criteria by calling
      <code>CriteriaPropertyHelper</code> and
      <code>performSearch(int pageNumber)</code>. Below there is an example of
      how to use this class extracted from the useradmin sample. First, let's
      see the relevant code snippet for the form:</p>
<source>
/**
 * @Form
 */
public class UserListForm extends BaseCriteriaSearchForm {
   private final UserSearchCommand command = new UserSearchCommand();

   // getters and setters for search criteria omitted

   public List getUsers() { /* ... */ }

   public void setUsers(List users) { /* ... */ }

   protected HibernateCriteria getHibernateCriteria() {
      return command;
   }

   protected Page performSearch(int pageNumber) throws Exception {
      return command.getUsers(pageNumber);
   }

   /**
    * @Action
    * @CallWhen runSearch=true()
    * @DataProvider objectField=users callOnInit=false
    */
   public List doSearch() throws Exception {
      search();

      return getPage().getResults();
   }

   // more code
</source>
      <p>And now, how to use the built-in actions for the navigation buttons, as
      defined in the UI xml file:</p>
<source>
<![CDATA[
<button name="previousPage" text="<<" font="bold" type="default" alignment="left"/>
<button name="nextPage" text=">>" font="bold" type="default" alignment="right"/>
]]>
</source>
    </section>
  </body>
</document>
