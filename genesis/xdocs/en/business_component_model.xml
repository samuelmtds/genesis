<?xml version="1.0" encoding="ISO-8859-1"?>
<document>
  <properties>
    <title>Business component model</title>
    <author email="mister__m@dev.java.net">Michael Nascimento Santos</author>
  </properties>
  <body>
    <section name="Business component model">
      <p>genesis' business component model is quite simple to understand. The
      following concepts and/or characteristics will be explained bellow:
        <ul>
          <li><a href="#Use of business classes at client-side">Use of business
          classes at client-side</a></li>
          <li><a href="#Transparent remoting">Transparent remoting</a></li>
          <li><a href="#Transaction support">Transaction support</a></li>
          <li><a href="#Hibernate integration">Hibernate integration</a></li>
          <li><a href="#Paging">Paging</a></li>
          <li><a href="#Dynamic criteria searching">Dynamic criteria searching
          </a></li>
        </ul>
      </p>
    </section>
    <section name="Use of business classes at client-side">
      <p>The use of genesis' business classes doesn't have any restriction. This
      means:
        <ul>
          <li>There is no need to create an interface for a business class. Other
          object-oriented best practices could lead to this - but the framework
          doesn't force anyone to do so.</li>
          <li>In order to build an object instance, one can use
          the <code>new</code> operator or any other Java resource 
          (e.g. a Factory or the reflection API).</li>
          <li>There is no need to tell the framework that some instance should
          be managed by it. Currently the only required configuration is the
          aspects configuration that is done in <code>aop.xml</code>. This
          configuration can be copied from the samples and if some changes are
          required, they will be done only once.</li>
        </ul>
      </p>
    </section>
    <section name="Transparent remoting">
      <p>Suppose there is a class called <code>SumExample</code> as below:</p>
<source>
 1. public class SumExample {
 2.    public int sum(int a, int b) {
 3.       System.out.println("a = " + a);
 4.       System.out.println("b = " + b);
 5.
 6.       int sum = a + b;
 7.
 8.       System.out.println("a + b = " + sum);
 9.
10.       return sum;
11.    }
12.
13.    public static void main(String[] args) {
14.       System.out.println(new SumExample().sum(2, 2));
15.    }
16. }
</source>
      <p>By running the code, the following output will be printed at the local
      standard output:</p>
<source>
a = 2
b = 2
a + b = 4
4
</source>
      <p>The <code>sum(int, int)</code> method can be turned to a remote one by
      simply adding a <code>@Remotable</code> annotation. The modified code
      would be:</p>
<source>
 1. public class RemoteSumExample {
 2.    /**
 3.     * @Remotable
 4.     */
 5.    public int sum(int a, int b) {
 6.       System.out.println("a = " + a);
 7.       System.out.println("b = " + b);
 8.
 9.       int soma = a + b;
10.
11.       System.out.println("a + b = " + sum);
12.
13.       return sum;
14.    }
15.
16.    public static void main(String[] args) {
17.       System.out.println(new RemoteSumExample().sum(2, 2));
18.    }
19. }
</source>
      <p>Running the new code inside a JBoss Application Server, we notice a
      decrease in the output lines:</p>
<source>
4
</source>
      <p>By watching the JBoss console, one will notice that some messages
      were printed at the server-side. Why is that?</p>
      <p>The output seen at the local console is due to the execution of 17th
      line. However, other <code>System.out.println</code> calls from the 6th, 7th
      and 11th lines took place inside an annotated method with
      <code>@Remotable</code> and that's why they were executed in a different
      way. Actually the whole <code>sum(int,int)</code> method was executed
      at the server-side. How?</p>
      <p>Annotated methods with the <code>@Remotable</code> tag will be
      intercepted by an aspect (genesis-aspect) that will send the instance in
      which the method was called to the server-side, and then this method will
      be executed there. The result will be sent back to the client-side.
      This characteristic is called <b>transparent remoting</b>.</p>
      <subsection name="Restrictions and limitations">
        <p>There are some restrictions on the methods that can be remotable
        in genesis:
          <ul>
            <li>It cannot be abstract</li>
            <li>It cannot be a static method nor manipulate static members</li>
            <li>It cannot be native</li>
            <li>It must be <code>public</code> and be inside a
            <code>public</code> class</li>
          </ul>
        </p>
        <p>The first restriction exists because an abstract method cannot be called
        (however it might be abstract in a superclass). The method cannot be
        static because static values differ between different JVMs. The last
        two restrictions are for EJB specification compliance.</p>
        <p>A last side effect to be noted is that 
        remote methods do not change the value of local instances variables. 
        We can see an example of this:</p>
<source>
 1. public class LocalVersusRemote {
 2.    private int value;
 3.
 4.    public void local() {
 5.       value++;
 6.       System.out.println("value in local(): " + value);
 7.    }
 8.
 9.    /**
10.     * @Remotable
11.     */
12.    public void remote() {
13.       value++;
14.       System.out.println("value in remote(): " + value);
15.    }
16.
17.    public int getValue() {
18.       return value;
19.    }
20.
21.    public static void main(String[] args) {
22.       LocalVersusRemote lvr = new LocalVersusRemote();
23.       lvr.local();
24.       System.out.println("value: " + lvr.getValue());
25.       lvr.remote();
26.       System.out.println("value: " + lvr.getValue());
27.       lvr.local();
28.       System.out.println("value: " + lvr.getValue());
29.    }
30. }
</source>
        <p>The local output will be:</p>
<source>
value in local(): 1
value: 1
value: 1
value in local(): 2
value: 2
</source>
        <p>While the remote output will be:</p>
<source>
value in remote(): 2
</source>
        <p>By running the 23rd line, the <code>value</code> variable is locally
        modified and its content are both in <code>local()</code> method and
        in 24th line output the same. However, by running the 25th line, the
        <code>lvr</code> instance is sent to the server and the
        <code>remote()</code> method is executed there, modifying the remote
        copy of <code>value</code> from 1 to 2, as shown at the remote console
         - but the local copy is kept unmodified as we can see with the 26th
        line output (local console).</p>
        <p>This way local values are sent to the server but not the other way
        around. The same restriction applies to object references in parameters.
        If a copy of the modified instance is desirable it must be returned
        from the annotated method itself.</p>
        <p>To correct the problem above, we can change it to return the new
        value:</p>
<source>
    /**
     * @Remotable
     */
    public int remote() {
       valor++;
       System.out.println("value in remote(): " + value);
       return value;
    }

    public void setValue(int value) {
       this.value = value;

    }

    public static void main(String[] args) {
       LocalVersusRemote lvr = new LocalVersusRemote();
       // ...
       lvr.setValue(lvr.remote());
       // ...
    }
</source>
        <p>This might intimidate some developers at first, but this is exactly
        how a Stateless Session Bean (SSB) works, for example. And the behavior
        of non-remote parameters sent through a RMI call is also the same. A
        stateful component model will be implemented in the near future -
        probably in the 0.3 release.</p>
      </subsection>
    </section>
    <section name="Transaction support">
      <p>To run a method inside a transaction, one need simply use the
      <code>@Transactional</code> annotation in quite a similar way as in the
      use of <code>@Remotable</code>. See below:</p>
<source>
/**
 * @Transactional
 */
public void transactionalMethod() {
   // method code
}
</source>
      <p>The use of <code>@Transactional</code> automatically applies a
      <code>@Remotable</code> annotation to the method. This way the use of only
      one of these annotation above in a given method is needed. Besides
      maintaining transparent remoting characteristics,
      <code>@Transactional</code> forces the method to be executed inside a JTA
      transaction. Any other JTA resources accessed inside its execution will be
      automatically included in the same transaction. The transaction context
      will be propagated to any other method or component invoked by the first
      method with a <code>@Transactional</code> annotation, without the need of any
      additional coding.</p>
      <p>If the method execution runs as expected, the transaction will be
      committed at the end of the method. In the case an exception, a
      rollback command will be issued and the exception will be forwarded to the
      client-side's code.</p>
    </section>
    <section name="Hibernate integration">
      <p>genesis provides a great integration with Hibernate framework.
      Currently, in order to take advantage of it, classes must implement the
      <code>net.java.dev.genesis.command.hibernate.HibernateCommand</code>
      interface by definition or by AOP introduction. In the future this won't be
      necessary anymore - most likely beginning with the 0.3 genesis version.</p>
      <p>This interface exposes the <code>setSession(Session)</code> method
      which is called by genesis (on the server-side) before the execution
      of each remote method. genesis injects a valid Hibernate session before the
      method call and sets the session reference to <code>null</code> at the 
      end of the call. To make this easier, another class is provided:
      <code>net.java.dev.genesis.command.hibernate.AbstractHibernateCommand
      </code>. This class implements the above interface and has useful methods
      like <code>getSession()</code>.</p>
      <p>Here is an example of how to use the hibernate integration in a
      business component:</p>
<source>
public class HibernateIntegrationExample extends AbstractHibernateCommand {
   /**
    * @Remotable
    */
   public Collection getAll() throws HibernateException {
      return getSession().createQuery("from MappedClass").list();
   }
}
</source>
      <p>As shown the use of Hibernate API within the business classes is quite
      simple.</p>
    </section>
    <section name="Paging">
      <p>Data paging support is implemented in the
      <code>net.java.dev.genesis.paging</code> package. The classes are <code>
      Page</code>, which represents a result page and <code>Pager</code>, which
      is responsible for pages generation.</p>
      <p>The following properties are exposed in <code>Page</code> class by
      getters and setters:
        <ul>
          <li><b>results</b>: a <code>java.util.List</code> with the results of
          current page.</li>
          <li><b>resultsPerPage</b>: the maximum results per page. <b>It is
          not</b> the number of results from the current page; to obtain this
          information one should use the <code>size()</code> method from
          <code>results</code>.</li>
          <li><b>pageNumber</b>: the current page number, starting from 0.</li>
          <li><b>first</b>: indicates if the current page is the first one. Same
          as <code>getPageNumber() == 0</code>.</li>
          <li><b>last</b>: indicates if the current page is the last one. Some
          <code>Pager</code> implementations might not return this property as
          <code>true</code> when the last page has exactly the same number of
          results as the results per page - i.e. when
          <code>getResults().size() == getResultsPerPage()</code>.</li>
        </ul>
      </p>
      <p>While there is a basic implementation for <code>Page</code>
      (<code>PageImpl</code>), there is none available for <code>Pager</code>,
      because the actual functionality of a pager is quite linked to the data
      source that is being paged. User applications will not normally use
      <code>PageImpl</code> direclty nor will have their own <code>Page</code>
      implementation. Nevertheless the genesis implementation should prove quite
      useful for specifics <code>Pager</code> implementations.</p>
        <subsection name="Paging with Hibernate">
          <p>Two <code>Pager</code> implementations are provided with genesis in
          order to integrate with Hibernate: <code>CriteriaPager</code> and
          <code>QueryPager</code>. They are in
          <code>net.java.dev.genesis.paging.hibernate</code> package. These
          classes can be used as is (the easier way) or by extending the
          <code>AbstractHibernateCommand</code> class. As an example, let's
          change our Hibernate example in such a way it will return only one
          page of data:</p>
<source>
public class HibernatePagingExample extends AbstractHibernateCommand {
   /**
    * @Remotable
    */
   public Page getAll(int pageNumber, int resultsPerPage)
         throws PagingException {
      return getPage(getSession().createQuery("from MappedClass"),
            pageNumber, resultsPerPage);
   }
}
</source>
        <p>In order to get the <code>MappedClass</code> instances from the
        returned page, all we have to do is to call the <code>getResults()</code
        > method on the returned <code>Page</code> object returned. This
        <code>getResults()</code> method returns a <code>List</code
        >, as explained in the <code>Page</code> properties in the section above
        - will hold a list of objects with the same type as if they were
        returned from a <code>query.list()</code> or <code>criteria.list()</code
        > calls.</p>
      </subsection>
    </section>
    <section name="Dynamic criteria searching">
      <p>Although Hibernate provides support for dynamic searches, i.e., with
      "built" clauses or defined at runtime through the <code>Criteria</code>
      interface, the use of this feature leads to a hard to maintain code
      because it tends to be very repetitive. The genesis framework has a
      support for dynamic searches at a higher level of abstraction - this will make
      those search implementations much easier. We will focus on the use of
      this feature from the business tier point of view.</p>
      <p>There is a sub interface from <code>HibernateCommand</code> called
      <code>HibernateCriteria</code>. Similar to the manner in which the Hibernate
       <code>Session</code> is
      injected into <code>HibernateCommand</code> instances, an instance of
      <code>Criteria</code> is attributed through the
      <code>setCriteria(Criteria)</code> method to <code>HibernateCriteria</code
      > implementations at appropriate times. In the same way the
      <code>HibernateCommand</code> interface provides an easier way to the
      developer, there is also a criteria class,
      <code>AbstractHibernateCriteria</code>. This helper class defines the
      <code>getCriteria()</code> method, besides other ones.</p>
      <p>The business method that needs a <code>Criteria</code> instance in
      order to be executed receives a
      <code>@Criteria HibernateMappedClassName</code> annotation. This
      annotation implies the method is also <code>@Remotable</code>, keeping the
      transparent remoting. Before calling this method and right after
      <code>setCriteria(Criteria)</code> execution, the properties' setters
      (see <a href="ui_additional_features.html">Model of User Interface
      Components</a>) from the business component will be called by the genesis
      framework so the recent injected <code>Criteria</code> instance will be
      properly configured. Finally the business method will be executed and its
      return forwarded to client-side code.</p>
      <p>To better understand this concept, an example is provided. Assume there
      is a <code>Person</code> class mapped with Hibernate. This class has,
      among others, the following attributes: <code>name</code> and
      <code>lastName</code>. These attributes will be use as parameters for a
      search. We could code the following dynamic and paged search:</p>
<source>
public class PersonSearch extends AbstractHibernateCriteria {
   public void setName(String name) {
      getCriteria().add(Expression.ilike("name", name, MatchMode.START));
   }

   public void setLastName(String lastName) {
      getCriteria().add(Expression.ilike("lastName", lastName,
            MatchMode.START));
   }

   /**
    * @Criteria Person
    */
   public Page getPeople(int pageNumber) throws PagingException {
      return getPage(getCriteria(), pageNumber);
   }
}
</source>
      <p>Once the form properties are copied to the business object (as
      explained in <a href="ui_additional_features.html">Client Model</a>),
      the following sequence of events will take place when the
      <code>getPeople(int)</code> method is executed:
        <ul>
          <li>The instance is sent to the server by the transparent remoting.
          </li>
          <li>Hibernate session is injected through
          <code>setSession(Session)</code> execution, defined in
          <code>HibernateCommand</code>.</li>
          <li>A <code>Criteria</code> is created by following
          <code>Person</code> persisting class, as indicated by the
          <code>@Criteria</code> annotation.</li>
          <li>The <code>Criteria</code> instance is injected by a call to
          <code>setCriteria(Criteria)</code>, defined in
          <code>HibernateCriteria</code>.</li>
          <li>The properties' setters of the form are executed. The
          <code>PersonSearch</code> class has the ability to restrict the
          <code>Criteria</code> to only use the search fields, without the
          concern of a filled field or not. The genesis framework assures the
          setters have been called - so they are filled.</li>
          <li>At last, the <code>getPeople(int)</code> is executed and the
          results are returned to the client-side in a transparent way.</li>
        </ul>
      </p>
    </section>
  </body>
</document>