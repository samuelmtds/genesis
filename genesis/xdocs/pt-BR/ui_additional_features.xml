<?xml version="1.0" encoding="ISO-8859-1"?>
<document>
  <properties>
    <title>Modelo de componentes de interface gráfica</title>
    <author email="mister__m@dev.java.net">Michael Nascimento Santos</author>
  </properties>
  <body>
    <section name="Funcionalidades adicionais de componentes de interface
    gráfica">
      <p>Os seguintes conceitos e/ou características são abordados abaixo:
      <ul>
        <li><a href="#Populando combos, listas e tabelas">Populando combos,
        listas e tabelas</a></li>
        <li><a href="#Formatação">Formatação</a></li>
        <li><a href="#Customizando a criação de componentes">Customizando a 
        criação de componentes</a></li>
        <li><a href="#Validando os dados">Validando os dados</a></li>
        <li><a href="#Configurando as mensagens">Configurando as mensagens</a>
        </li>
        <li><a href="#Trabalhando com pesquisas dinâmicas">Trabalhando com
        pesquisas dinâmicas</a></li>
      </ul>
      </p>
    </section>
    <section name="Populando combos, listas e tabelas">
      <p>As opções disponíveis em um combo box podem variar de acordo com os
      dados preenchidos pelo usuário ou outras regras de negócio. O conteúdo de
      uma tabela pode precisar ser preenchido dinamicamente em resposta a um
      critério de filtro especificado pelo usuário, por exemplo. Para lidar com
      tais situações, existe uma anotação chamada <code>@DataProvider</code>,
      cuja sintaxe é:</p>
<source>
@DataProvider &lt;objectField=nomeCampoObjeto&gt;
              &lt;indexField=nomeCampoIndice&gt;
              &lt;widgetName=nomeCampo&gt;
              &lt;callOnInit=valorBooleano&gt;
              &lt;resetSelection=valorBooleano&gt;
</source>
      <p>Esta anotação deve ser colocada em métodos que retornam uma
      <code>java.util.List</code> ou uma array de Objetos.
      O retorno dos métodos será utilizado para popular a combobox, lista ou tabela.
      <code>objectField</code> deve
      receber o nome da propriedade, se houver, que guardará a instância
      selecionada no widget. Deve ser do mesmo tipo ou uma superclasse do tipo
      retornado no método anotado, uma array do tipo ou uma
      <code>Collection</code>. <code>indexField</code> é a propriedade que
      guardará os índices dos elementos selecionados no widget. Deve ser um
      <code>int</code> ou um <code>Integer</code>, uma array de um desses tipos
      ou uma <code>Collection</code>. No caso de <code>widgetName</code>,
      se utilizado, deve receber o nome do widget, definido no xml da view,
      que irá receber as informações retornadas pelo método anotado.
      <b>Pelo menos uma dessas três propriedades deve ser
      informado</b>.</p>
      <p>O <code>name</code> do widget na tela é igual ao nome da propriedade
      informada como <code>widgetName</code>, <code>objectField</code>
      ou <code>indexField</code>, sendo esta a ordem de prioridade para
      determinação do nome.</p>
      <p>Como mencionado acima, <code>objectField</code> e
      <code>indexField</code> recebem um nome de propriedade que pode retornar
      um bean, uma array ou uma <code>Collection</code>. Vejamos quando cada
      tipo poderá ser utilizado:</p>
      <table>
        <tr>
          <th>Tipo de Retorno e Utilização</th>
          <th>objectField</th>
          <th>indexField</th>
        </tr>
        <tr>
          <td>bean: usado sempre para comboboxes e
          listas/tabelas que permitem apenas seleção única</td>
          <td>Qualquer classe (não pode ser tipo primitivo)</td>
          <td>Apenas <code>Integer</code> ou tipo primitivo <code>int</code></td>
        </tr>
        <tr>
          <td><code>Collection</code> ou arrays: utilizado
          para listas/tabelas que permitem seleções múltiplas</td>
          <td>Array de qualquer classe (não pode ser de tipo primitivo) ou
          <code>Collection</code> de qualquer classe</td>
          <td>Apenas array de <code>Integer</code>s (ou de tipo primitivo
          <code>int</code>) ou <code>Collection</code> de
          <code>Integer</code>s</td>
        </tr>
      </table>

      <p>Um exemplo de uso desta anotação é ilustrado abaixo:</p>
<source>
<![CDATA[
<panel gap="5">
   <label text="Estado:" />
   <combobox name="estado" property="key=sigla;value=descricao" />
</panel>
]]>
</source>
<source>
public class Estado {
   private String sigla;
   private String descricao;

   // getters e setters para as propriedades
}
</source>
<source>
/**
 * @Form
 */
public class ExemploDataProviderForm {
   private Estado estado;

   public Estado getEstado() {
      return estado;
   }

   public void setEstado(Estado estado) {
      this.estado = estado;
   }

   /**
    * @DataProvider objectField=estado
    */
   public List populaEstados() {
      // retorna uma Collection contendo instâncias de Estado
   }

   // ...
}
</source>
      <p>No primeiro bloco vemos o xml da tela que exibe um <code>label</code> e
      um <code>combobox</code> que conterá os estados em tempo de execução. A
      propriedade <code>name</code> possui o mesmo valor que o atributo
      <code>objectField</code> da anotação <code>@DataProvider</code> do
      terceiro bloco. Pode-se notar alguns valores configurados no atributo
      <code>property</code>. Os seguintes valores são utilizados no caso de
      comboboxes:</p>
      <ul>
        <li><b>key</b>: nome da propriedade do bean que será utilizado para
        popular o componente cujo valor é único por instância. É sempre
        requerido.</li>
        <li><b>value</b>: nome da propriedade utilizada para exibir o bean. É
        requerida quando o bean não for uma subclasse de
        <code>net.java.dev.reusablecomponents.lang.Enum</code>.</li>
        <li><b>blank</b>: inclui uma linha em branco como primeira opção da
        combobox. Não é requerida e tem como valor padrão <code>false</code>.
        </li>
        <li><b>blankLabel</b>: define o texto a ser exibido na linha em branco.
        Não é requerida, tem como valor padrão uma <code>String</code> vazia e
        só é usada quando <code>blank=true</code>.</li>
      </ul>
      <p>Conforme indicado pelo valor do atributo <code>objectField</code>, a
      propriedade <code>estado</code> conterá a instância de <code>Estado</code>
      correspondente à opção da combo escolhida pelo usuário.</p>
      <p>No caso de uma <code>list</code>, os requirimentos são similares.
      Veja o exemplo abaixo:</p>
<source>
<![CDATA[
<panel gap="5">
   <label text="Estado:" />
   <list name="estado" property="key=sigla;value=descricao" />
</panel>
]]>
</source>
      <p>Os requerimentos para popular uma table são um pouco diferentes. Para
      exibir numa tabela os estados do exemplo anterior, o xml da interface
      poderia ser assim:</p>
<source>
<![CDATA[
<panel gap="5">
   <table name="estado">
      <header>
         <column name="sigla" text="Sigla" />
         <column name="descricao" text="Descrição" />
      </header>
   </table>
</panel>
]]>
</source>
      <p>Com base no exemplo acima, podemos observar que o valor de <code>name
      </code> na tabela precisa ser igual ao valor do atributo
      <code>objectField</code>. Cada linha representará uma instância e cada
      coluna será preenchida com a propriedade do bean cujo nome é o valor de
      <code>name</code> em cada uma delas.</p>
      <p>Uma variação desta anotação ocorre com a utilização do atributo
      <code>callOnInit</code>. Suponha que o <code>combobox</code> ou a
      <code>table</code> dos exemplos acima <b>não devam ser preenchidas</b> na
      inicialização da janela em questão. Neste caso, a anotação deverá ser
      reescrita da seguinte forma:</p>
<source>
   // ...

   /**
    * @DataProvider objectField=estado callOnInit=false
    */
   public List populaEstados() {
      // retorna uma Collection contendo instâncias de Estado
   }

   // ...
</source>
      <p>Desta forma, na inicialização da janela, os widgets
      <code>combobox</code> ou <code>list</code> ou <code>table</code>
      estarão vazios. O preenchimento dos mesmos poderá ser acionado mediante
      a anotação
      <code>@CallWhen</code>. Isto é, a anotação <code>@CallWhen</code> pode ser
      usada em conjunto com <code>@DataProvider</code> para
      indicar sob que condição a tabela/lista/combo
      será repopulada. <code>@Action</code> pode ser usado no mesmo método caso
      este também possa ser acionado por um botão (como Pesquisar, por exemplo)
      e, quando isso ocorrer, o uso de <code>@EnabledWhen</code> e
      <code>@VisibleWhen</code> também será possível.</p>
      <p>O atributo <code>resetSelection</code> determina se os elementos serão
      desselecionados quando o método for invocado. Este é o comportamento
      padrão, ou seja, se omitido, o valor desse atributo é considerado
      <code>false</code>. Quando o valor informado é <code>true</code>, a
      seleção é mantida com respeito a <b>posição</b> dos ítens, o que torna
      essa funcionalidade mais útil quando algo está sendo adicionado ao final
      da <code>java.util.List</code> ou array cada vez que o método é
      executado.</p>
    </section>
    <section name="Formatação">
      <p>Visto que formatar as informações para que sejam exibidas na tela é uma
      parte importante de qualquer aplicação com interface gráfica, espera-se
      que isto seja fácil de fazer e configurável. A API que é utilizada para
      este propósito no genesis encontra-se implementada no pacote
      <code>net.java.dev.genesis.text</code>.</p>
      <p>Encontra-se neste pacote a interface <code>Formatter</code>, que define
      o método <code>format(Object)</code>. Este método converte o objeto
      passado em uma String formatada. Da mesma forma como outros componentes
      comuns do framework, existe um registro padrão de implementações da
      interface, a classe <code>FormatterRegistry</code>. As seguintes
      implementações estão registradas por padrão nessa classe:</p>
      <ul>
        <li><code>EnumFormatter</code> converte instâncias de
        <code>net.java.dev.reusablecomponents.lang.Enum</code> procurando no
        <a href="#Configurando as mensagens"><code>ResourceBundle</code></a> a
        mensagem configurada para a chave formada pelo nome da classe sem pacote
        + "." + nome da constante. Se esta não for encontrada, uma mensagem de
        prioridade INFO será logada e a instância convertida com
        <code>toString()</code>.</li>
        <li><code>DefaultFormatter</code> é registrado para todos os outros
        tipos e converte as instâncias utilizando <code>toString()</code> -
        exceto se forem <code>null</code>, quando retorna uma String com tamanho
        zero.</li>
      </ul>
      <p>Para registrar um novo formatador para uma classe basta utilizar o
      método <code>register(Class,Formatter)</code> em
      <code>FormatterRegistry</code>.</p>
      <p>No entanto, o registro de um formatador por classe pode não ser
      suficiente em algumas situações. Por exemplo, ao se exibir uma propriedade
      booleana como texto, pode-se querer exibir determinado texto no lugar
      das constantes <code>true</code> e <code>false</code>. O genesis possui
      uma API que permite definir explicitamente o formatador de determinado
      campo utilizado na tela. Alguns passos são necessários para isso:</p>
      <ol>
        <li>Ao invés de utilizar alguma versão do método <code>bind(..)</code>,
        deve-se preparar uma instância de <code>ThinletBinder</code> para ser
        ligada a view e a um widget utilizando-se os métodos
        <code>prepareBinder(form)</code> ou
        <code>prepareBinder(widget, form)</code> de
        <code>net.java.dev.genesis.ui.thinlet.BaseThinlet</code>.</li>
        <li>O formatador deve ser registrado utilizando-se o método
        <code>registerFormatter(String,Formatter)</code> em
        <code>net.java.dev.genesis.ui.thinlet.ThinletBinder</code>. O valor da
        <code>String</code> deverá ser o nome da propriedade cujo formatador
        será sobrescrito. Este nome de propriedade é determinado da seguinte
        forma:
          <ul>
            <li>Caso a propriedade seja uma propriedade simples, retornada
            através de um método getter, deve ser usado apenas o nome simples
            dessa propriedade.</li>
            <li>Caso queira se mudar o formatador dos ítens de uma combobox ou
            lista ou de uma das colunas de uma tabela, o nome da propriedade
            deverá ser composto por
            <code>nomeDoWidget.nomePropriedadeObjetoExibido</code>.</li>
          </ul>
        </li>
        <li>Opcionalmente, caso a propriedade cujo formatador foi alterado
        precise ser convertida pelo genesis para seu tipo original e o formato
        gerado não for suportado pelo conversor, deve-se sobrescrever o
        conversor através do método
        <code>registerConverter(String,Converter)</code>.
        <code>org.apache.commons.beanutils.Converter</code> faz parte do
        Jakarta Commons BeanUtils e deve-se consultar a documentação deste
        framework caso seja necessário implementar esta interface.</li>
        <li>Finalmente, deve-se efetuar o binding manualmente chamando-se o
        método <code>bind()</code>.</li>
      </ol>
      <p>Um exemplo destes passos pode ser visto abaixo:</p>
<source>
ThinletBinder binder = prepareBinder(form);
binder.registerFormatter("propriedade", new Formatter() {
   public String format(Object o) {
      return "Formato alterado";
   }
});
binder.bind();
</source>
      <p>O valor de <code>propriedade</code> exibido na tela será sempre a
      constante <code>Formato alterado</code>, independentemente do seu
      valor no form.</p>
      <subsection name="Propriedades virtuais">
        <p>Desde a versão 2.2, é possível se trabalhar com propriedades
        virtuais, ou seja, que não existem no objeto sendo exibido. Essas
        propriedades tem seu valor de exibição determinado através em um
        formatador específico, que tem de estar obrigatoriamente registrado na
        instância de <code>ThinletBinder</code>.
        </p>
        <p>O processo de definição e exibição de uma propriedade virtual é
        basicamente o mesmo de uma propriedade normal, exceto pelos pontos
        abaixos:</p>
        <ul>
           <li>Apenas células de tabelas e valores exibidos em comboboxes e
           listas podem ser propriedades virtuais.</li>
           <li>Propriedades virtuais podem ser definidas em comboboxes e listas
           definindo-se no elemento <code>property</code> do xml
           <code>virtual=true</code>. Visto que colunas de tabelas não possuem
           o atributo <code>property</code>, o valor de seu atributo
           <code>name</code> deve ser precedido do prefixo <code>virtual:</code>
           .</li>
           <li>A instância de <code>Formatter</code> receberá como parâmetro do
           método <code>format(Object)</code> todo o bean sendo exibido, já que
           a propriedade a ser exibida não existe fisicamente no objeto.</li>
        </ul>
        <p>Um exemplo de definição e uso de uma propriedade virtual é mostrado
        abaixo, tanto para comboboxes como para tabelas:</p>
<source>
<![CDATA[
<panel gap="5">
   <combobox name="widget"
             property="key=propriedadeUnica;value=valorVirtual;virtual=true" />
</panel>
]]>
</source>
<source>
<![CDATA[
<panel gap="5">
   <table name="widget">
      <header>
         <column name="propriedadeUnica" text="#" />
         <column name="virtual:valorVirtual" text="Virtual" />
      </header>
   </table>
</panel>
]]>
</source>
<source>
ThinletBinder binder = prepareBinder(form);
binder.registerFormatter("widget.valorVirtual", new Formatter() {
   public String format(Object o) {
      return o == null ? "0" : String.valueOf(o.hashCode());
   }
});
binder.bind();
</source>
        <p>É importante notar que, embora o nome da coluna seja precedido de
        <code>virtual:</code>, isso não afeta a formação do nome da propriedade
        na hora de registrar o formatador.</p>
      </subsection>
   </section>
   <section name="Customizando a criação de componentes">
      <p>A partir da versão 2.3, é possivel customizar a maneira com que os
      componentes são criados através da interface 
      <code>net.java.dev.genesis.ui.thinlet.WidgetFactory</code> e de outras
      classes de suporte. É possível fazer isso tanto por classe do dado a ser 
      representado quanto por widget específico.</p>
      <p>Para fazer com que, por exemplo, tanto as células das tabelas como os 
      ítens das listas e comboboxes sejam alinhadas a direita quando seu
      conteúdo for uma subclasse de <code>java.lang.Number</code>, deve-se
      registrar uma instância de <code>WidgetFactory</code> em
      <code>net.java.dev.genesis.ui.thinlet.WidgetFactoryRegistry</code> 
      antes que qualquer código que crie widgets seja executado. Isto pode ser 
      feito como mostrado abaixo:</p>
<source>
public class NumberWidgetFactory extends DefaultWidgetFactory {
   public Object create(BaseThinlet thinlet, String name, String value,
         Object bean, BaseThinlet.ItemType type) {
      Object widget = super.create(thinlet, name, value, bean, type);
      Thinlet.setChoice(widget, BaseThinlet.ALIGNMENT, BaseThinlet.RIGHT);
      return widget;
   }
}
</source>
<source>
// Código de registro, provavelmente no main
WidgetFactoryRegistry.getInstance().register(Number.class, new NumberWidgetFactory());
</source>
      <p>Conforme mostrado no código acima, a maioria das implementações de
      <code>WidgetFactory</code> herdará da classe 
      <code>DefaultWidgetFactory</code>, que implementa o comportamento 
      básico utilizado no genesis. Os argumentos passados para o método 
      <code>create(BaseThinlet, String, String, Object, BaseThinlet.ItemType)</code>
      são, respectivamente:</p>
      <ul>
         <li><b>thinlet</b>: a instância da subclasse de 
         <code>BaseThinlet</code> onde o widget será adicionado.</li>
         <li><b>name</b>: valor da propriedade a ser usada como nome do 
         componente. Pode ser ignorada, mas isso normalmente não é recomendável.
         </li>
         <li><b>value</b>: o valor do texto a ser usado no componente. Pode ser 
         ignorado, mas isso normalmente não é recomendável.</li>
         <li><b>property</b>: a propriedade que foi formatada para produzir
         <code>value</code>. Pode ser usada em casos bem específicos, como para 
         criar uma tooltip com base em outra propriedade de um bean.</li>
         <li><b>type</b>: o tipo do widget a ser criado, de acordo com a 
         enumeração.</li>
      </ul>
      <p>Para utilizar uma instância de <code>WidgetFactory</code> para criar
      algum widget específico, deve-se registrá-la na instância de 
      <code>ThinletBinder</code> com o método <code>registerWidgetFactory(String,
      WidgetFactory)</code>, utilizando-se a mesma regra de nomenclatura 
      explicada na seção de <a href="#Formatação">Formatação</a>, conforme 
      exemplificado abaixo:</p>
<source>
<![CDATA[
<panel gap="5">
   <table name="widget">
      <header>
         <column name="propriedadeComum" text="Comum" />
         <column name="propriedadeEspecifica" text="Especifica" />
      </header>
   </table>
</panel>
]]>
</source>
<source>
ThinletBinder binder = prepareBinder(form);
binder.registerFormatter("widget.propriedadeEspecifica", new NumberWidgetFactory());
binder.bind();
</source>
    </section>
    <section name="Validando os dados">
      <p>A validação de dados é crítica para a integridade de um sistema,
      especialmente quando esses dados são entrados pelo usuário, como no caso
      de uma interface gráfica. O suporte a validação no genesis é implementado
      utilizando-se de um dos componentes do projeto Jakarta, o <a href=
      "http://jakarta.apache.org/commons/validator/">commons-validator</a>.
      Diversos outros softwares open-source utilizam o commons-validator como
      componente de validação, incluindo o Struts, o que aumenta as chances de
      já se estar familiarizado com ele. Caso contrário, recomendamos a leitura
      da documentação no próprio site do projeto.</p>
      <p>A anotação <code>@ValidateBefore</code> pode ser colocada em ações que
      só podem ser executadas quando a validação for bem-sucedida. Caso ocorra
      algum erro de validação será lançada uma
      <code>net.java.dev.genesis.ui.ValidationException</code>, que já é <a
      href="#Tratando erros">tratada por padrão</a> pelo framework de modo a
      exibir os erros formatados para o usuário.</p>
      <p>Diversos validadores padrão encontram-se implementados em
      <code>BasicValidator</code>, do pacote <code>net.java.dev.genesis.ui</code
      >. Estes validadores são, em grande parte, semelhantes aos providos com o
      Struts, o que facilita sua compreensão. São eles:</p>
      <ul>
        <li><code><b>byte</b>, <b>short</b>, <b>int</b>, <b>long</b>,
        <b>float</b> e <b>double</b></code>: verificam se o dado pode ser
        convertido para um desses tipos sem estouro de faixa.</li>
        <li><code><b>bigDecimal</b></code>: verifica se o dado pode ser
        convertido para <code>java.math.BigDecimal</code> utilizando o conversor
        padrão do <a href="http://jakarta.apache.org/commons/beanutils">
        BeanUtils</a> registrado para ele. O genesis provê uma implementação
        personalizada deste conversor, <code>BigDecimalConverter</code> em
        <code>net.java.dev.genesis.commons.beanutils.converters</code>, visto
        que as implementações que acompanham com o BeanUtils não funcionam da
        maneira esperada para o Locale pt-BR.</li>
        <li><code><b>date</b></code>: implementação de validação de datas. Pode
        utilizar a variável <code>pattern</code> como padrão de data válido.
        Este padrão é compatível com os especificados para a classe
        <code>java.text.DateFormat</code>.</li>
        <li><code><b>email</b></code>: somente aceita conteúdo que possa ser
        considerado um email sintaticamente válido.</li>
        <li><code><b>required</b></code>: assegura que o campo não esteja vazio.
        </li>
        <li><code><b>requiredif</b></code>: compatível com a versão que
        acompanha o Struts, implementa um tipo de validação relativamente fraco.
        Seu uso não é recomendado e é provido somente para facilitar a migração
        de usuários do Struts. Utilize <a href="generic_scripting.html">scripts</a> 
        ao invés deste.</li>
        <li><code><b>mask</b></code>: implementa validação com base numa
        expressão regular de máscara. Requer a definição da variável
        <code>mask</code> contendo a expressão regular.</li>
        <li><code><b>minlength</b> e <b>maxlength</b></code>: garantem que o
        dado informado possui um número não inferior e não superior,
        respectivamente, ao número máximo de caracteres definido através da
        variável <code>minlength</code> e <code>maxlength</code>.</li>
        <li><code><b>min</b></code>: verifica se o número informado é maior ou 
        igual ao valor da variável <code>min</code>.</li>
        <li><code><b>max</b></code>: verifica se o número informado é menor ou 
        igual ao valor da variável <code>max</code>.</li>
        <li><code><b>longRange</b>, <b>doubleRange</b> e <b>bigDecimalRange</b>
        </code>: verificam se o número informado encontra-se dentro da faixa
        esperada, definida através das variáveis <code>min</code> e
        <code>max</code>.</li>
        <li><a href="generic_scripting.html">Scripts</a>: o mais flexível validador provido com o
        genesis. Considera o dado válido se a análise da expressão de script
        definida pela variável <code>de script</code> retornar um dado diferente de
        <code>java.lang.Boolean.FALSE</code>.</li>
      </ul>
      <p>Assim como os validadores do Struts, todos os providos com o genesis,
      exceto pelos de <a href="generic_scripting.html">scripts</a> só são 
      acionados se o campo estiver
      preenchido. Isso significa que <b>mesmo que você configure seu validador
      corretamente, ele só será invocado quando o usuário preencher algo no
      campo</b>. Se sua intenção é que o validador seja sempre executado,
      <code>required</code> também deverá estar configurado para o campo.</p>
      <p>Os dados a serem validados são passados ainda em formato String para os
      validadores. É importante lembrar-se disso ao escrever expressões de script
      ou quando se utiliza um validador customizado.</p>
      <p>A classe que integra o commons-validator ao genesis,
      <code>net.java.dev.genesis.ui.ValidationUtils</code>, espera que dois
      arquivos de configuração estejam disponíveis no classpath:
      <code>validation-rules.xml</code> e <code>validation.xml</code>. Estes
      arquivos devem estar de acordo com o DTD para o commons-validator 1.1. Uma
      configuração padrão para <code>validation-rules.xml</code> é provida no
      jar do genesis-client, como abaixo:</p>
<source>
<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE form-validation PUBLIC 
   '-//Apache Software Foundation//DTD Commons Validator Rules Configuration 1.1//EN' 
   'http://jakarta.apache.org/commons/dtds/validator_1_1.dtd'>
<form-validation>
    <global>
        <validator name="byte" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateByte" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.byte"/>
        <validator name="short" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateShort" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.short"/>	
        <validator name="int" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateInt" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.int"/>
        <validator name="long" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateLong" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.long"/>
        <validator name="float" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateFloat" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.float"/>
        <validator name="double" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateDouble" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.double"/>
        <validator name="bigDecimal" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateBigDecimal" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.bigdecimal"/>
        <validator name="required" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateRequired" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.required"/>
        <validator name="requiredif" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateRequiredIf" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field,org.apache.commons.validator.Validator" 
                msg="errors.requiredif"/>
        <validator name="mask" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateMask" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.mask"/>
        <validator name="email" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateEmail" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.email"/>
        <validator name="date" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateDate" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.date"/>			
        <validator name="minlength" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateMinLength" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.minlength"/>			
        <validator name="maxlength" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateMaxLength" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.maxlength"/>			
        <validator name="min" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateMin" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.min"/>	
        <validator name="max" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateMax" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.max"/>	
        <validator name="longRange" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateLongRange" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.longRange"/>			
        <validator name="doubleRange" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateDoubleRange" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.doubleRange"/>		
        <validator name="bigDecimalRange" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateBigDecimalRange" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.bigDecimalRange"/>	
        <validator name="jxpath" 
                classname="net.java.dev.genesis.ui.BasicValidator" 
                method="validateJXPath" 
                methodParams="java.lang.Object,org.apache.commons.validator.Field" 
                msg="errors.jxpath"/>			
    </global>
</form-validation>
]]>
</source>
      <p>Na maioria dos casos, uma forma prática de se configurar a validação
      por form é utilizar o <a href="http://xdoclet.sf.net">XDoclet</a>. Um
      exemplo de configuração de validação do exemplo useradmin é a classe
      <code>InsertUpdateForm</code>, do pacote
      <code>net.java.dev.genesis.samples.useradmin.ui</code>, parcialmente
      transcrito abaixo:</p>
<source>
/**
 * @Form
 * @genesis.form
 */
public class InsertUpdateForm {
   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.birthday"
    *
    * @genesis.validator type="date"
    * @genesis.validator-var name="pattern" value="MM/dd/yyyy"
    */
   public void setBirthday(Date birthday) {
      this.birthday = birthday;
   }

   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.country"
    */
   public void setCountry(Country country) {
      this.country = country;
   }

   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.email"
    *
    * @genesis.validator type="email"
    * @genesis.validator-args arg0resource="User.email"
    */
   public void setEmail(String email) {
      this.email = email;
   }

   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.role"
    */
   public void setRole(Role role) {
      this.role = role;
      setRoleCode(role == null ? null : role.getCode());
   }

   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.login"
    *
    * @genesis.validator type="minlength" arg1value="${var:minlength}"
    * @genesis.validator-var name="minlength" value="4"
    */
   public void setLogin(String login) {
      this.login = login;
   }

   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.name"
    */
   public void setName(String name) {
      this.name = name;
   }

   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.password"
    *
    * @genesis.validator type="minlength" arg1value="${var:minlength}"
    * @genesis.validator-var name="minlength" value="6"
    *
    * @genesis.validator type="maxlength" arg1value="${var:maxlength}"
    * @genesis.validator-var name="maxlength" value="8"
    */
   public void setPassword(String password) {
      this.password = password;
   }

   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.address"
    */
   public void setAddress(String address) {
      this.address = address;
   }

   /**
    * @genesis.validator type="required"
    * @genesis.validator-args arg0resource="User.state"
    */
   public void setState(State state) {
      this.state = state;
   }

   /**
    * @Action
    * @ValidateBefore
    */
   public void save() throws Exception {
      final User user = new User();
      PropertyUtils.copyProperties(user, this);
      if (getId() == null) {
         new UserCreateCommand().createUser(user);
      } else {
         new UserUpdateCommand().updateUser(user);
      }
   }

   // ...
}
</source>
      <p>Antes da chamada a <code>save()</code> ser executada, a validação é
      realizada de acordo com as regras do arquivo gerado e eventuais erros
      impedem a execução do método. Para aqueles que não estão familiarizados
      com o XDoclet, encontra-se abaixo o arquivo <code>validation.xml</code>
      gerado automaticamente durante a execução do build:</p>
<source>
<![CDATA[
<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE form-validation PUBLIC
   '-//Apache Software Foundation//DTD Commons Validator Rules Configuration
   1.1//EN'
   'http://jakarta.apache.org/commons/dtds/validator_1_1.dtd'>
<form-validation>
  <!--
    Define global validation config in validation-global.xml
  -->
  <formset>
      <form name="net.java.dev.genesis.samples.useradmin.ui.InsertUpdateForm">
              <field property="birthday"
                     depends="required,date">
                  <arg position="0"
                       key="User.birthday"
                  />
                  <var>
                    <var-name>pattern</var-name>
                    <var-value>MM/dd/yyyy</var-value>
                  </var>
              </field>
              <field property="country"
                     depends="required">
                  <arg position="0"
                       key="User.country"
                  />
              </field>
              <field property="email"
                     depends="required,email">
                  <arg position="0"
                       key="User.email"
                  />
              </field>
              <field property="role"
                     depends="required">
                  <arg position="0"
                       key="User.role"
                  />
              </field>
              <field property="login"
                     depends="required,minlength">
                  <arg position="0"
                       key="User.login"
                  />
                  <arg position="1"
                       name="minlength"
                       key="${var:minlength}"
                       resource="false"
                  />
                  <var>
                    <var-name>minlength</var-name>
                    <var-value>4</var-value>
                  </var>
              </field>
              <field property="name"
                     depends="required">
                  <arg position="0"
                       key="User.name"
                  />
              </field>
              <field property="password"
                     depends="required,minlength,maxlength">
                  <arg position="0"
                       key="User.password"
                  />
                  <arg position="1"
                       name="minlength"
                       key="${var:minlength}"
                       resource="false"
                  />
                  <arg position="1"
                       name="maxlength"
                       key="${var:maxlength}"
                       resource="false"
                  />
                  <var>
                    <var-name>minlength</var-name>
                    <var-value>6</var-value>
                  </var>
                  <var>
                    <var-name>maxlength</var-name>
                    <var-value>8</var-value>
                  </var>
              </field>
              <field property="address"
                     depends="required">
                  <arg position="0"
                       key="User.address"
                  />
              </field>
              <field property="state"
                     depends="required">
                  <arg position="0"
                       key="User.state"
                  />
              </field>
      </form>
  </formset>
</form-validation>
]]>
</source>
      <p>É utilizado também um arquivo de recursos para configurar as mensagens,
      logo abaixo descrito.</p>
    </section>
    <section name="Configurando as mensagens">
      <p>Diversas mensagens podem ser configuradas externamente ao código
      utilizando-se um <code>java.util.ResourceBundle</code>. O
      <code>ResourceBundle</code> permite armazenar um dicionário de
      propriedades nome/valor - similar a um <code>Properties</code> -,
      suportando múltiplos <code>java.util.Locale</code>s. De forma
      simplificada, é possível configurar mensagens diferentes de acordo com o
      idioma utilizado.</p>
      <p>O genesis utiliza um <code>ResourceBundle</code> de nome
      <code>messages</code>, de modo que deve existir um
      <code>messages.properties</code> no classpath. A classe
      <code>net.java.dev.genesis.ui.UIUtils</code> mantém a instância deste
      <code>ResourceBundle</code> durante a execução.</p>
      <p>São configurados no arquivo de recursos mensagens e texto referentes a:
      </p>
      <ul>
        <li>Validação</li>
        <li>Valores de display das <code>Enum</code>s (no formato
        <code>Classe.CONSTANTE=Valor de display</code>)</li>
        <li>Mensagens das telas padrão providas com o genesis, como a tela
        utilizada por <code>OptionDialog</code></li>
        <li>Quaisquer textos definidos pelo usuário que devam ser externalizados
        do código</li>
      </ul>
      <p>Abaixo há um exemplo de configuração do <code>ResourceBundle</code>
      para o exemplo useradmin:</p>
<source>
# 1. Configuração para validação
errors.byte=The {0} field is not a byte.
errors.short=The {0} field is not a short.
errors.int=The {0} field is not an integer.
errors.long=The {0} field is not a long.
errors.float=The {0} field is not a float.
errors.double=The {0} field is not a double.
errors.bigdecimal=The {0} field is not a big decimal.
errors.required=The {0} field is required.
errors.requiredif=The {0} field is required.
errors.mask=The {0} field is not valid.
errors.email=The {0} field is not a valid email.
errors.date=The {0} field is not a valid date.
errors.min={0} must be greater or equal to {1}.
errors.max={0} must be lesser or equal to {1}.
errors.minlength=The {0} field can not be less than {1} characters.
errors.maxlength=The {0} field can not be greater than {1} characters.
errors.longRange={0} is not in the range {1} through {2}.
errors.doubleRange={0} is not in the range {1} through {2}.
errors.bigDecimalRange={0} is not in the range {1} through {2}.
errors.jxpath=The {0} field is not valid.
validation.errors.title=Validation errors

# 2. Configuração das mensagens das telas
MessageDialog.close=Close
Option.YES=Yes
Option.NO=No
Option.CANCEL=Cancel
ErrorReporterDialog.ok=OK
ErrorReporterDialog.stackTrace=Stack Trace:

# 3. Configurações personalizadas do usuário
InsertRoleView.title=Insert Role
InsertView.title=Insert User
UpdateView.title=Update User
RoleListView.title=Role List
UserListView.title=Users Administration

button.ok=Ok
button.add=Add
button.remove=Remove
button.cancel=Cancel
button.save=Save
button.search=Search
button.reset=Reset
button.newUser=New User
button.updateUser=Update User
button.removeUser=Remove User

User.name=Name
User.login=Login
User.password=Password
User.email=e-mail
User.birthday=Birthday
User.address=Address
User.country=Country
User.state=State
User.role=Role

Role.label=Label
Role.code=Code
</source>
      <p>Para mais informações sobre como trabalhar com arquivos de recurso
      consulte o Javadoc da classe <code>java.util.ResourceBundle</code>.</p>
    </section>
    <section name="Trabalhando com pesquisas dinâmicas">
      <p>O genesis facilita a construção de pesquisas dinâmicas - cujos
      critérios de seleção mudam em tempo de execução, não os valores passados
      para estes - integrando essa funcionalidade tanto com os componentes de
      interface gráfica como com os componentes de negócio.</p>
      <p>Na parte cliente, para permitir que somente as propriedades prenchidas
      sejam utilizadas na busca, basta fazer:</p>
<source>
CriteriaPropertyHelper.fillCriteria(hibernateCriteria, form);
</source>
      <p>A classe <code>CriteriaPropertyHelper</code> encontra-se no pacote
      <code>net.java.dev.genesis.helpers</code>. <code>hibernateCriteria</code>
      deve obedecer os
      <a href="business_component_model.html#Pesquisas dinâmicas com Criteria">
      requisitos para componentes de negócio para pesquisas dinâmicas</a>
      enquanto <code>form</code> deve ser um form do genesis válido. Serão
      copiadas as propriedades que existam em ambos os beans e que estejam
      preenchidas no form de acordo com as
      <a href="#Determinando se o campo está vazio">regras para determinar
      campos vazios</a>. A chamada a <code>fillCriteria(HibernateCriteria,
      Object)</code> deverá ser feita antes da chamada ao método anotado com
      <code>@Criteria</code>.</p>
      <p>Para tornar ainda mais simples a construção de pesquisas dinâmicas com
      resultados paginados, duas classes auxiliares são definidas no pacote
      <code>net.java.dev.genesis.ui.paging</code>: <code>BaseSearchForm</code> e
      <code>BaseCriteriaSearchForm</code>. Estas classes abstratas podem ser
      estendidas pelos forms, diminuindo o esforço de implementação.</p>
      <p><code>BaseSearchForm</code> contém lógica relacionada com a paginação,
      além de abstrair o processo de execução da pesquisa. Algumas ações e
      propriedades podem ser utilizadas diretamente na construção da interface
      gráfica:</p>
      <ul>
        <li><code>previousPage()</code> e <code>nextPage()</code> são ações do
        genesis que podem ser ligadas aos botões na tela que navegarão para a
        página anterior e a próxima página de resultados, respectivamente.
        Possuem anotações <code>@VisibleWhen</code> que ocultarão os widgets
        nas situações corretas.</li>
        <li><code>pageNumber</code> é a propriedade que contém o número da
        página de resultados atual.</li>
      </ul>
      <p>Esta classe também define o método abstrato <code>performSearch()</code
      >, que retorna uma instância de
      <code>net.java.dev.genesis.paging.Page</code> e expõe a propriedade
      <code>runSearch</code>, que deve ser usada na expressão condicional de
      execução da busca nas subclasses. Normalmente, não será necessário
      utilizá-la diretamente, já que <code>BaseCriteriaSearchForm</code> provê
      um nível de abstração maior quando a pesquisa é realizada por uma
      implementação de <code>HibernateCriteria</code>. Neste caso, bastará
      implementar os métodos <code>getHibernateCriteria()</code> de modo a
      retornar o objeto de negócios - que receberá os critérios de busca através
      de uma  chamada a <code>CriteriaPropertyHelper</code> - e o método
      <code>performSearch(int pageNumber)</code>, que efetuará a pesquisa.
      Abaixo encontra-se um exemplo de seu uso extraído do useradmin. Primeiro,
      vemos o trecho de código relevante do form:</p>
<source>
/**
 * @Form
 */
public class UserListForm extends BaseCriteriaSearchForm {
   private final UserSearchCommand command = new UserSearchCommand();

   // codigo para getters e setters de criterios de pesquisa

   public List getUsers() { /* ... */ }

   public void setUsers(List users) { /* ... */ }

   protected HibernateCriteria getHibernateCriteria() {
      return command;
   }

   protected Page performSearch(int pageNumber) throws Exception {
      return command.getUsers(pageNumber);
   }

   /**
    * @Action
    * @CallWhen runSearch=true()
    * @DataProvider objectField=users callOnInit=false
    */
   public List doSearch() throws Exception {
      search();

      return getPage().getResults();
   }

   // codigo restante
</source>
      <p>E o uso das ações para os botões de navegação no xml da interface
      gráfica:</p>
<source>
<![CDATA[
<button name="previousPage" text="<<" font="bold" type="default" alignment="left"/>
<button name="nextPage" text=">>" font="bold" type="default" alignment="right"/>
]]>
</source>
    </section>
  </body>
</document>
