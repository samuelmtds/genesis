<?xml version="1.0" encoding="ISO-8859-1"?>
<document>
  <properties>
    <title>Modelo de componentes de negócio</title>
    <author email="mister__m@dev.java.net">Michael Nascimento Santos</author>
  </properties>
  <body>
    <section name="Modelo de componentes de negócio">
      <p>O modelo de componentes de negócio do genesis é bastante simples de ser
      compreendido. Os seguintes conceitos e/ou características são
      abordados abaixo:
      <ul>
        <li><a href="#Uso das classes de negócio no cliente">Uso das classes de
        negócio no cliente</a></li>
        <li><a href="#Integração com o Hibernate">Integração com o Hibernate</a>
        </li>
        <li><a href="#Paginação">Paginação</a></li>
        <li><a href="#Pesquisas dinâmicas com Criteria">Pesquisas dinâmicas com
        Criteria</a></li>
      </ul>
      </p>
    </section>
    <section name="Uso das classes de negócio no cliente">
      <p>O uso de uma classe de negócio do genesis no código cliente não impõe
      nenhuma restrição. Isto significa que:
      <ul>
        <li>Não é necessário criar uma interface para sua classe de negócio por
        causa do genesis. Outros fatores de boa orientação a objetos podem levar
        a isso, mas não o framework.</li>
        <li>Para se obter uma instância de uma das classes, basta usar <code>new
        </code> ou qualquer outro recurso OO ou Java que já seria usado (uma
        Factory, por exemplo, ou reflection).</li>
        <li>Não é necessário notificar ao framework que certa instância deve ser
        gerenciada por ele. A única configuração requerida pelo genesis
        atualmente é a configuração dos aspectos, feita uma vez no <code>aop.xml
        </code>. Esta configuração pode ser copiada dos exemplos e se precisar
        ser alterada, isso provavelmente só ocorrerá uma vez.</li>
      </ul>
      </p>
    </section>
    <section name="Integração com o Hibernate">
      <p>O genesis provê uma ótima integração com o Hibernate para os
      componentes de negócio. Atualmente, para tirar proveito dela, a classe
      deve implementar a interface <code>
      net.java.dev.genesis.command.hibernate.HibernateCommand</code> diretamente
      ou através de introduction. Futuramente essa limitação será removida,
      provavelmente na versão 3.0.</p>
      <p>Essa interface expõe o método <code>setSession(Session)</code> que é
      invocado automaticamente pelo framework no servidor antes da execução de
      cada método remoto injetando uma sessão válida e após com o valor <code>
      null</code>, para liberar a referência. Para facilitar o uso dessa
      integração na maior parte dos casos, é provida uma classe, <code>
      net.java.dev.genesis.command.hibernate.AbstractHibernateCommand</code> que
      implementa a interface e possui métodos úteis como <code>getSession()
      </code>.</p>
      <p>Abaixo temos um exemplo de como utilizar essa integração num componente
      de negócios:</p>
      <source>
public class ExemploIntegracaoHibernate extends AbstractHibernateCommand {
   /**
    * @Remotable
    */
   public Collection getTodos() throws HibernateException {
      return getSession().createQuery("from ClasseMapeada").list();
   }
}
</source>
      <p>Como o exemplo acima mostra, utilizar o Hibernate em conjunto com suas
      classes de negócio é bastante simples e direto.</p>
    </section>
    <section name="Paginação">
      <p>O suporte à paginação está implementado no pacote <code>
      net.java.dev.genesis.paging</code>. As duas classes principais são <code>
      Page</code>, que representa uma página de resultados e <code>Pager</code>,
      que é responsável por gerar as páginas.</p>
      <p>As seguintes propriedades estão expostas em <code>Page</code> através
      de getters e setters:
      <ul>
        <li><b>results</b>: uma <code>java.util.List</code> contendo os
        resultados da página atual.</li>
        <li><b>resultsPerPage</b>: número máximo de resultados por página. <b>
        Não contém</b> o número de resultados da página atual; para obter essa
        informação deve-se chamar o método <code>size()</code> em <code>results
        </code>.</li>
        <li><b>pageNumber</b>: número da página atual, baseado em 0.</li>
        <li><b>first</b>: indica se esta é a primeira página. O mesmo que <code
        >getPageNumber() == 0</code>.</li>
        <li><b>last</b>: indica se esta é a última página. Algumas
        implementações de <code>Pager</code> podem não retornar essa
        propriedade como <code>true</code> quando a última página contiver
        exatamente o número de resultados por página, ou seja, quando
        <code>getResults().size() == getResultsPerPage()</code>.</li>
      </ul></p>
      <p>Enquanto há uma implementação básica para <code>Page</code> (<code>
      PageImpl</code>), não se tem o mesmo para <code>Pager</code>, visto que a
      funcionalidade de um paginador está bastante ligada à origem dos dados que
      este está paginando. Aplicações cliente normalmente não usarão <code>
      PageImpl</code> nem tampouco terão sua própria implementação de <code>Page
      </code>, mas a implementação provida pelo framework pode ser bastante útil
      para implementações específicas de <code>Pager</code>.</p>
      <subsection name="Paginação de listas">
        <p><code>net.java.dev.genesis.paging.ListPager</code> é uma
        implementação de <code>Pager</code> que pode ser usada para gerar
        páginas a partir de instâncias de <code>java.util.List</code>.</p>
        <p>Existem dois construtores para esta classe: um que aceita somente a
        instância de <code>List</code> e outro que aceita também um parâmetro
        booleano indicando se a propriedade <code>results</code> da instância
        de <code>Page</code> retornada deve ser uma referência direta a uma
        subseção da lista - permitindo assim a modificação da lista original
        pelo código cliente - ou uma nova lista. Caso o primeiro construtor
        seja chamado, o valor dessa propriedade será <code>true</code>, o que
        significa que não será possível alterar o objeto original passado no
        construtor utilizando-se o retorno do método.</p>
        <p>Pode-se utilizar esta classe da seguinte maneira:</p>
        <source>
public class ExemploPaginacaoList {
   public Page getSecao(List lista, int numeroPagina, int resultadosPorPagina)
         throws PagingException {
      return new ListPager(lista).getPage(numeroPagina, resultadosPorPagina);
   }
}
</source>
      </subsection>
      <subsection name="Paginação com Hibernate">
        <p>Duas implementação de <code>Pager</code> são providas junto com o
        genesis para integração com Hibernate: <code>CriteriaPager</code> e
        <code>QueryPager</code>, implementados em <code>
        net.java.dev.genesis.paging.hibernate</code>. Essas classes podem tanto
        ser usadas diretamente como de forma mais fácil e indireta em uma classe
        que estenda <code>AbstractHibernateCommand</code>. Como ilustração,
        vamos modificar nosso exemplo do Hibernate de modo a executar a consulta
        retornando uma página:</p>
        <source>
public class ExemploPaginacaoHibernate extends AbstractHibernateCommand {
   /**
    * @Remotable
    */
   public Page getTodos(int numeroPagina, int resultadosPorPagina)
         throws PagingException {
      return getPage(getSession().createQuery("from ClasseMapeada"),
            numeroPagina, resultadosPorPagina);
   }
}
</source>
        <p>Para se obter as instâncias de <code>ClasseMapeada</code> de dentro
        da página retornada, basta apenas chamar <code>getResults()</code> no
        objeto <code>Page</code> retornado. Essa <code>List</code> - <code>
        getResults()</code> retorna uma <code>List</code>, conforme explicado
        nas propriedades de <code>Page</code>, logo acima - sempre conterá
        elementos do mesmo tipo que estariam presentes numa chamada a <code>
        query.list()</code> ou <code> criteria.list()</code>.</p>
      </subsection>
    </section>
    <section name="Pesquisas dinâmicas com Criteria">
      <p>Embora o Hibernate possua suporte a pesquisas dinâmicas, isto é, com
      cláusulas "montadas" ou definidas em tempo de execução através da
      interface <code>Criteria</code>, o uso prático desse suporte básico leva a
      código bastante repetitivo e difícil de manter. O genesis possui suporte a
      pesquisas dinâmicas num nível de abstração mais alto, o que facilita a
      implementação delas. Abordaremos aqui o uso desse suporte com foco na
      camada de negócios.</p>
      <p>Existe uma subinterface de <code>HibernateCommand</code> chamada <code>
      HibernateCriteria</code>. Assim como a <code>Session</code> é injetada
      para instâncias de <code>HibernateCommand</code>, uma instância de
      <code>Criteria</code> é atribuída através do método
      <code>setCriteria(Criteria)</code> para implementações de
      <code>HibernateCriteria</code> nos momentos apropriados. Da mesma forma
      que ocorre com a primeira interface, existe uma classe base para facilitar
      a implementação de <code>HibernateCriteria</code>,
      <code>AbstractHibernateCriteria</code>. Esta classe auxiliar define o
      método <code>getCriteria()</code>, além de outros métodos utilitários.</p>
      <p>O método de negócio que precisa da instância de <code>Criteria</code>
      para sua execução recebe a anotação <code>@Criteria
      &lt;NomeDaClasseMapeadaNoHibernate&gt; &lt;order-by=propriedades&gt;</code>.
      Essa anotação implica que o método também é <code>@Remotable</code>,
      mantendo assim a remotabilidade transparente. Antes de invocar este
      método e depois de ter invocado <code>setCriteria(Criteria)</code>, os
      setters das propriedades "preenchidas" do objeto de negócio que tenham
      sido copiadas no cliente (ver documentação do
      <a href="ui_additional_features.html">modelo de componentes para interface
      gráfica</a>) serão automaticamente chamados
      pelo framework de modo que a recém-injetada instância de
      <code>Criteria</code> possa ser configurada apropriadamente. Finalmente o
      método de negócios será invocado e seu retorno repassado ao código
      cliente.</p>
      <p>Para entender melhor esse conceito, o exemplo abaixo pode ser de ajuda.
      Supondo-se que existe uma classe <code>Pessoa</code> mapeada via
      Hibernate, que, entre outros atributos, possua <code>nome</code> e <code>
      sobrenome</code>, que são os critérios de pesquisa, podemos implementar
      uma pesquisa dinâmica e paginada sobre a classe da seguinte forma:</p>
<source>
public class PesquisaPessoa extends AbstractHibernateCriteria {
   public void setNome(String nome) {
      getCriteria().add(Expression.ilike("nome", nome, MatchMode.START));
   }

   public void setSobrenome(String sobrenome) {
      getCriteria().add(Expression.ilike("sobrenome", sobrenome,
            MatchMode.START));
   }

   /**
    * @Criteria Pessoa order-by=nome, sobrenome asc
    */
   public Page getPessoas(int numeroPagina) throws PagingException {
      return getPage(getCriteria(), numeroPagina);
   }
}
</source>
      <p>Uma vez tendo copiado as propriedades do formulário para o objeto de
      negócios (conforme explicado na documentação do <a href=
      "ui_additional_features.html">modelo cliente</a>), a seguinte seqüência de
      eventos ocorre quando o método <code>getPessoas(int)</code> é invocado:
      <ul>
        <li>A instância é transferida pelo servidor através da remotabilidade
        transparente.</li>
        <li>É injetada a sessão do Hibernate através da chamada a <code>
        setSession(Session)</code>, definida em <code>HibernateCommand</code>.
        </li>
        <li>É criado um <code>Criteria</code> tendo como base a entidade
        persistente <code>Pessoa</code>, conforme informado na anotação <code>
        @Criteria</code>.</li>
        <li>A instância de <code>Criteria</code> é injetada através de chamada a
        <code>setCriteria(Criteria)</code>, definido em <code>HibernateCriteria
        </code>.</li>
        <li>Os setters das propriedades que estavam preenchidas no form no
        momento da cópia são chamados. A classe <code>PesquisaPessoa</code> tem
        então a chance de restringir o <code>Criteria</code> somente para os
        campos de busca, sem ter de se preocupar se o campo foi preenchido ou
        não, já que o genesis garante que se o setter foi chamado, o campo foi
        preenchido.</li>
        <li>Finalmente, o método <code>getPessoas(int)</code> é chamado e o
        resultado retornado para o cliente de forma transparente.</li>
      </ul>
      </p>
      <p>É possível utilizar a anotação sem informar o nome da classe mapeada no
      Hibernate. Neste caso, a instância de <code>Criteria</code> não será
      criada e o valor injetado na classe será <code>null</code>, mas o resto do
      comportamento descrito acima será mantido. Isto é útil quando é necessário
      realizar pesquisas dinâmicas complexas que não podem ser implementadas com
      <code>Criteria</code>.</p>
    </section>
  </body>
</document>