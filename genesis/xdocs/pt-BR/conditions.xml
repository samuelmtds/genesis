<?xml version="1.0" encoding="ISO-8859-1"?>
<document>
  <properties>
    <title>Trabalhando com condições</title>
    <author email="mister__m@dev.java.net">Michael Nascimento Santos</author>
  </properties>
  <body>
    <section name="Trabalhando com condições">
      <p>Um conceito poderoso no genesis é o suporte a condições. Esse suporte
      permite implementar uma variedade de características, como controle de
      habilitação/desabilitação de widgets, visibilidade, limpeza automática de
      campos e chamadas automáticas a métodos. Tudo isso é feito de maneira
      declarativa no form, sem necessidade de lidar com a API gráfica utilizada
      para as views.</p>
      <subsection name="Habilitando e desabilitando componentes">
        <p>É muito comum no desenvolvimento de interfaces gráficas a situação em
        que determinado campo ou botão só pode estar habilitado quando uma
        determinada condição é verdade. A fim de simplificar estes casos, o
        genesis possui uma anotação chamada <code>@EnabledWhen</code>. Esta
        anotação pode ser utilizada tanto com atributos como com ações. Um
        exemplo prático do uso encontra-se abaixo:</p>
<source>
@Form
public class ExemploEnabledWhenForm {
   private boolean casado;
   private String nomeConjuge;

   public boolean isCasado() {
      return casado;
   }

   public void setCasado(boolean casado) {
      this.casado = casado;
   }

   @EnabledWhen("form.casado")
   public String getNomeConjuge() {
      return nomeConjuge;
   }

   public void setNomeConjuge(String nomeConjuge) {
      this.nomeConjuge = nomeConjuge;
   }
}
</source>
        <p>No caso acima, somente quando o widget que representa a propriedade
        <code>casado</code> estiver indicando o valor <code>true</code> para ela
        é que será possível entrar com o nome do cônjuge, i.e., esposo/esposa da
        pessoa.</p>
      </subsection>
      <subsection name="Controlando a visibilidade">
        <p>É possível ocultar componentes ou mostrá-los condicionalmente
        utilizando a anotação <code>@VisibleWhen</code>. Sua sintaxe é
        semelhante a da anotação <code>@EnabledWhen</code> e também pode ser
        utilizada tanto para atributos como para ações. Um exemplo de uso com
        ação encontra-se abaixo:</p>
<source>
@Form
public class ExemploVisibleWhenForm {
   private int numeroDependentes;

   public int getNumeroDependentes() {
      return numeroDependentes;
   }

   public void setNumeroDependentes(int numeroDependentes) {
      this.numeroDependentes = numeroDependentes;
   }

   @Action
   @VisibleWhen("form.numeroDependentes > 0")
   public void calculaTaxasAdicionais() {
      // ...
   }

   // ...
}
</source>
        <p>O botão que representa <code>calculaTaxasAdicionais()</code> só
        estará visível quando o valor da propriedade
        <code>numeroDependentes</code> for maior que zero.</p>
      </subsection>
      <subsection name="Agrupamento de widgets">
        <p>Em muitos casos, certas operações necessitam ser executadas para um
        grupo de controles visuais (widgets). Um exemplo desta situação é tornar
        invisível ou habilitado um grupo de controles como um todo. Para 
        explicar como fazer isso, vamos considerar um exemplo prático. Abaixo 
        temos o código resumido da construção de uma mesma interface tanto em 
        Thinlet como em Swing:
        </p>
<source>
<![CDATA[
...
<label text="Data Corrente:" font="bold"/>
<panel width="10" height="1" />
<textfield name="dataCorrente" />
...
]]>
</source>
<source>
<![CDATA[
//..
getContentPane().setLayout(new GridLayout(1, 2, 10, 0));

JLabel dataCorrenteLabel = dataCorrenteLabel = new JLabel();
dataCorrenteLabel.setText("Data Corrente:");
getContentPane().add(dataCorrenteLabel);

JTextField dataCorrente = new javax.swing.JTextField();
dataCorrente.setName("dataCorrente");
getContentPane().add(dataCorrente);

//..
]]>
</source>
        <p>Nas interfaces acima, o desenvolvedor tem a intenção de
        mostrar o campo "Data Corrente" mediante certas condições. Para isso,
        utiliza-se a anotação <code>@VisibleWhen</code> conforme o
        código abaixo:</p>
<source>
@VisibleWhen("certasCondicoes")
public Date getDataCorrente() {
   ...
}
</source>
        <p>Porém, neste caso, o que ocorre é que apenas o campo texto 
        (<code>textfield</code>/<code>JTextField</code>) fica invisível (caso as 
        referidas condições não sejam satisfeitas). Atente para o fato de que o 
        <code>label</code>/<code>JLabel</code> e o <code>panel</code> 
        (necessário para espaçamento no Thinlet) não ficam invisíveis - isto 
        claramente não é o que deve ocorrer nestas situações. O desejável é que 
        esses três controles sigam a mesma regra de visibilidade.</p>
        <p>Para que isto ocorra, utiliza-se a propriedade
        <code>widgetGroup</code> no atributo "property" do
        <code>textfield</code> no xml do Thinlet, conforme o exemplo abaixo:</p>
<source>
<![CDATA[
...
<label name="dataCorrenteLabel" text="Data Corrente:" font="bold"/>
<panel name="dataCorrenteEspaco" width="10" height="1" />
<textfield name="dataCorrente"
      property="widgetGroup=dataCorrenteLabel,dataCorrenteEspaco"/>
...
]]>
</source>
        <p>Veja que os controles <code>label</code> e
        <code>panel</code> agora estão nomeados e referenciados dentro do
        <code>widgetGroup</code>, separados por vírgula.</p>
        <p>Para o Swing, deve-se definir a <code>clientProperty</code> 
        <code>SwingBinder.WIDGET_GROUP_PROPERTY</code> conforme demonstrado 
        abaixo:</p>
<source>
<![CDATA[
//..
getContentPane().setLayout(new GridLayout(1, 2, 10, 0));

JLabel dataCorrenteLabel = dataCorrenteLabel = new JLabel();
dataCorrenteLabel.setName("dataCorrenteLabel");
dataCorrenteLabel.setText("Data Corrente:");
getContentPane().add(dataCorrenteLabel);

JTextField dataCorrente = new javax.swing.JTextField();
dataCorrente.setName("dataCorrente");
dataCorrente.putClientProperty(SwingBinder.WIDGET_GROUP_PROPERTY, "dataCorrenteLabel");
getContentPane().add(dataCorrente);

//..
]]>
</source>
        <p>Perceba que o valor da <code>clientProperty</code> é o 
        <code>name</code> do <code>JLabel</code>. Se houvesse mais de um 
        componente, seus nomes poderiam ser separados por vírgula ou poderia ser
        utilizada uma array de <code>String</code> como valor da propriedade.
        Pode-se ainda colocar o valor da <code>clientProperty</code> o próprio
        componente, uma coleção de componentes ou um array de componentes, como
        ilustrado abaixo:</p>
<source>
//..
getContentPane().setLayout(new GridLayout(1, 2, 10, 0));

JLabel dataCorrenteLabel = dataCorrenteLabel = new JLabel();
dataCorrenteLabel.setName("dataCorrenteLabel");
dataCorrenteLabel.setText("Data Corrente:");
getContentPane().add(dataCorrenteLabel);

JTextField dataCorrente = new javax.swing.JTextField();
dataCorrente.setName("dataCorrente");
dataCorrente.putClientProperty(SwingBinder.WIDGET_GROUP_PROPERTY, <b>dataCorrenteLabel</b>);
getContentPane().add(dataCorrente);

//..
</source>
        <p>Desse modo, todos os widgets referenciados irão obedecer à regra de 
        visibilidade anotada no <code>form</code> anteriormente.</p>
        <p>Além do agrupamento genérico <code>widgetGroup</code>, pode-se
        utilizar as propriedades mais específicas <code>enabledWidgetGroup</code>
        e <code>visibleWidgetGroup</code> que definem um grupo de widgets que
        seguem respectivamente as regras de habilitação/desabilitação e
        visibilidade/invisibilidade de forma separada. Essas propriedades são 
        disponibilizadas porque em muitos casos o agrupamento de widgets é 
        diferente em cada caso. Exemplo:</p>
<source>
<![CDATA[
...
<label name="clienteLabel" text="Cliente:" font="bold"/>
<panel name="clienteEspaco1" width="10" height="1" />
<textfield name="codigoCliente" ... />
<panel name="clienteEspaco2" width="10" height="1" />
<textfield name="nomeCliente"
      property="enabledWidgetGroup=codigoCliente;
            visibleWidgetGroup=clienteLabel,clienteEspaco1,
                               codigoCliente,clienteEspaco2"/>
...
]]>
</source>
        <p>Dessa forma, pode-se definir uma regra de habilitação/desabilitação
        de edição que afetará apenas os widgets <code>codigoCliente</code> e
        <code>nomeCliente</code> e uma outra regra de visibilidade para o
        conjunto completo, incluindo o label e os espaçamentos.</p>
        <p>Para o Swing, utiliza-se as <code>clientProperty</code>s 
        <code>SwingBinder.ENABLED_GROUP_PROPERTY</code> e 
        <code>SwingBinder.VISIBLE_GROUP_PROPERTY</code>.</p>
      </subsection>
      <subsection name="Limpando o conteúdo dos campos">
        <p>Sob diversas condições é necessário limpar o conteúdo de certos
        campos. O genesis pode fazer isso automaticamente pelo programador
        através do uso da anotação <code>@ClearOn</code>. Embora sua sintaxe
        seja semelhante a de <code>@EnabledWhen</code> e
        <code>@VisibleWhen</code>, esta anotação somente pode ser usada para
        atributos e não para ações (já que elas não possuem conteúdo). Pode-se
        modificar um dos exemplos anteriores para torná-lo mais correto:</p>
<source>
@Form
public class ExemploClearOnForm {
   private boolean casado;
   private String nomeConjuge;

   public boolean isCasado() {
      return casado;
   }

   public void setCasado(boolean casado) {
      this.casado = casado;
   }

   @EnabledWhen("form.casado")
   @ClearOn("!form.casado")
   public String getNomeConjuge() {
      return nomeConjuge;
   }

   public void setNomeConjuge(String nomeConjuge) {
      this.nomeConjuge = nomeConjuge;
   }
}
</source>
        <p>Quando a propriedade <code>casado</code> tiver o valor
        <code>false</code> o atributo <code>nomeConjuge</code> terá o seu valor
        resetado para <code>null</code> automaticamente.</p>
        <p>O valor para o qual o campo é resetado é definido através da anotação
        <code>@EmptyValue</code>. Esta anotação deve estar sobre o atributo para
        o qual especifica o valor vazio. Sua sintaxe é:</p>
<source>
@EmptyValue("valor")
</source>
        <p>Caso <code>@EmptyValue</code> não esteja especificado, um valor
        padrão é utilizado - <code>false</code> para campos booleanos, zero para
        numéricos e <code>null</code> para os demais.</p>
        <p>É possível utilizar <code>@ClearOn</code> juntamente com uma anotação
        <code>@DataProvider</code>. Nesses casos, os componentes referenciados pelo
        DataProviders são limpos e as propriedades do form que indicam os itens
        selecionados são resetados para <code>null</code> quando a condição
        for satisfeita. Um exemplo de uso é:</p>
<source>
   @DataProvider(objectField="estado")
   @ClearOn("&lt;alguma condição em linguagem de script&gt;")
   public List populaEstados() {
      ...
   }
</source>
      </subsection>
      <subsection name="Invocando métodos automaticamente">
        <p>Alguns métodos precisam ser chamados toda vez que certas condições
        ocorrerem. Ao invés de forçar o programador a fazer isso manualmente - o
        que pode levar a código "spaghetti" -, o genesis possui a anotação
        <code>@CallWhen</code>. Com sintaxe similar à das anotações anteriores,
        esta anotação pode somente ser usada em ações e não em atributos.</p>
        <p>Pode-se modificar um dos exemplos anteriores para ilustrar o uso
        prático desta anotação:</p>
<source>
@Form
public class ExemploCallWhenForm {
   private int numeroDependentes;

   public int getNumeroDependentes() {
      return numeroDependentes;
   }

   public void setNumeroDependentes(int numeroDependentes) {
      this.numeroDependentes = numeroDependentes;
   }

   @Action
   @CallWhen("form.numeroDependentes > 0")
   public void calculaTaxasAdicionais() {
      // ...
   }

   // ...
}
</source>
        <p>Diferentemente do exemplo original para <code>@VisibleWhen</code>, o
        método <code>calculaTaxasAdicionais()</code> será invocado
        automaticamente pelo genesis toda vez que a propriedade
        <code>numeroDependentes</code> for maior que zero.</p>
      </subsection>
      <subsection name="Declarando condições">
        <p>Embora todas as anotações que recebem condições em formato de script
        possam receber expressões de qualquer tipo, certas condições podem ser 
        utilizadas repetidas vezes no código ou como parte de outra expressão. 
        Assim, o genesis possibilita a declaração dessas condições e sua 
        exportação como variáveis que podem ser referenciadas em outros pontos 
        do código. Para declarar uma condição utiliza-se a anotação 
        <code>@Condition</code>, que possui a seguinte sintaxe:</p>
<source>
@Condition("nomeCondicao=expressaoScript")
</source>
        <p>A variável <code>nomeCondicao</code> é exportada de modo a
        representar a expressão <code>expressaoScript</code> em outros pontos do
        código. A maneira de se referenciar a variável numa outra expressão 
        depende da linguagem de script utlizada.</p>
        <p>Esta anotação pode ser usada tanto na classe, no getter de um
        atributo ou em um método anotado com <code>@Action</code>. Contudo, seu 
        escopo dentro do genesis será sempre o de classe, não importando onde 
        ela seja declarada. Obviamente, esta anotação é útil somente quando 
        usada em conjunto com outra anotação condicional que referencie a 
        variável exportada, como as mencionadas acima.</p>
        <p></p>
      </subsection>
    </section>
    <section name="Determinando se o campo está vazio">
      <p>A fim de realizar ou não algumas operações, o framework precisa
      determinar se um campo está vazio. Além disso, o fato de um campo estar
      preenchido ou não é uma informação que costuma ser utilizada pelo
      desenvolvedor para estabelecer condições nas anotações do genesis. A
      interface <code>EmptyResolver</code>, definida no pacote
      <code>net.java.dev.genesis.resolvers</code> é utilizada para isto.</p>
      <p>Esta interface expõe um único método, <code>isEmpty(Object)</code>, que
      retorna um <code>boolean</code>. Para especificar qual implementação de
      <code>EmptyResolver</code> deverá ser utilizada para determinado atributo
      basta anotá-lo com <code>@EmptyResolver</code>. A sintaxe desta anotação
      é:</p>
<source>
@EmptyResolver(value=&lt;classeQueImplementaInterface&gt;,
               properties=&lt;atributos&gt;)
</source>
      <p>Para evitar que fosse necessário especificar qual implementação de
      <code>EmptyResolver</code> deveria ser utilizada para cada atributo em
      cada form de uma aplicação, o genesis provê um mecanismo capaz de
      determinar uma implementação padrão com base no tipo do atributo. A classe
      <code>EmptyResolverRegistry</code> mantém um registro das implementações
      padrão de <code>EmptyResolver</code> por classe. As seguintes
      implementações padrão são mantidas inicialmente:</p>
      <ul>
        <li><code>MapEmptyResolver</code> é registrado para instâncias de
        <code>java.util.Map</code>. Retorna <code>true</code> quando a instância
        é nula ou <code>java.util.Map.isEmpty()</code> retorne <code>true</code>.</li>
        <li><code>CollectionEmptyResolver</code> é a implementação padrão para
        <code>java.util.Collection</code>. Usa o mesmo princípio que
        <code>MapEmptyResolver</code> para determinar as instâncias vazias.</li>
        <li>A implementação registrada para <code>String</code> é
        <code>StringEmptyResolver</code>. Retorna <code>true</code> quando a instância
        é nula ou de tamanho zero após removidos os espaços, i.e.,
        <code>s == null || s.trim().length() == 0</code>.</li>
        <li>Para todos os casos restantes é registrada uma instância de
        <code>DefaultEmptyResolver</code>. Esta implementação retorna <code>true</code>
        para instâncias nulas ou arrays com zero elementos.</li>
      </ul>
      <p>Estas implementações registradas como padrão devem ser suficientes para
      a maioria dos casos. Como exemplo de customização, consideremos o uso da
      anotação em um atributo de form no qual espaços vazios são relevantes:</p>
<source>
@EmptyResolver(properties="trim=false")
public String getAtributo() {
   return atributo;
}
</source>
      <p>Visto que <code>String</code> já possui um <code>EmptyResolver</code>
      padrão registrado, <code>StringEmptyResolver</code>, e que esta
      implementação já expõe um atributo que permite configurar se os espaços
      serão removidos ou não, não é necessário especificar o nome da classe que
      implementa a interface e sim apenas definir a propriedade <code>trim</code>
      como <code>false</code>. Se não fosse possível configurar a instância
      padrão, uma outra implementação poderia ser usada da seguinte forma:</p>
<source>
@EmptyResolver(br.com.empresa.pacote.ImplementacaoEmptyResolver.class)
public String getAtributo() {
   return atributo;
}
</source>
      <subsection name="Verificando se um campo está vazio em expressões
          condicionais">
        <p>Conforme já mencionado, é muito comum determinar condições baseadas
        no fato de um campo estar vazio ou não. O genesis expõe funções de script
        auxiliares que podem ser usadas nas condições com o intuito de facilitar
        esta tarefa: <code>isEmpty(any)</code> e 
        <code>isNotEmpty(any)</code>.</p>
        <p>Quando o valor passado para elas é uma propriedade do form, o
        <code>EmptyResolver</code> configurado para ela - determinado pelo
        processo acima descrito - é utilizado para determinar o retorno da
        função. Caso seja uma variável ou mesmo uma constante, obtém-se de
        <code>EmptyResolverRegistry</code> a implementação padrão de
        <code>EmptyResolver</code> para o tipo da expressão e esta é usada.
        Pode-se utilizar estas funções com a linguagem de script padrão do 
        genesis, <a href="generic_scripting.html">JavaScript</a>, como mostrado 
        abaixo:</p>
<source>
public String getAtributo() {
   return atributo;
}

public void setAtributo(String atributo) {
   this.atributo = atributo;
}

@EnabledWhen("genesis.isNotEmpty('form:atributo')")
public String getAtributoDependente() {
   return atributoDependente;
}

public void setAtributoDependente(String atributoDependente) {
   this.atributoDependente = atributoDependente;
}
</source>
        <p>Note o uso da sintaxe <code>'form:atributo'</code> como parâmetro da
        função. Isso é necessário para que a função seja aplicada para o valor
        de <code>atributo</code> no form, ao invés de utilizar a literal 
        <code>'atributo'</code> como argumento.</p>
        <p>É possível verificar a sintaxe desta função para outras linguagens de
        script no <a href="quick_reference.html#Funções_script_do_genesis">guia 
        de referência rápida de anotações</a>.</p>
      </subsection>
    </section>
    <section name="Comparando valores">
      <p>Tanto o próprio framework como o desenvolvedor precisa diversas vezes
      verificar se algum campo teve seu valor alterado ou se seu valor é igual
      ao de uma constante ou ao conteúdo de outro campo. A interface
      <code>EqualityComparator</code> definida em
      <code>net.java.dev.genesis.equality</code> é implementada por classes
      capazes de tomar essa decisão.</p>
      <p>Nesta interface é definido o método <code>equals(Object,Object)</code>
      que retorna um <code>boolean</code> indicando se as instâncias comparadas
      são iguais. A anotação de mesmo nome, <code>@EqualityComparator</code>
      pode ser usada para definir explicitamente a implementação utilizada para
      determinado atributo. Sua sintaxe é semelhante a de
      <code>@EmptyResolver</code>:</p>
<source>
@EqualityComparator(value=&lt;classeQueImplementaInterface&gt;,
                    properties=&lt;atributos&gt;
</source>
      <p>Na maioria dos casos não será necessário utilizar a anotação visto que
      o genesis possui também para este caso um mecanismo padrão para determinar
      qual implementação da interface deve ser utilizada para um dado atributo.
      O registro das classes e suas implementações é mantido por
      <code>EqualityComparatorRegistry</code>. As implementações registradas por
      padrão são:</p>
      <ul>
        <li><code>BigDecimalEqualityComparator</code> considera duas instâncias
        de <code>java.math.BigDecimal</code> iguais se ambas forem nulas ou se o
        retorno do método <code>compareTo(BigDecimal)</code> invocado sobre uma
        delas for zero.</li>
        <li><code>StringEqualityComparator</code> considera <code>String</code>s
        nulas ou de tamanho zero após removidos os espaços como iguais. Também
        são consideradas iguais se <code>s1.trim().equals(s2.trim())</code>.</li>
        <li>Os casos restantes são tratados por
        <code>DefaultEqualityComparator</code> que determina como iguais duas
        instâncias nulas ou utiliza o retorno de <code>o1.equals(o2)</code>.</li>
      </ul>
      <subsection name="Verificando mudanças de valores em campos e fazendo
          comparações em expressões condicionais">
        <p>Algumas funções de script são exportadas pelo genesis para auxiliar o
        programador em tarefas comuns:</p>
        <ul>
          <li><code>hasChanged(propriedade)</code> e
          <code>hasNotChanged(propriedade)</code> verificam se ocorreram ou
          não mudanças no valor da propriedade do form.</li>
          <li><code>equals(any,any)</code> e <code>notEquals(any,any)</code>
          comparam dois valores - que podem ser constantes, propriedades do form
          ou variáveis - e retornam o resultado da comparação.</li>
        </ul>
        <p>O genesis mantém internamente um controle dos campos que tiveram seu
        valor alterado na iteração atual. É esta lista que é consultada pelas
        funções <code>hasChanged(propriedade)</code> e
        <code>hasNotChanged(propriedade)</code>. Para determinar se um valor
        foi alterado ou não e popular esta lista interna, o framework utiliza a
        instância de <code>EqualityComparator</code> configurada para a
        propriedade.</p>
        <p>As funções <code>equals(any,any)</code> e
        <code>notEquals(any,any)</code> também utilizam instâncias de
        <code>EqualityComparator</code> para determinar seu retorno. No entanto,
        o processo para isto é um pouco mais complexo, conforme explicado
        abaixo:</p>
        <ul>
          <li>É determinada a instância de <code>EqualityComparator</code> para
          cada um dos parâmetros. Se o parâmetro for uma propriedade do form, a
          implementação configurada para ele será utilizada. Caso contrário,
          será considerada a implementação padrão obtida através de consulta a
          <code>EqualityComparatorRegistry</code>.</li>
          <li>Se os comparadores dos dois parâmetros forem iguais, o primeiro
          deles será utilizado para compará-los.</li>
          <li>Se o primeiro parâmetro for da mesma classe ou uma subclasse do
          tipo do segundo parâmetro, a sua instância de
          <code>EqualityComparator</code> será utilizada para efetuar a
          comparação.</li>
          <li>Se o segundo parâmetro for da mesma classe ou uma subclasse do
          tipo do primeiro parâmetro, a sua instância de
          <code>EqualityComparator</code> será utilizada para efetuar a
          comparação.</li>
          <li>Se nenhuma das condições acima for verdade será retornado
          <code>false</code>.</li>
        </ul>
        <p>O uso de uma função de cada par, utilizando 
        <a href="generic_scripting.html">JavaScript</a>, é demonstrado 
        abaixo:</p>
<source>
public BigDecimal getTaxa() {
   return taxa;
}

public void setTaxa(BigDecimal taxa) {
   this.taxa = taxa;
}

@Action
@CallWhen("genesis.hasChanged('form:taxa')")
public void recalculaValores() {
   // lógica de recálculo
}
</source>
<source>
public BigDecimal getValorDevido() {
   return valorDevido;
}

public void setValorDevido(BigDecimal valorDevido) {
   this.valorDevido = valorDevido;
}

public BigDecimal getValorPago() {
   return valorPago;
}

public void setValorPago(BigDecimal valorPago) {
   this.valorPago = valorPago;
}

@Action
@CallWhen("genesis.notEquals('form:valorDevido', 'form:valorPago')")
public void calculaMontanteCorrigido() {
   // lógica para cálculo do montante corrigido
}
</source>
      </subsection>
      <subsection name="Alterando a forma como os valores são clonados">
         <p>Em versões anteriores, os valores anteriores das propriedades eram
         simplesmente copiados como parte do estado do form, o que trazia 
         algumas limitações na detecção de mudança de valores. Por exemplo, 
         caso o valor de uma propriedade fosse um JavaBean e uma das 
         propriedades deste bean fosse alterada, não seria possível detectar a
         mudança com <code>genesis.hasChanged('form:propriedade')</code>, visto 
         que tanto a cópia do estado anterior que o genesis possuía como o valor 
         atual apontariam para a mesma instância em memória.</p>
         <p>A partir da versão 2.3 foi introduzida uma API que permite controlar
         como o genesis gera a cópia do valor anterior de uma propriedade. A 
         interface <code>net.java.dev.genesis.cloning.Cloner</code> possui um
         método <code>clone(Object)</code> que retorna o valor que o genesis 
         deve guardar como cópia do valor informado como parâmetro. A 
         implementação padrão dessa interface - provida por 
         <code>net.java.dev.genesis.cloning.DefaultCloner</code> - simplesmente 
         retorna o valor passado como parâmetro, preservando assim a 
         compatibilidade com a versão anterior.</p>
         <p>Assim como no caso de <code>EqualityComparator</code>, existe um 
         registro que associa as implementações de <code>Cloner</code> com a 
         classe usada na propriedade, 
         <code>net.java.dev.genesis.cloning.ClonerRegistry</code>, bem como uma
         anotação que permite sobrescrever a implementação de 
         <code>Cloner</code> a ser usada, <code>@Cloner</code>.</p>
         <p>O código abaixo mostra como sobrescrever a implementação de 
         <code>Cloner</code> usada tanto globalmente como para uma propriedade
         específica de um bean:</p>
<source>
ClonerRegistry.getInstance().register(Usuario.class, new BeanUtilsCloner());
</source>
<source>
@Form
public class ExemploClonerForm {
   @Cloner(net.java.dev.genesis.cloning.BeanUtilsCloner.class)
   public Usuario getUsuario() {
      // ...
   }
   
   // ...
}
</source>
         <p>A classe utilizada nos exemplos acima, 
         <code>net.java.dev.genesis.cloning.BeanUtilsCloner</code>, é a outra 
         implementação provida pelo genesis que clona o valor utilizando a API 
         do Commons BeanUtils.</p>
      </subsection>
    </section>
  </body>
</document>