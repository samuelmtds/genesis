<?xml version="1.0" encoding="ISO-8859-1"?>
<document>
  <properties>
    <title>Trabalhando com condições</title>
    <author email="mister__m@dev.java.net">Michael Nascimento Santos</author>
  </properties>
  <body>
    <section name="Trabalhando com condições">
      <p>Um conceito poderoso no genesis é o suporte a condições. Esse suporte
      permite implementar uma variedade de características, como controle de
      habilitação/desabilitação de widgets, visibilidade, limpeza automática de
      campos e chamadas automáticas a métodos. Tudo isso é feito de maneira
      declarativa no form, sem necessidade de lidar com a API gráfica utilizada
      para as views.</p>
      <subsection name="Habilitando e desabilitando componentes">
        <p>É muito comum no desenvolvimento de interfaces gráficas a situação em
        que determinado campo ou botão só pode estar habilitado quando uma
        determinada condição é verdade. A fim de simplificar estes casos, o
        genesis possui uma anotação chamada <code>@EnabledWhen</code>. Esta
        anotação pode ser utilizada tanto com atributos como com ações. Um
        exemplo prático do uso encontra-se abaixo:</p>
<source>
@Form
public class ExemploEnabledWhenForm {
   private boolean casado;
   private String nomeConjuge;

   public boolean isCasado() {
      return casado;
   }

   public void setCasado(boolean casado) {
      this.casado = casado;
   }

   @EnabledWhen("casado")
   public String getNomeConjuge() {
      return nomeConjuge;
   }

   public void setNomeConjuge(String nomeConjuge) {
      this.nomeConjuge = nomeConjuge;
   }
}
</source>
        <p>No caso acima, somente quando o widget que representa a propriedade
        <code>casado</code> estiver indicando o valor <code>true</code> para ela
        é que será possível entrar com o nome do cônjuge, i.e., esposo/esposa da
        pessoa.</p>
      </subsection>
      <subsection name="Controlando a visibilidade">
        <p>É possível ocultar componentes ou mostrá-los condicionalmente
        utilizando a anotação <code>@VisibleWhen</code>. Sua sintaxe é
        semelhante a da anotação <code>@EnabledWhen</code> e também pode ser
        utilizada tanto para atributos como para ações. Um exemplo de uso com
        ação encontra-se abaixo:</p>
<source>
@Form
public class ExemploVisibleWhenForm {
   private int numeroDependentes;

   public int getNumeroDependentes() {
      return numeroDependentes;
   }

   public void setNumeroDependentes(int numeroDependentes) {
      this.numeroDependentes = numeroDependentes;
   }

   @Action
   @VisibleWhen("numeroDependentes > 0")
   public void calculaTaxasAdicionais() {
      // ...
   }

   // ...
}
</source>
        <p>O botão que representa <code>calculaTaxasAdicionais()</code> só
        estará visível quando o valor da propriedade
        <code>numeroDependentes</code> for maior que zero.</p>
      </subsection>
      <subsection name="Agrupamento de widgets">
        <p>Em muitos casos, certas operações necessitam ser executadas para um
        grupo de controles visuais (widgets). Um exemplo desta situação é tornar
        invisível ou habilitado um grupo de controles como um todo. Para 
        explicar como fazer isso, vamos considerar um exemplo prático. Abaixo 
        temos o código resumido da construção de uma mesma interface tanto em 
        Thinlet como em Swing:
        </p>
<source>
<![CDATA[
...
<label text="Data Corrente:" font="bold"/>
<panel width="10" height="1" />
<textfield name="dataCorrente" />
...
]]>
</source>
<source>
<![CDATA[
//..
getContentPane().setLayout(new GridLayout(1, 2, 10, 0));

JLabel dataCorrenteLabel = dataCorrenteLabel = new JLabel();
dataCorrenteLabel.setText("Data Corrente:");
getContentPane().add(dataCorrenteLabel);

JTextField dataCorrente = new javax.swing.JTextField();
dataCorrente.setName("dataCorrente");
getContentPane().add(dataCorrente);

//..
]]>
</source>
        <p>Nas interfaces acima, o desenvolvedor tem a intenção de
        mostrar o campo "Data Corrente" mediante certas condições. Para isso,
        utiliza-se a anotação <code>@VisibleWhen</code> conforme o
        código abaixo:</p>
<source>
@VisibleWhen("certasCondicoes")
public Date getDataCorrente() {
   ...
}
</source>
        <p>Porém, neste caso, o que ocorre é que apenas o campo texto 
        (<code>textfield</code>/<code>JTextField</code>) fica invisível (caso as 
        referidas condições não sejam satisfeitas). Atente para o fato de que o 
        <code>label</code>/<code>JLabel</code> e o <code>panel</code> 
        (necessário para espaçamento no Thinlet) não ficam invisíveis - isto 
        claramente não é o que deve ocorrer nestas situações. O desejável é que 
        esses três controles sigam a mesma regra de visibilidade.</p>
        <p>Para que isto ocorra, utiliza-se a propriedade
        <code>widgetGroup</code> no atributo "property" do
        <code>textfield</code> no xml do Thinlet, conforme o exemplo abaixo:</p>
<source>
<![CDATA[
...
<label name="dataCorrenteLabel" text="Data Corrente:" font="bold"/>
<panel name="dataCorrenteEspaco" width="10" height="1" />
<textfield name="dataCorrente"
      property="widgetGroup=dataCorrenteLabel,dataCorrenteEspaco"/>
...
]]>
</source>
        <p>Veja que os controles <code>label</code> e
        <code>panel</code> agora estão nomeados e referenciados dentro do
        <code>widgetGroup</code>, separados por vírgula.</p>
        <p>Para o Swing, deve-se definir a <code>clientProperty</code> 
        <code>SwingBinder.WIDGET_GROUP_PROPERTY</code> conforme demonstrado 
        abaixo:</p>
<source>
<![CDATA[
//..
getContentPane().setLayout(new GridLayout(1, 2, 10, 0));

JLabel dataCorrenteLabel = dataCorrenteLabel = new JLabel();
dataCorrenteLabel.setName("dataCorrenteLabel");
dataCorrenteLabel.setText("Data Corrente:");
getContentPane().add(dataCorrenteLabel);

JTextField dataCorrente = new javax.swing.JTextField();
dataCorrente.setName("dataCorrente");
dataCorrente.putClientProperty(SwingBinder.WIDGET_GROUP_PROPERTY, 
    "dataCorrenteLabel");
getContentPane().add(dataCorrente);

//..
]]>
</source>
        <p>Perceba que o valor da <code>clientProperty</code> é o 
        <code>name</code> do <code>JLabel</code>. Se houvesse mais de um 
        componente, seus nomes poderiam ser separados por vírgula ou poderia ser
        utilizada uma array de <code>String</code> como valor da propriedade.</p>
        <p>Desse modo, todos os widgets referenciados irão obedecer à regra de 
        visibilidade anotada no <code>form</code> anteriormente.</p>
        <p>Além do agrupamento genérico <code>widgetGroup</code>, pode-se
        utilizar as propriedades mais específicas <code>enabledWidgetGroup</code>
        e <code>visibleWidgetGroup</code> que definem um grupo de widgets que
        seguem respectivamente as regras de habilitação/desabilitação e
        visibilidade/invisibilidade de forma separada. Essas propriedades são 
        disponibilizadas porque em muitos casos o agrupamento de widgets é 
        diferente em cada caso. Exemplo:</p>
<source>
<![CDATA[
...
<label name="clienteLabel" text="Cliente:" font="bold"/>
<panel name="clienteEspaco1" width="10" height="1" />
<textfield name="codigoCliente" ... />
<panel name="clienteEspaco2" width="10" height="1" />
<textfield name="nomeCliente"
      property="enabledWidgetGroup=codigoCliente;
            visibleWidgetGroup=clienteLabel,clienteEspaco1,
                               codigoCliente,clienteEspaco2"/>
...
]]>
</source>
        <p>Dessa forma, pode-se definir uma regra de habilitação/desabilitação
        de edição que afetará apenas os widgets <code>codigoCliente</code> e
        <code>nomeCliente</code> e uma outra regra de visibilidade para o
        conjunto completo, incluindo o label e os espaçamentos.</p>
        <p>Para o Swing, utiliza-se as <code>clientProperty</code>s 
        <code>SwingBinder.ENABLED_GROUP_PROPERTY</code> e 
        <code>SwingBinder.VISIBLE_GROUP_PROPERTY</code>.</p>
      </subsection>
      <subsection name="Limpando o conteúdo dos campos">
        <p>Sob diversas condições é necessário limpar o conteúdo de certos
        campos. O genesis pode fazer isso automaticamente pelo programador
        através do uso da anotação <code>@ClearOn</code>. Embora sua sintaxe
        seja semelhante a de <code>@EnabledWhen</code> e
        <code>@VisibleWhen</code>, esta anotação somente pode ser usada para
        atributos e não para ações (já que elas não possuem conteúdo). Pode-se
        modificar um dos exemplos anteriores para torná-lo mais correto:</p>
<source>
@Form
public class ExemploClearOnForm {
   private boolean casado;
   private String nomeConjuge;

   public boolean isCasado() {
      return casado;
   }

   public void setCasado(boolean casado) {
      this.casado = casado;
   }

   @EnabledWhen("casado")
   @ClearOn("!casado")
   public String getNomeConjuge() {
      return nomeConjuge;
   }

   public void setNomeConjuge(String nomeConjuge) {
      this.nomeConjuge = nomeConjuge;
   }
}
</source>
        <p>Quando a propriedade <code>casado</code> tiver o valor
        <code>false</code> o atributo <code>nomeConjuge</code> terá o seu valor
        resetado para <code>null</code> automaticamente.</p>
        <p>O valor para o qual o campo é resetado é definido através da anotação
        <code>@EmptyValue</code>. Esta anotação deve estar sobre o atributo para
        o qual especifica o valor vazio. Sua sintaxe é:</p>
<source>
@EmptyValue("valor")
</source>
        <p>Caso <code>@EmptyValue</code> não esteja especificado, um valor
        padrão é utilizado - <code>false</code> para campos booleanos, zero para
        numéricos e <code>null</code> para os demais.</p>
        <p>É possível utilizar <code>@ClearOn</code> juntamente com uma anotação
        <code>@DataProvider</code>. Nesses casos, os componentes referenciados pelo
        DataProviders são limpos e as propriedades do form que indicam os itens
        selecionados são resetados para <code>null</code> quando a condição
        for satisfeita. Um exemplo de uso é:</p>
<source>
   @DataProvider(objectField="estado")
   @ClearOn("&lt;alguma condição em linguagem de script&gt;")
   public List populaEstados() {
      ...
   }
</source>
      </subsection>
      <subsection name="Invocando métodos automaticamente">
        <p>Alguns métodos precisam ser chamados toda vez que certas condições
        ocorrerem. Ao invés de forçar o programador a fazer isso manualmente - o
        que pode levar a código "spaghetti" -, o genesis possui a anotação
        <code>@CallWhen</code>. Com sintaxe similar à das anotações anteriores,
        esta anotação pode somente ser usada em ações e não em atributos.</p>
        <p>Pode-se modificar um dos exemplos anteriores para ilustrar o uso
        prático desta anotação:</p>
<source>
@Form
public class ExemploCallWhenForm {
   private int numeroDependentes;

   public int getNumeroDependentes() {
      return numeroDependentes;
   }

   public void setNumeroDependentes(int numeroDependentes) {
      this.numeroDependentes = numeroDependentes;
   }

   @Action
   @CallWhen("numeroDependentes > 0")
   public void calculaTaxasAdicionais() {
      // ...
   }

   // ...
}
</source>
        <p>Diferentemente do exemplo original para <code>@VisibleWhen</code>, o
        método <code>calculaTaxasAdicionais()</code> será invocado
        automaticamente pelo genesis toda vez que a propriedade
        <code>numeroDependentes</code> for maior que zero.</p>
      </subsection>
      <subsection name="Declarando condições">
        <p>Embora todas as anotações que recebem condições em formato de script
        possam receber expressões de qualquer tipo, certas condições podem ser 
        utilizadas repetidas vezes no código ou como parte de outra expressão. 
        Assim, o genesis possibilita a declaração dessas condições e sua 
        exportação como variáveis que podem ser referenciadas em outros pontos 
        do código. Para declarar uma condição utiliza-se a anotação 
        <code>@Condition</code>, que possui a seguinte sintaxe:</p>
<source>
@Condition("nomeCondicao=expressaoScript")
</source>
        <p>A variável <code>nomeCondicao</code> é exportada de modo a
        representar a expressão <code>expressaoScript</code> em outros pontos do
        código. A maneira de se referenciar a variável numa outra expressão 
        depende da linguagem de script utlizada.</p>
        <p>Esta anotação pode ser usada tanto na classe, no getter de um
        atributo ou em um método anotado com <code>@Action</code>. Contudo, seu 
        escopo dentro do genesis será sempre o de classe, não importando onde 
        ela seja declarada. Obviamente, esta anotação é útil somente quando 
        usada em conjunto com outra anotação condicional que referencie a 
        variável exportada, como as mencionadas acima.</p>
        <p></p>
      </subsection>
    </section>
  </body>
</document>
