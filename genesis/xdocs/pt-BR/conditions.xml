<?xml version="1.0" encoding="ISO-8859-1"?>
<document>
  <properties>
    <title>Trabalhando com condições</title>
    <author email="mister__m@dev.java.net">Michael Nascimento Santos</author>
  </properties>
  <body>
    <section name="Trabalhando com condições">
      <p>Um conceito poderoso no genesis é o suporte a condições. Esse suporte
      permite implementar uma variedade de características, como controle de
      habilitação/desabilitação de widgets, visibilidade, limpeza automática de
      campos e chamadas automáticas a métodos. Tudo isso é feito de maneira
      declarativa no form, sem necessidade de lidar com a API gráfica utilizada
      para as views.</p>
      <subsection name="Habilitando e desabilitando componentes">
        <p>É muito comum no desenvolvimento de interfaces gráficas a situação em
        que determinado campo ou botão só pode estar habilitado quando uma
        determinada condição é verdade. A fim de simplificar estes casos, o
        genesis possui uma anotação chamada <code>@EnabledWhen</code>. Esta
        anotação pode ser utilizada tanto com atributos como com ações. Um
        exemplo prático do uso encontra-se abaixo:</p>
<source>
@Form
public class ExemploEnabledWhenForm {
   private boolean casado;
   private String nomeConjuge;

   public boolean isCasado() {
      return casado;
   }

   public void setCasado(boolean casado) {
      this.casado = casado;
   }

   @EnabledWhen("casado")
   public String getNomeConjuge() {
      return nomeConjuge;
   }

   public void setNomeConjuge(String nomeConjuge) {
      this.nomeConjuge = nomeConjuge;
   }
}
</source>
        <p>No caso acima, somente quando o widget que representa a propriedade
        <code>casado</code> estiver indicando o valor <code>true</code> para ela
        é que será possível entrar com o nome do cônjuge, i.e., esposo/esposa da
        pessoa.</p>
      </subsection>
      <subsection name="Controlando a visibilidade">
        <p>É possível ocultar componentes ou mostrá-los condicionalmente
        utilizando a anotação <code>@VisibleWhen</code>. Sua sintaxe é
        semelhante a da anotação <code>@EnabledWhen</code> e também pode ser
        utilizada tanto para atributos como para ações. Um exemplo de uso com
        ação encontra-se abaixo:</p>
<source>
@Form
public class ExemploVisibleWhenForm {
   private int numeroDependentes;

   public int getNumeroDependentes() {
      return numeroDependentes;
   }

   public void setNumeroDependentes(int numeroDependentes) {
      this.numeroDependentes = numeroDependentes;
   }

   @Action
   @VisibleWhen("numeroDependentes > 0")
   public void calculaTaxasAdicionais() {
      // ...
   }

   // ...
}
</source>
        <p>O botão que representa <code>calculaTaxasAdicionais()</code> só
        estará visível quando o valor da propriedade
        <code>numeroDependentes</code> for maior que zero.</p>
      </subsection>
      <subsection name="Agrupamento de widgets">
        <p>Em muitos casos, certas operações necessitam ser executadas para um
        grupo de controles visuais (widgets). Um exemplo desta situação é tornar
        invisível ou habilitado um grupo de controles como um todo. Para 
        explicar como fazer isso, vamos considerar um exemplo prático. Abaixo 
        temos o código resumido da construção de uma mesma interface tanto em 
        Thinlet como em Swing:
        </p>
<source>
<![CDATA[
...
<label text="Data Corrente:" font="bold"/>
<panel width="10" height="1" />
<textfield name="dataCorrente" />
...
]]>
</source>
<source>
<![CDATA[
//..
getContentPane().setLayout(new GridLayout(1, 2, 10, 0));

JLabel dataCorrenteLabel = dataCorrenteLabel = new JLabel();
dataCorrenteLabel.setText("Data Corrente:");
getContentPane().add(dataCorrenteLabel);

JTextField dataCorrente = new javax.swing.JTextField();
dataCorrente.setName("dataCorrente");
getContentPane().add(dataCorrente);

//..
]]>
</source>
        <p>Nas interfaces acima, o desenvolvedor tem a intenção de
        mostrar o campo "Data Corrente" mediante certas condições. Para isso,
        utiliza-se a anotação <code>@VisibleWhen</code> conforme o
        código abaixo:</p>
<source>
@VisibleWhen("certasCondicoes")
public Date getDataCorrente() {
   ...
}
</source>
        <p>Porém, neste caso, o que ocorre é que apenas o campo texto 
        (<code>textfield</code>/<code>JTextField</code>) fica invisível (caso as 
        referidas condições não sejam satisfeitas). Atente para o fato de que o 
        <code>label</code>/<code>JLabel</code> e o <code>panel</code> 
        (necessário para espaçamento no Thinlet) não ficam invisíveis - isto 
        claramente não é o que deve ocorrer nestas situações. O desejável é que 
        esses três controles sigam a mesma regra de visibilidade.</p>
        <p>Para que isto ocorra, utiliza-se a propriedade
        <code>widgetGroup</code> no atributo "property" do
        <code>textfield</code> no xml do Thinlet, conforme o exemplo abaixo:</p>
<source>
<![CDATA[
...
<label name="dataCorrenteLabel" text="Data Corrente:" font="bold"/>
<panel name="dataCorrenteEspaco" width="10" height="1" />
<textfield name="dataCorrente"
      property="widgetGroup=dataCorrenteLabel,dataCorrenteEspaco"/>
...
]]>
</source>
        <p>Veja que os controles <code>label</code> e
        <code>panel</code> agora estão nomeados e referenciados dentro do
        <code>widgetGroup</code>, separados por vírgula.</p>
        <p>Para o Swing, deve-se definir a <code>clientProperty</code> 
        <code>SwingBinder.WIDGET_GROUP_PROPERTY</code> conforme demonstrado 
        abaixo:</p>
<source>
<![CDATA[
//..
getContentPane().setLayout(new GridLayout(1, 2, 10, 0));

JLabel dataCorrenteLabel = dataCorrenteLabel = new JLabel();
dataCorrenteLabel.setName("dataCorrenteLabel");
dataCorrenteLabel.setText("Data Corrente:");
getContentPane().add(dataCorrenteLabel);

JTextField dataCorrente = new javax.swing.JTextField();
dataCorrente.setName("dataCorrente");
dataCorrente.putClientProperty(SwingBinder.WIDGET_GROUP_PROPERTY, 
    "dataCorrenteLabel");
getContentPane().add(dataCorrente);

//..
]]>
</source>
        <p>Perceba que o valor da <code>clientProperty</code> é o 
        <code>name</code> do <code>JLabel</code>. Se houvesse mais de um 
        componente, seus nomes poderiam ser separados por vírgula ou poderia ser
        utilizada uma array de <code>String</code> como valor da propriedade.</p>
        <p>Desse modo, todos os widgets referenciados irão obedecer à regra de 
        visibilidade anotada no <code>form</code> anteriormente.</p>
        <p>Além do agrupamento genérico <code>widgetGroup</code>, pode-se
        utilizar as propriedades mais específicas <code>enabledWidgetGroup</code>
        e <code>visibleWidgetGroup</code> que definem um grupo de widgets que
        seguem respectivamente as regras de habilitação/desabilitação e
        visibilidade/invisibilidade de forma separada. Essas propriedades são 
        disponibilizadas porque em muitos casos o agrupamento de widgets é 
        diferente em cada caso. Exemplo:</p>
<source>
<![CDATA[
...
<label name="clienteLabel" text="Cliente:" font="bold"/>
<panel name="clienteEspaco1" width="10" height="1" />
<textfield name="codigoCliente" ... />
<panel name="clienteEspaco2" width="10" height="1" />
<textfield name="nomeCliente"
      property="enabledWidgetGroup=codigoCliente;
            visibleWidgetGroup=clienteLabel,clienteEspaco1,
                               codigoCliente,clienteEspaco2"/>
...
]]>
</source>
        <p>Dessa forma, pode-se definir uma regra de habilitação/desabilitação
        de edição que afetará apenas os widgets <code>codigoCliente</code> e
        <code>nomeCliente</code> e uma outra regra de visibilidade para o
        conjunto completo, incluindo o label e os espaçamentos.</p>
        <p>Para o Swing, utiliza-se as <code>clientProperty</code>s 
        <code>SwingBinder.ENABLED_GROUP_PROPERTY</code> e 
        <code>SwingBinder.VISIBLE_GROUP_PROPERTY</code>.</p>
      </subsection>
      <subsection name="Limpando o conteúdo dos campos">
        <p>Sob diversas condições é necessário limpar o conteúdo de certos
        campos. O genesis pode fazer isso automaticamente pelo programador
        através do uso da anotação <code>@ClearOn</code>. Embora sua sintaxe
        seja semelhante a de <code>@EnabledWhen</code> e
        <code>@VisibleWhen</code>, esta anotação somente pode ser usada para
        atributos e não para ações (já que elas não possuem conteúdo). Pode-se
        modificar um dos exemplos anteriores para torná-lo mais correto:</p>
<source>
@Form
public class ExemploClearOnForm {
   private boolean casado;
   private String nomeConjuge;

   public boolean isCasado() {
      return casado;
   }

   public void setCasado(boolean casado) {
      this.casado = casado;
   }

   @EnabledWhen("casado")
   @ClearOn("!casado")
   public String getNomeConjuge() {
      return nomeConjuge;
   }

   public void setNomeConjuge(String nomeConjuge) {
      this.nomeConjuge = nomeConjuge;
   }
}
</source>
        <p>Quando a propriedade <code>casado</code> tiver o valor
        <code>false</code> o atributo <code>nomeConjuge</code> terá o seu valor
        resetado para <code>null</code> automaticamente.</p>
        <p>O valor para o qual o campo é resetado é definido através da anotação
        <code>@EmptyValue</code>. Esta anotação deve estar sobre o atributo para
        o qual especifica o valor vazio. Sua sintaxe é:</p>
<source>
@EmptyValue("valor")
</source>
        <p>Caso <code>@EmptyValue</code> não esteja especificado, um valor
        padrão é utilizado - <code>false</code> para campos booleanos, zero para
        numéricos e <code>null</code> para os demais.</p>
        <p>É possível utilizar <code>@ClearOn</code> juntamente com uma anotação
        <code>@DataProvider</code>. Nesses casos, os componentes referenciados pelo
        DataProviders são limpos e as propriedades do form que indicam os itens
        selecionados são resetados para <code>null</code> quando a condição
        for satisfeita. Um exemplo de uso é:</p>
<source>
   @DataProvider(objectField="estado")
   @ClearOn("&lt;alguma condição em linguagem de script&gt;")
   public List populaEstados() {
      ...
   }
</source>
      </subsection>
      <subsection name="Invocando métodos automaticamente">
        <p>Alguns métodos precisam ser chamados toda vez que certas condições
        ocorrerem. Ao invés de forçar o programador a fazer isso manualmente - o
        que pode levar a código "spaghetti" -, o genesis possui a anotação
        <code>@CallWhen</code>. Com sintaxe similar à das anotações anteriores,
        esta anotação pode somente ser usada em ações e não em atributos.</p>
        <p>Pode-se modificar um dos exemplos anteriores para ilustrar o uso
        prático desta anotação:</p>
<source>
@Form
public class ExemploCallWhenForm {
   private int numeroDependentes;

   public int getNumeroDependentes() {
      return numeroDependentes;
   }

   public void setNumeroDependentes(int numeroDependentes) {
      this.numeroDependentes = numeroDependentes;
   }

   @Action
   @CallWhen("numeroDependentes > 0")
   public void calculaTaxasAdicionais() {
      // ...
   }

   // ...
}
</source>
        <p>Diferentemente do exemplo original para <code>@VisibleWhen</code>, o
        método <code>calculaTaxasAdicionais()</code> será invocado
        automaticamente pelo genesis toda vez que a propriedade
        <code>numeroDependentes</code> for maior que zero.</p>
      </subsection>
      <subsection name="Declarando condições">
        <p>Embora todas as anotações que recebem condições em formato de script
        possam receber expressões de qualquer tipo, certas condições podem ser 
        utilizadas repetidas vezes no código ou como parte de outra expressão. 
        Assim, o genesis possibilita a declaração dessas condições e sua 
        exportação como variáveis que podem ser referenciadas em outros pontos 
        do código. Para declarar uma condição utiliza-se a anotação 
        <code>@Condition</code>, que possui a seguinte sintaxe:</p>
<source>
@Condition("nomeCondicao=expressaoScript")
</source>
        <p>A variável <code>nomeCondicao</code> é exportada de modo a
        representar a expressão <code>expressaoScript</code> em outros pontos do
        código. A maneira de se referenciar a variável numa outra expressão 
        depende da linguagem de script utlizada.</p>
        <p>Esta anotação pode ser usada tanto na classe, no getter de um
        atributo ou em um método anotado com <code>@Action</code>. Contudo, seu 
        escopo dentro do genesis será sempre o de classe, não importando onde 
        ela seja declarada. Obviamente, esta anotação é útil somente quando 
        usada em conjunto com outra anotação condicional que referencie a 
        variável exportada, como as mencionadas acima.</p>
        <p></p>
      </subsection>
    </section>
    <section name="Determinando se o campo está vazio">
      <p>A fim de realizar ou não algumas operações, o framework precisa
      determinar se um campo está vazio. Além disso, o fato de um campo estar
      preenchido ou não é uma informação que costuma ser utilizada pelo
      desenvolvedor para estabelecer condições nas anotações do genesis. A
      interface <code>EmptyResolver</code>, definida no pacote
      <code>net.java.dev.genesis.resolvers</code> é utilizada para isto.</p>
      <p>Esta interface expõe um único método, <code>isEmpty(Object)</code>, que
      retorna um <code>boolean</code>. Para especificar qual implementação de
      <code>EmptyResolver</code> deverá ser utilizada para determinado atributo
      basta anotá-lo com <code>@EmptyResolver</code>. A sintaxe desta anotação
      é:</p>
<source>
@EmptyResolver(value=&lt;classeQueImplementaInterface&gt;,
               properties=&lt;atributos&gt;)
</source>
      <p>Para evitar que fosse necessário especificar qual implementação de
      <code>EmptyResolver</code> deveria ser utilizada para cada atributo em
      cada form de uma aplicação, o genesis provê um mecanismo capaz de
      determinar uma implementação padrão com base no tipo do atributo. A classe
      <code>EmptyResolverRegistry</code> mantém um registro das implementações
      padrão de <code>EmptyResolver</code> por classe. As seguintes
      implementações padrão são mantidas inicialmente:</p>
      <ul>
        <li><code>MapEmptyResolver</code> é registrado para instâncias de
        <code>java.util.Map</code>. Considera como vazias instâncias nulas ou
        que retornem <code>true</code> para <code>isEmpty()</code>.</li>
        <li><code>CollectionEmptyResolver</code> é a implementação padrão para
        <code>java.util.Collection</code>. Usa o mesmo princípio que
        <code>MapEmptyResolver</code> para determinar as instâncias vazias.</li>
        <li>A implementação registrada para <code>String</code> é
        <code>StringEmptyResolver</code>. São consideradas vazias instâncias
        nulas ou de tamanho zero após removidos os espaços, i.e.,
        <code>s == null || s.trim().length() == 0</code>.</li>
        <li>Para todos os casos restantes é registrada uma instância de
        <code>DefaultEmptyResolver</code>. Esta implementação considera vazias
        instâncias nulas ou arrays com zero elementos.</li>
      </ul>
      <p>Estas implementações registradas como padrão devem ser suficientes para
      a maioria dos casos. Como exemplo de customização, consideremos o uso da
      anotação em um atributo de form no qual espaços vazios são relevantes:</p>
<source>
@EmptyResolver(properties="trim=false")
public String getAtributo() {
   return atributo;
}
</source>
      <p>Visto que <code>String</code> já possui um <code>EmptyResolver</code>
      padrão registrado, <code>StringEmptyResolver</code>, e que esta
      implementação já expõe um atributo que permite configurar se os espaços
      serão removidos ou não, não é necessário especificar o nome da classe que
      implementa a interface e sim apenas definir a propriedade <code>trim</code>
      como <code>false</code>. Se não fosse possível configurar a instância
      padrão, uma outra implementação poderia ser usada da seguinte forma:</p>
<source>
@EmptyResolver(br.com.empresa.pacote.ImplementacaoEmptyResolver.class)
public String getAtributo() {
   return atributo;
}
</source>
      <subsection name="Verificando se um campo está vazio em expressões
          condicionais">
        <p>Conforme já mencionado, é muito comum determinar condições baseadas
        no fato de um campo estar vazio ou não. O genesis expõe funções de script
        auxiliares que podem ser usadas nas condições com o intuito de facilitar
        esta tarefa: <code>isEmpty(any)</code> e 
        <code>isNotEmpty(any)</code>.</p>
        <p>Quando o valor passado para elas é uma propriedade do form, o
        <code>EmptyResolver</code> configurado para ela - determinado pelo
        processo acima descrito - é utilizado para determinar o retorno da
        função. Caso seja uma variável ou mesmo uma constante, obtém-se de
        <code>EmptyResolverRegistry</code> a implementação padrão de
        <code>EmptyResolver</code> para o tipo da expressão e esta é usada.
        Pode-se utilizar estas funções com a linguagem de script padrão do 
        genesis, <a href="generic_scripting.html">JavaScript</a>, como mostrado 
        abaixo:</p>
<source>
public String getAtributo() {
   return atributo;
}

public void setAtributo(String atributo) {
   this.atributo = atributo;
}

@EnabledWhen("genesis.isNotEmpty('form:atributo')")
public String getAtributoDependente() {
   return atributoDependente;
}

public void setAtributoDependente(String atributoDependente) {
   this.atributoDependente = atributoDependente;
}
</source>
        <p>Note o uso da sintaxe <code>'form:atributo'</code> como parâmetro da
        função. Isso é necessário para que a função seja aplicada para o valor
        de <code>atributo</code> no form, ao invés de utilizar a literal 
        <code>'atributo'</code> como argumento.</p>
        <p>É possível verificar a sintaxe desta função para outras linguagens de
        script no <a href="quick_reference.html#Funções_script_do_genesis">guia 
        de referência rápida de anotações</a>.</p>
      </subsection>
    </section>
  </body>
</document>