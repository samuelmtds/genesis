<?xml version="1.0" encoding="ISO-8859-1"?>
<document>
  <properties>
    <title>Paginação e pesquisas dinâmicas</title>
    <author email="allanjones@dev.java.net">Allan Jones Batista de Castro</author>
    <author email="mister__m@dev.java.net">Michael Nascimento Santos</author>
  </properties>
  <body>
    <section name="Paginação">
      <p>O suporte à paginação está implementado no pacote <code>
      net.java.dev.genesis.paging</code>. As duas classes principais são <code>
      Page</code>, que representa uma página de resultados e <code>Pager</code>,
      que é responsável por gerar as páginas.</p>
      <p>As seguintes propriedades estão expostas em <code>Page</code> através
      de getters e setters:
      <ul>
        <li><b>results</b>: uma <code>java.util.List</code> contendo os
        resultados da página atual.</li>
        <li><b>resultsPerPage</b>: número máximo de resultados por página. <b>
        Não contém</b> o número de resultados da página atual; para obter essa
        informação deve-se chamar o método <code>size()</code> em <code>results
        </code>.</li>
        <li><b>pageNumber</b>: número da página atual, baseado em 0.</li>
        <li><b>first</b>: indica se esta é a primeira página. O mesmo que <code
        >getPageNumber() == 0</code>.</li>
        <li><b>last</b>: indica se esta é a última página. Algumas
        implementações de <code>Pager</code> podem não retornar essa
        propriedade como <code>true</code> quando a última página contiver
        exatamente o número de resultados por página, ou seja, quando
        <code>getResults().size() == getResultsPerPage()</code>.</li>
      </ul></p>
      <p>Enquanto há uma implementação básica para <code>Page</code>
      (<code>PageImpl</code>), não se tem o mesmo para <code>Pager</code>, visto que a
      funcionalidade de um paginador está bastante ligada à origem dos dados que
      este está paginando. Aplicações cliente normalmente não usarão <code>
      PageImpl</code> nem tampouco terão sua própria implementação de <code>Page
      </code>, mas a implementação provida pelo framework pode ser bastante útil
      para implementações específicas de <code>Pager</code>.</p>
      <subsection name="Paginação de listas">
        <p><code>net.java.dev.genesis.paging.ListPager</code> é uma
        implementação de <code>Pager</code> que pode ser usada para gerar
        páginas a partir de instâncias de <code>java.util.List</code>.</p>
        <p>Existem dois construtores para esta classe: um que aceita somente a
        instância de <code>List</code> e outro que aceita também um parâmetro
        booleano indicando se a propriedade <code>results</code> da instância
        de <code>Page</code> retornada deve ser uma referência direta a uma
        subseção da lista - permitindo assim a modificação da lista original
        pelo código cliente - ou uma nova lista. Caso o primeiro construtor
        seja chamado, o valor dessa propriedade será <code>true</code>, o que
        significa que não será possível alterar o objeto original passado no
        construtor utilizando-se o retorno do método.</p>
        <p>Pode-se utilizar esta classe da seguinte maneira:</p>
        <source>
public class ExemploPaginacaoList {
   public Page getSecao(List lista, int numeroPagina, int resultadosPorPagina)
         throws PagingException {
      return new ListPager(lista).getPage(numeroPagina, resultadosPorPagina);
   }
}
</source>
      </subsection>
      <subsection name="Paginação com Hibernate">
        <p>Duas implementação de <code>Pager</code> são providas junto com o
        genesis para integração com Hibernate: <code>CriteriaPager</code> e
        <code>QueryPager</code>, implementados em <code>
        net.java.dev.genesis.paging.hibernate</code>. Essas classes podem tanto
        ser usadas diretamente como de forma mais fácil e indireta em uma classe
        que estenda <code>AbstractHibernateCommand</code>. Como ilustração,
        vamos modificar nosso exemplo do Hibernate de modo a executar a consulta
        retornando uma página:</p>
        <source>
public class ExemploPaginacaoHibernate extends AbstractHibernateCommand {
   @Remotable
   public Page getTodos(int numeroPagina, int resultadosPorPagina)
         throws PagingException {
      return getPage(getSession().createQuery("from ClasseMapeada"),
            numeroPagina, resultadosPorPagina);
   }
}
</source>
        <p>Para se obter as instâncias de <code>ClasseMapeada</code> de dentro
        da página retornada, basta apenas chamar <code>getResults()</code> no
        objeto <code>Page</code> retornado. Essa <code>List</code> - <code>
        getResults()</code> retorna uma <code>List</code>, conforme explicado
        nas propriedades de <code>Page</code>, logo acima - sempre conterá
        elementos do mesmo tipo que estariam presentes numa chamada a <code>
        query.list()</code> ou <code> criteria.list()</code>.</p>
      </subsection>
    </section>
    <section name="Trabalhando com pesquisas dinâmicas">
      <p>O genesis facilita a construção de pesquisas dinâmicas - cujos
      critérios de seleção mudam em tempo de execução, não os valores passados
      para estes - integrando essa funcionalidade tanto com os componentes de
      interface gráfica como com os componentes de negócio. Abaixo, mostraremos
      o suporte a pesquisas dinâmicas com Hibernate, e na seqüência, como é o 
      suporte na parte cliente.</p>
      <subsection name="Pesquisas dinâmicas com Criteria">
        <p>Embora o Hibernate possua suporte a pesquisas dinâmicas, isto é, com
        cláusulas "montadas" ou definidas em tempo de execução através da
        interface <code>Criteria</code>, o uso prático desse suporte básico leva a
        código bastante repetitivo e difícil de manter. O genesis possui suporte a
        pesquisas dinâmicas num nível de abstração mais alto, o que facilita a
        implementação delas. Abordaremos aqui o uso desse suporte com foco na
        camada de negócios.</p>
        <p>Existe uma subinterface de <code>HibernateCommand</code> chamada <code>
        HibernateCriteria</code>. Assim como a <code>Session</code> é injetada
        para instâncias de <code>HibernateCommand</code>, uma instância de
        <code>Criteria</code> é atribuída através do método
        <code>setCriteria(Criteria)</code> para implementações de
        <code>HibernateCriteria</code> nos momentos apropriados. Da mesma forma
        que ocorre com a primeira interface, existe uma classe base para facilitar
        a implementação de <code>HibernateCriteria</code>,
        <code>AbstractHibernateCritcodeeria</code>. Esta classe auxiliar define o
        método <code>getCriteria()</code>, além de outros métodos utilitários.</p>
        <p>O método de negócio que precisa da instância de <code>Criteria</code>
        para sua execução recebe a anotação <code>@Criteria(value=
        &lt;ClasseMapeadaNoHibernate&gt;.class,
        order-by={&lt;propriedades&gt;})</code>.
        Essa anotação implica que o método também é <code>@Remotable</code>,
        mantendo assim a remotabilidade transparente. Antes de invocar este
        método e depois de ter invocado <code>setCriteria(Criteria)</code>, os
        setters das propriedades "preenchidas" do objeto de negócio que tenham
        sido copiadas no cliente (ver documentação do
        <a href="conditions.html#Determinando_se_o_campo_está_vazio">Determinando se o campo está vazio</a>) serão automaticamente chamados
        pelo framework de modo que a recém-injetada instância de
        <code>Criteria</code> possa ser configurada apropriadamente. Finalmente o
        método de negócios será invocado e seu retorno repassado ao código
        cliente.</p>
        <p>Para entender melhor esse conceito, o exemplo abaixo pode ser de ajuda.
        Supondo-se que existe uma classe <code>Pessoa</code> mapeada via
        Hibernate, que, entre outros atributos, possua <code>nome</code> e <code>
        sobrenome</code>, que são os critérios de pesquisa, podemos implementar
        uma pesquisa dinâmica e paginada sobre a classe da seguinte forma:</p>
<source>
public class PesquisaPessoa extends AbstractHibernateCriteria {
   public void setNome(String nome) {
      getCriteria().add(Expression.ilike("nome", nome, MatchMode.START));
   }

   public void setSobrenome(String sobrenome) {
      getCriteria().add(Expression.ilike("sobrenome", sobrenome,
            MatchMode.START));
   }

   @Criteria(value=meupacote.Pessoa.class, orderby={"nome", "sobrenome asc"})
   public Page getPessoas(int numeroPagina) throws PagingException {
      return getPage(numeroPagina);
   }
}
</source>
        <p>Uma vez tendo copiado as propriedades do formulário para o objeto de
        negócios, a seguinte seqüência de
        eventos ocorre quando o método <code>getPessoas(int)</code> é invocado:
        <ul>
          <li>A instância é transferida pelo servidor através da remotabilidade
          transparente.</li>
          <li>É injetada a sessão do Hibernate através da chamada a <code>
          setSession(Session)</code>, definida em <code>HibernateCommand</code>.
          </li>
          <li>É criado um <code>Criteria</code> tendo como base a entidade
          persistente <code>Pessoa</code>, conforme informado na anotação <code>
          @Criteria</code>.</li>
          <li>A instância de <code>Criteria</code> é injetada através de chamada a
          <code>setCriteria(Criteria)</code>, definido em <code>HibernateCriteria
          </code>.</li>
          <li>Os setters das propriedades que estavam preenchidas no form no
          momento da cópia são chamados. A classe <code>PesquisaPessoa</code> tem
          então a chance de restringir o <code>Criteria</code> somente para os
          campos de busca, sem ter de se preocupar se o campo foi preenchido ou
          não, já que o genesis garante que se o setter foi chamado, o campo foi
          preenchido.</li>
          <li>Finalmente, o método <code>getPessoas(int)</code> é chamado e o
          resultado retornado para o cliente de forma transparente.</li>
        </ul>
        </p>
        <p>Para casos específicos, é possível utilizar a anotação sem informar o 
        nome da classe mapeada no Hibernate. Neste caso, a instância de 
        <code>Criteria</code> não será criada e o valor injetado na classe será 
        <code>null</code>, mas o resto do comportamento descrito acima será 
        mantido. Isto é útil quando é necessário realizar pesquisas dinâmicas 
        complexas que não podem ser implementadas com <code>Criteria</code>.</p>
      </subsection>
      <subsection name="Pesquisas dinâmicas no codigo cliente">
        <p>Na parte cliente, para permitir que somente as propriedades prenchidas
        sejam utilizadas na busca, basta fazer:</p>
<source>
CriteriaPropertyHelper.fillCriteria(hibernateCriteria, form);
</source>
        <p>A classe <code>CriteriaPropertyHelper</code> encontra-se no pacote
        <code>net.java.dev.genesis.helpers</code>. <code>hibernateCriteria</code>
        deve obedecer os
        <a href="#Pesquisas dinâmicas com Criteria">requisitos para pesquisas dinâmicas</a>
        explicado anteriormente, enquanto <code>form</code> deve ser um form do genesis válido.
        Serão copiadas as propriedades que existam em ambos os beans e que estejam
        preenchidas no form de acordo com as
        <a href="conditions.html#Determinando_se_o_campo_está_vazio">regras para determinar
        campos vazios</a>. A chamada a <code>fillCriteria(HibernateCriteria,
        Object)</code> deverá ser feita antes da chamada ao método anotado com
        <code>@Criteria</code>.</p>
        <p>Para tornar ainda mais simples a construção de pesquisas dinâmicas com
        resultados paginados, duas classes auxiliares são definidas no pacote
        <code>net.java.dev.genesis.ui.paging</code>: <code>BaseSearchForm</code> e
        <code>BaseCriteriaSearchForm</code>. Estas classes abstratas podem ser
        estendidas pelos forms, diminuindo o esforço de implementação.</p>
        <p><code>BaseSearchForm</code> contém lógica relacionada com a paginação,
        além de abstrair o processo de execução da pesquisa. Algumas ações e
        propriedades podem ser utilizadas diretamente na construção da interface
        gráfica:</p>
        <ul>
          <li><code>previousPage()</code> e <code>nextPage()</code> são ações do
          genesis que podem ser ligadas aos botões na tela que navegarão para a
          página anterior e a próxima página de resultados, respectivamente.
          Possuem anotações <code>@VisibleWhen</code> que ocultarão os widgets
          nas situações corretas.</li>
          <li><code>pageNumber</code> é a propriedade que contém o número da
          página de resultados atual.</li>
        </ul>
        <p>Esta classe também define o método abstrato <code>performSearch()</code
        >, que retorna uma instância de
        <code>net.java.dev.genesis.paging.Page</code> e expõe a propriedade
        <code>runSearch</code>, que deve ser usada na expressão condicional de
        execução da busca nas subclasses. Normalmente, não será necessário
        utilizá-la diretamente, já que <code>BaseCriteriaSearchForm</code> provê
        um nível de abstração maior quando a pesquisa é realizada por uma
        implementação de <code>HibernateCriteria</code>. Neste caso, bastará
        implementar os métodos <code>getHibernateCriteria()</code> de modo a
        retornar o objeto de negócios - que receberá os critérios de busca através
        de uma  chamada a <code>CriteriaPropertyHelper</code> - e o método
        <code>performSearch(int pageNumber)</code>, que efetuará a pesquisa.
        Abaixo encontra-se um exemplo de seu uso extraído do useradmin. Primeiro,
        vemos o trecho de código relevante do form:</p>
<source>
@Form
public class UserListForm extends BaseCriteriaSearchForm {
   private final UserSearchCommand command = new UserSearchCommand();

   // codigo para getters e setters de criterios de pesquisa

   public String getName() { /* ... */ }

   public void setName(String name) { /* ... */ }

   public String getEmail() { /* ... */ }

   public void setEmail(String email) { /* ... */ }
  
   public String getLogin() { /* ... */ }

   public void setLogin(String login) { /* ... */ }
  
   protected HibernateCriteria getHibernateCriteria() {
      return command;
   }

   protected Page performSearch(int pageNumber) throws Exception {
      return command.getUsers(pageNumber);
   }

   @Action
   @CallWhen("form.runSearch")
   @DataProvider(objectField="users", callOnInit=false)
   public List doSearch() throws Exception {
      search();

      return getPage().getResults();
   }

   // codigo restante
</source>
        <p>E o uso das ações para os botões de navegação na interface
        gráfica:</p>
        <p><b>Thinlet:</b></p>
<source>
<![CDATA[
<button name="doSearch" halign="right" text="i18n.button.search" font="bold" mnemonic="0" type="default"/>
 
... 
<button name="previousPage" text="<<" font="bold" type="default" alignment="left"/>
<button name="nextPage" text=">>" font="bold" type="default" alignment="right"/>
]]>
</source>
        <p><b>Swing:</b></p>
<source>
<![CDATA[
searchButton = new JButton(getMessage("button.search"));
searchButton.setName("doSearch");

...  
previousPage = new JButton("<<");
previousPage.setName("previousPage");

...
nextPage = new JButton(">>");
nextPage.setName("nextPage");
]]>
</source>
        <p><b>SWT:</b></p>
<source>
<![CDATA[
searchButton = new Button(shell, SWT.NONE);
searchButton.setText(getMessage("button.search"));
searchButton.setData(SWTBinder.NAME_PROPERTY, "doSearch");

...  
previousPage = new Button(shell, SWT.NONE);
previousPage.setText("<<");
previousPage.setData(SWTBinder.NAME_PROPERTY, "previousPage");

...
nextPage = new Button(shell, SWT.NONE);
nextPage.setText(">>");
nextPage.setData(SWTBinder.NAME_PROPERTY, "nextPage");
]]>
</source>
        <p>E a classe de negócio:</p>
<source>
public class UserSearchCommand extends AbstractHibernateCriteria {
   public void setEmail(String email) {
      getCriteria().add(Expression.ilike("email", email, MatchMode.START));
   }

   public void setLogin(String login) {
      getCriteria().add(Expression.ilike("login", login, MatchMode.START));
   }

   public void setName(String name) {
      getCriteria().add(Expression.ilike("name", name, MatchMode.START));
   }
   
   @Criteria(value=User.class, orderby="name")
   public Page getUsers(final int pageNumber) throws Exception {
      return getPage(pageNumber);
   }
}
</source>
      </subsection>
    </section>

  </body>
</document>
