<?xml version="1.0" encoding="ISO-8859-1"?>
<document>
  <properties>
    <title>Aspectos do genesis</title>
    <author email="mister__m@dev.java.net">Michael Nascimento Santos</author>
  </properties>
  <body>
    <section name="Aspectos do genesis">
      <p>Uma parte significativa das funcionalidades do genesis é implementada
      via aspectos. Através da AOP é possível estender de forma significativa
      tais funcionalidades sem que o código de negócio e de interface gráfica
      tenha de ser reescrito. Esta seção da documentação tem como objetivo
      descrever os aspectos para que usuários mais avançados possam entender e
      customizar seu funcionamento. É necessário conhecer bem AOP, AspectWerkz,
      EJB e Thinlet para total compreensão.</p>
      <ul>
        <li><a href="#Determinando métodos remotos e transacionais">Determinando
        métodos remotos e transacionais</a></li>
        <li><a href="#Executando métodos remotos e transacionais">Executando
        métodos remotos e transacionais</a></li>
        <li><a href="#Executando pesquisas dinâmicas">Executando pesquisas
        dinâmicas</a></li>
        <li><a href="#Limitando o tempo de execução de um método">Limitando o
        tempo de execução de um método</a></li>
        <li>
        <a href="#Trocando o cursor do mouse durante o tratamento de eventos">
        Trocando o cursor do mouse durante o tratamento de eventos</a></li>
        <li><a href="#Instanciando os metadados">Instanciando os metadados</a>
        </li>
        <li><a href="#Referência de configuração">Referência de configuração</a>
        </li>
      </ul>
    </section>
    <section name="Determinando métodos remotos e transacionais">
      <p>A interface <code>CommandResolver</code>, definida no pacote
      <code>net.java.dev.genesis.aspect</code>, é utilizada para determinar se
      um método é remoto ou transacional. Abaixo, vemos a parte relevante da
      definição desta interface:</p>
<source>
public interface CommandResolver {
   public boolean isRemotable(Method m);
   public boolean isTransactional(Method m);
}
</source>
      <p>O aspecto <code>CommandInvocationAspect</code>, do mesmo pacote, provê
      uma implementação dessa interface como classe interna,
      <code>CommandResolverImpl</code>, que baseia-se na presença das anotações
      <code>@Remotable</code> e <code>@Transactional</code> - ou no fato das
      classes que contém os métodos implementarem <code>Query</code> e
      <code>Transaction</code>, interfaces legadas do genesis 0.1 que não devem
      ser mais utilizadas - para determinar se um método é remoto ou
      transacional.</p>
      <p>Caso o parâmetro do aspecto de nome <code>useFastMode</code> for
      definido como <code>true</code> - esse é o valor padrão deste parâmetro -,
      qualquer método será considerado no mínimo remoto, visto que na
      configuração padrão do arquivo aop.xml somente métodos remotos e
      transacionais são selecionados pelo pointcut de execução. Essa
      implementação é introduzida nas classes selecionadas
      pelo pointcut de nome <code>commandResolverIntroduction</code>.</p>
      <p>Caso seja necessário determinar se um método é remoto ou transacional
      de outra forma - utilizando-se uma definição xml externa ao invés de
      anotações, por exemplo -, basta prover uma nova implementação de
      <code>CommandResolver</code> com o critério desejado e introduzi-la nas
      classes de negócio.</p>
    </section>
    <section name="Executando métodos remotos e transacionais">
      <p>Os métodos remotos e transacionais têm sua execução interceptada por
      aspectos, de modo que as instâncias possam ser transferidas (ou não, como
      veremos) para o servidor e que um contexto transacional apropriado possa
      ser utilizado. Além disso, é feita também a injeção de dependências antes
      da execução.</p>
      <p>Dois componentes são utilizados para isso: um aspecto e uma
      implementação de
      <code>net.java.dev.genesis.command.TransactionalInjector</code>. A
      interface <code>TransactionalInjector</code> é definida como:</p>
<source>
public interface TransactionalInjector {
   public void init(Object context);
   public void beforeInvocation(Object target, boolean transactional)
                                                          throws Exception;
   public void afterInvocation() throws Exception;
   public void onException(Exception e);
   public void onFinally() throws Exception;
}
</source>
      <p>A implementação da interface é utilizada pelos aspectos de forma bem
      definida, como segue:</p>
      <ol>
        <li>Logo após a instanciação, o método <code>init(Object)</code> é
        chamado passando-se um objeto de contexto, específico por modo de
        execução - local, em EJB etc. - que permite a instância recém-criada ler
        configurações do usuário.</li>
        <li>O método <code>beforeInvocation(Object,boolean)</code> é invocado
        antes de cada execução de um método remoto e transacional, passando-se o
        objeto no qual o método será chamado e o estado transacional da chamada.
        É neste momento que eventuais dependências deverão ser injetadas e que a
        transação deverá ser iniciada se necessário.</li>
        <li><code>afterInvocation()</code> só é chamado quando a execução do
        método transcorre normalmente, i.e., sem que seja lançada uma exceção. É
        o momento em que a transação deve ser comitada.</li>
        <li>Chama-se <code>onException(Exception)</code> caso seja lançada uma
        exceção em <code>beforeInvocation(Object,boolean)</code> ou durante a
        execução do método remoto/transacional. É o momento para fazer rollback
        da transação.</li>
        <li>O método <code>onFinally()</code> sempre é chamado e deve liberar
        quaisquer recursos alocados durante a execução.</li>
      </ol>
      <p>Cada instância de <code>TransactionalInjector</code> será utilizada por
      somente uma Thread.</p>
      <p>Utilizando-se aspectos e implementações específicas de
      <code>TransactionalInjector</code> é possível customizar totalmente a
      forma como as transações são executadas e fazer qualquer tipo de injeção
      de dependências nos componentes de negócio. Dois poderosos modos de
      execução são providos juntamente com o genesis e explicados abaixo.</p>
      <subsection name="Execução local">
        <p>A execução local é feita pelo aspecto
        <code>LocalCommandExecutionAspect</code>. Basicamente, este aspecto
        delega a maior parte das responsabilidades para a implementação de <code
        >TransactionalInjector</code>, como mostra o texto de código a seguir:
        </p>
<source>
try {
   injector.beforeInvocation(obj, transactional);
   final Object ret = joinPoint.proceed();
   injector.afterInvocation();

   return ret;
} catch (final Exception e) {
   injector.onException(e);

   throw e;
} finally{
   injector.onFinally();
}
</source>
        <p>O pointcut <code>localCommandExecution</code> é utilizado para
        definir a execução de quais métodos deve ser interceptada pelo advice
        <code>commandExecution(JoinPoint)</code>. A implementação de
        <code>TransactionalInjector</code> pode ser configurada com o parâmetro
        do aspecto de nome <code>transactionalInjector</code>. O objeto de
        contexto passado para o método <code>init(Object)</code> da
        implementação será a instância de <code>CrossCuttingInfo</code>
        recebida.</p>
        <p>A classe <code>HibernateTransactionalInjector</code>, que, assim como
        o aspecto, está definida em <code>net.java.dev.genesis.aspect</code> é
        uma implementação de <code>TransactionalInjector</code> apropriada para
        este cenário. Ela introduz uma sessão do Hibernate nas classes que
        implementam
        <code>net.java.dev.genesis.command.hibernate.HibernateCommand</code> e
        controla a transação utilizando os recursos da própria sessão.</p>
      </subsection>
      <subsection name="Execução em EJB com chamada remota">
        <p>Outra possibilidade de execução provida diretamente com o genesis é
        por se executar a chamada dentro de um Stateless Session Bean,
        utilizando-se transações gerenciadas pelo container (CMT, container
        managed transactions). O aspecto <code>EJBCommandExecutionAspect</code>
        faz isto pro invocar os métodos
        <code>executeTransaction(Object,String,String[],Object[])</code> e
        <code>executeQuery(Object,String,String[],Object[])</code> no EJB cuja
        interface remota é
        <code>net.java.dev.genesis.ejb.CommandExecutor</code>. Os parâmetros
        passados para ambos os métodos são, respectivamente, a instância em que
        o método será executado, o nome do método, os nomes das classes da
        assinatura do método e os valores passados para a invocação.</p>
        <p>O advice <code>commandExecution(JoinPoint)</code> é que fará a
        chamada remota ao Session Bean. O pointcut de nome
        <code>ejbCommandExecution</code> é utilizado para selecionar a execução
        de quais métodos deverá ser realizada desta forma. O parâmetro do
        aspecto de nome <code>jndiName</code> contém o endereço JNDI da home do
        EJB, enquanto que o parâmetro booleano <code>retryOnNoSuchObject</code>
        indica se a execução deverá ser feita novamente, somente mais uma vez,
        ao receber uma <code>java.rmi.NoSuchObjectException</code> (que ocorre
        quando o servidor de aplicações é reiniciado).</p>
        <p>Visto que a execução do método ocorre dentro do Session Bean, é no
        servidor que estará a implementação de <code>TransactionalInjector</code
        >, que pode ser especificada pela env-entry de mesmo nome,
        <code>TransactionalInjector</code>. Para o método <code>init(Object)
        </code>, o objeto de contexto passado é a instância de <code>
        SessionContext</code> do Session Bean.</p>
        <p>A implementação <code>
        net.java.dev.genesis.ejb.hibernate.EJBHibernateTransactionalInjector
        </code> contida no genesis é própria para uso nesta configuração. No seu
        método <code>init(Object)</code> localiza-se a implementação da
        <code>SessionFactory</code> do Hibernate no endereço JNDI especificado
        como valor para a env-entry <code>HibernateFactoryAddress</code>. O
        mecanismo de transação utilizado é JTA, já que os métodos expostos do
        EJB são todos CMT. O rollback será realizado, quando necessário, por uma
        chamada a <code>setRollbackOnly()</code> na instância de
        <code>SessionContext</code>.</p>
      </subsection>
    </section>
    <section name="Executando pesquisas dinâmicas">
      <p>As pesquisas dinâmicas, ou seja, classes que recebem injeção de uma
      instância de <code>Criteria</code> e possuem os setters correspondentes
      aos critérios de pesquisa não-vazios invocados antes da pesquisa
      propriamente dita, são executados através do aspecto
      <code>net.java.dev.genesis.aspect.CriteriaCommandExecutionAspect</code>.
      </p>
      <p>Toda classe interceptada por este aspecto precisa implementar
      <code>net.java.dev.genesis.command.hibernate.CriteriaResolver</code>,
      abaixo transcrita:</p>
<source>
public interface CriteriaResolver {
   public Map getPropertiesMap();
   public void setPropertiesMap(final Map propertiesMap);
}
</source>
      <p>O método <code>setPropertiesMap(Map)</code> será chamado na parte
      cliente passando somente os dados que deverão ser utilizados para
      pesquisa. Normalmente este método será chamado indiretamente pelo cliente
      através do método utilitário
      <code>fillCriteria(HibernateCriteria,Object)</code> da classe
      <code>net.java.dev.genesis.helpers.CriteriaPropertyHelper</code>.</p>
      <p>O pointcut de nome <code>criteriaResolverIntroduction</code> define que
      classes deverão receber como introdução a implementação da interface de
      nome <code>CriteriaResolverImpl</code>, que é uma classe estática interna
      do aspecto. Esta implementação utiliza uma variável membro do tipo
      <code>java.util.Map</code> para guardar e expor a informação.</p>
      <p>O pointcut de nome <code>criteriaCommandExecution</code> define os
      métodos que serão interceptados pelo advice
      <code>commandExecution(JoinPoint)</code>. Este método lê através do método
      <code>getPropertiesMap()</code> de <code>CriteriaResolver</code> quais as
      propriedades utilizadas no método de pesquisa e faz uso desta informação,
      assim como também a assinatura e os parâmetros da chamada do método para
      instanciar
      <code>net.java.dev.genesis.command.hibernate.CriteriaCommandExecutor</code
      >. Na nova instância será chamado o método <code>execute()</code>, que
      possui uma anotação <code>@Remotable</code> e será interceptado para <a
      href="#Execução em EJB com chamada remota">execução remota</a>. Este
      método inicializa o <code>Criteria</code> (quando o nome da classe mapeada
      é informado), injeta-o na instância, invoca os setters dos critérios de
      pesquisa e chama o método de pesquisa.</p>
    </section>
    <section name="Limitando o tempo de execução de um método">
      <p>O aspecto <code>TimeoutAspect</code> permite controlar o tempo limite
      para execução de um método; caso este seja ultrapassado, uma
      <code>net.java.dev.genesis.exception.TimeoutException</code> será lançada.
      </p>
      <p>O tempo limite é configurado pelo parâmetro do aspecto de nome
      <code>timeout</code>. O pointcut de nome <code>timeout</code> seleciona os
      métodos cuja execução será interceptada pelo advice
      <code>timeoutAdvice(JoinPoint)</code>. O advice executa o método
      interceptado numa outra thread e aguarda seu término por
      <code>timeout</code> segundos. Qualquer exceção que seria normalmente
      lançada pelo método interceptado é repassada para quem o chamou.</p>
    </section>
    <section name="Trocando o cursor do mouse durante o tratamento de eventos">
      <p>Com o intuito de que o usuário perceba que uma operação longa está
      sendo executada, o <code>WaitCursorAspect</code> permite trocar o cursor
      do mouse para o cursor de espera durante um método de tratamento de evento
      da interface gráfica.</p>
      <p>O pointcut <code>waitCursorExecution</code> especifica quais métodos
      implementam o tratamento de eventos e devem ser interceptados pelo advice
      de mesmo nome - <code>waitCursorExecution(JoinPoint)</code>. Este advice
      salva o cursor atual, troca-o para o cursor de espera e restaura o cursor
      original quando o tratamento de eventos termina. Espera-se que os métodos
      interceptados pertençam a uma instância de
      <code>java.awt.Component</code>, onde estão definidos métodos para obter e
      definir o cursor em uso.</p>
    </section>
    <section name="Instanciando os metadados">
      <p>Todo o binding de uma form com a view baseia-se em metadados das duas
      partes. Este modelo de metadados encontra-se no pacote
      <code>net.java.dev.genesis.ui.metadata</code> para o form e no pacote
      <code>net.java.dev.genesis.ui.thinlet.metadata</code> para a view. Em
      ambos os pacotes, existem interfaces - <code>FormMetadataFactory</code> e
      <code>ThinletMetadataFactory</code>, respectivamente -, que devem ser
      implementadas pelas classes responsáveis por retornar estes metadados.
      Abaixo, segue uma transcrição dos trechos relevantes de ambas:</p>
<source>
public interface FormMetadataFactory {
    public FormMetadata getFormMetadata(Class formClass);
}
</source>
<source>
public interface ThinletMetadataFactory {
   public ThinletMetadata getThinletMetadata(Class formClass);
}
</source>
      <p>Os aspectos <code>FormMetadataFactoryAspect</code> e
      <code>ThinletMetadataFactoryAspect</code> definem implementações destas
      interfaces com bases em anotações. As implementações chamam-se
      <code>AspectFormMetadataFactory</code> e
      <code>AspectThinletMetadataFactory</code> e são classes estáticas internas
      de seus respectivos aspectos. As classes que precisam receber tais
      introduções são selecionadas pelos pointcuts de nome
      <code>formMetadataFactoryIntroduction</code> e
      <code>thinletMetadataFactoryIntroduction</code>. Para sobrescrever a forma
      com que os metadados são criados - usando-se xml, por exemplo - basta
      introduzir uma implementação diferente dessas interfaces nos forms e nas
      views.</p>
    </section>
    <section name="Referência de configuração">
      <p>Abaixo encontram-se algumas tabelas úteis para o desenvolvedor
      avançado, além de uma configuração padrão suficiente para a maioria dos
      casos.</p>
      <subsection name="Parâmetros">
        <table>
          <tr>
            <th>Aspecto</th>
            <th>Nome</th>
            <th>Tipo</th>
            <th>Descrição</th>
            <th>Obrigatório</th>
            <th>Valor padrão</th>
          </tr>
          <tr>
            <td>CommandInvocationAspect</td>
            <td>useFastMode</td>
            <td>boolean</td>
            <td>Define se o processo que determina se um método é remoto ou não
            será realmente executado ou se todo método interceptado será
            considerado no mínimo remoto</td>
            <td><b>Sim</b></td>
            <td><code>true</code></td>
          </tr>
          <tr>
            <td>CriteriaCommandExecutionAspect</td>
            <td>useOriginalMethod</td>
            <td>boolean</td>
            <td>Define como o nome do método que deve ser executado será obtido
            da instância de <code>MethodJoinPoint</code>. Deve ser
            <code>true</code> para os modos de execução locais</td>
            <td>Não</td>
            <td><code>false</code></td>
          </tr>
          <tr>
            <td rowspan="2">EJBCommandExecutionAspect</td>
            <td>jndiName</td>
            <td>String</td>
            <td>Endereço JNDI em que se pode obter uma instância da classe
            <code>net.java.dev.genesis.ejb.CommandExecutorHome</code></td>
            <td><b>Sim</b></td>
            <td>Não possui</td>
          </tr>
          <tr>
            <td>retryOnNoSuchObject</td>
            <td>boolean</td>
            <td>Indica se o método deve ser executado novamente se uma
            <code>java.rmi.NoSuchObjectException</code> ocorrer</td>
            <td>Não</td>
            <td><code>true</code></td>
          </tr>
          <tr>
            <td>LocalCommandExecutionAspect</td>
            <td>transactionalInjector</td>
            <td>Nome qualificado completo de classe</td>
            <td>Nome de uma classe que implemente
            <code>net.java.dev.genesis.command.TransactionalInjector</code></td>
            <td><b>Sim</b></td>
            <td>Não possui</td>
          </tr>
          <tr>
            <td>TimeoutAspect</td>
            <td>timeout</td>
            <td>long</td>
            <td>Número máximo de milisegundos em que o método pode ser executado
            </td>
            <td><b>Sim</b></td>
            <td>Não possui</td>
          </tr>
        </table>
      </subsection>
      <subsection name="Pointcuts nomeados">
        <p>Os pointcuts nomeados só estarão disponíveis quando o jar anotado for
        utilizado e, nessas condições, atribuir-lhes um valor será obrigatório
        caso o aspecto que os define for utilizado.</p>
        <table>
          <tr>
            <th>Aspecto</th>
            <th>Nome</th>
            <th>Tipo</th>
            <th>Descrição</th>
          </tr>
          <tr>
            <td>CommandInvocationAspect</td>
            <td>commandResolverIntroduction</td>
            <td>Classe</td>
            <td>Introduz a interface
            <code>net.java.dev.genesis.aspect.CommandResolver</code> com a
            implementação
            <code>CommandInvocationAspect$CommandResolverImpl</code></td>
          </tr>
          <tr>
            <td rowspan="2">CriteriaCommandExecutionAspect</td>
            <td>criteriaCommandExecution</td>
            <td>Método</td>
            <td>Intercepta a execução de métodos de pesquisa dinâmica</td>
          </tr>
          <tr>
            <td>criteriaResolverIntroduction</td>
            <td>Classe</td>
            <td>Introduz a interface
            <code>net.java.dev.genesis.command.hibernate.CriteriaResolver</code>
            com a implementação
            <code>CriteriaCommandExecutionAspect$CriteriaResolverImpl</code></td
            >
          </tr>
          <tr>
            <td>EJBCommandExecutionAspect</td>
            <td>ejbCommandExecution</td>
            <td>Método</td>
            <td>Intercepta a execução de métodos remotos e transacionais e
            transfere a instância sobre a qual o método foi invocado para o
            servidor</td>
          </tr>
          <tr>
            <td>FormMetadataFactoryAspect</td>
            <td>formMetadataFactoryIntroduction</td>
            <td>Classe</td>
            <td>Introduz a interface
            <code>net.java.dev.genesis.ui.metadata.FormMetadataFactory</code>
            com a implementação
            <code>FormMetadataFactoryAspect$AspectFormMetadataFactory</code></td
            >
          </tr>
          <tr>
            <td>LocalCommandExecutionAspect</td>
            <td>localCommandExecution</td>
            <td>Método</td>
            <td>Intercepta a execução de métodos remotos e transacionais e
            executa-os localmente</td>
          </tr>
          <tr>
            <td>ThinletMetadataFactoryAspect</td>
            <td>thinletMetadataFactoryIntroduction</td>
            <td>Classe</td>
            <td>Introduz a interface
            <code>
            net.java.dev.genesis.ui.thinlet.metadata.ThinletMetadataFactory
            </code>
            com a implementação
            <code>ThinletMetadataFactoryAspect$AspectThinletMetadataFactory
            </code></td>
          </tr>
          <tr>
            <td>TimeoutAspect</td>
            <td>timeout</td>
            <td>Método</td>
            <td>Intercepta a execução de um método de modo que este execute em
            um tempo limite ou seja lançada uma exceção</td>
          </tr>
          <tr>
            <td>WaitCursorAspect</td>
            <td>waitCursorExecution</td>
            <td>Método</td>
            <td>Muda o cursor do mouse para o cursor de espera enquanto a
            execução do método interceptado não for finalizada</td>
          </tr>
        </table>
      </subsection>
      <subsection name="Configuração exemplo de aop.xml">
        <p>A configuração do exemplo useradmin é mostrada abaixo. Pode ser
        necessário ajustá-la de acordo com as necessidades do projeto, mas
        acreditamos que essa configuração será suficiente na maior parte dos
        casos.</p>
<source>
<![CDATA[
<!DOCTYPE aspectwerkz PUBLIC
      "-//AspectWerkz//DTD 1.0//EN"
      "http://aspectwerkz.codehaus.org/dtd/aspectwerkz_1_0.dtd">
<aspectwerkz>
   <system id="useradmin" base-package="net.java.dev.genesis.aspect">
      <!-- helpers pointcuts -->
      <pointcut name="executeCommand"
                expression="execution(@Remotable * ...*(..)) OR
                execution(@Transactional * ...*(..))" />
      <pointcut name="form" expression="within(@Form ..)" />

      <!-- Genesis pointcuts -->
      <pointcut name="formMetadataFactoryIntroduction" expression="form" />
      <pointcut name="thinletMetadataFactoryIntroduction"
                expression=
                "within(net.java.dev.genesis.ui.thinlet.BaseThinlet+)" />
      <pointcut name="criteriaResolverIntroduction"
                expression=
                "within(net.java.dev.genesis.command.hibernate.HibernateCriteria
                +)" />
      <pointcut name="commandResolverIntroduction"
                expression="hasmethod(@Remotable * ...*(..)) OR
                hasmethod(@Transactional * ...*(..))" />
      <pointcut name="timeout" expression="executeCommand" />
      <pointcut name="ejbCommandExecution" expression="executeCommand" />
      <pointcut name="criteriaCommandExecution"
                expression="execution(@Criteria *
                net.java.dev.genesis.command.hibernate.HibernateCriteria+.*(..))
                " />
      <pointcut name="waitCursorExecution"
                expression="execution(* thinlet.Thinlet.invokeImpl(..))" />

      <!-- Genesis Aspects -->
      <aspect class="CommandInvocationAspect" />
      <aspect class="FormMetadataFactoryAspect" />
      <aspect class="ThinletMetadataFactoryAspect" />
      <aspect class="TimeoutAspect">
         <param name="timeout" value="60000" />
      </aspect>
      <aspect class="EJBCommandExecutionAspect">
         <param name="jndiName" value="ejb/CommandExecutor"/>
      </aspect>
      <aspect class="CriteriaCommandExecutionAspect"/>
      <aspect class="WaitCursorAspect"/>
   </system>
</aspectwerkz>
]]>
</source>
      </subsection>
    </section>
  </body>
</document>