<?xml version="1.0" encoding="ISO-8859-1"?>
<document>
  <properties>
    <title>Populando combos, listas e tabelas</title>
    <author email="mister__m@dev.java.net">Michael Nascimento Santos</author>
    <author email="allanjones@dev.java.net">Allan Jones Batista de Castro</author>
  </properties>
  <body>
    <section name="Populando combos, listas e tabelas">
      <p>As opções disponíveis em um combo box podem variar de acordo com os
      dados preenchidos pelo usuário ou outras regras de negócio. O conteúdo de
      uma tabela pode precisar ser preenchido dinamicamente em resposta a um
      critério de filtro especificado pelo usuário, por exemplo. Para lidar com
      tais situações, existe uma anotação chamada <code>@DataProvider</code>,
      cuja sintaxe é:</p>
<source>
@DataProvider(objectField="nomeCampoObjeto",
              indexField="nomeCampoIndice",
              widgetName="nomeCampo",
              callOnInit=valorBooleano
              resetSelection=valorBooleano)
</source>
      <p>Esta anotação deve ser colocada em métodos que retornam uma
      <code>java.util.List</code> ou uma array de Objetos.
      O retorno dos métodos será utilizado para popular a combobox, lista ou tabela.
      <code>objectField</code> deve
      receber o nome da propriedade em seu form, se houver, que guardará a instância
      (ou instâncias, em caso de múltipla seleção) selecionada no widget.
      Deve ser do mesmo tipo ou uma superclasse do tipo
      retornado no método anotado, uma array do tipo ou uma
      <code>Collection</code>. <code>indexField</code> é o nome da propriedade em
      seu form que guardará os índices dos elementos selecionados no widget.
      Deve ser um <code>int</code> ou um <code>Integer</code>, uma array de um desses tipos
      ou uma <code>Collection</code>. No caso de <code>widgetName</code>,
      se utilizado, deve receber o nome do componente gráfico que representa
      a lista, combo ou tabela que receberá os valores retornados pelo método anotado
      No caso do Thinlet, o widgetName deve ser o mesmo do widget definido no xml da view.
      No caso do Swing, o widgetName deve ser o nome do referido Component.
      <b>Pelo menos uma dessas três propriedades deve ser
      informado</b>.</p>
      <p>O <code>name</code> do widget na tela é igual ao nome da propriedade
      informada como <code>widgetName</code>, <code>objectField</code>
      ou <code>indexField</code>, sendo esta a ordem de prioridade para
      determinação do nome.</p>
      <p>Como mencionado acima, <code>objectField</code> e
      <code>indexField</code> recebem um nome de propriedade que pode retornar
      um bean, uma array ou uma <code>Collection</code>. Vejamos quando cada
      tipo poderá ser utilizado:</p>
      
      <subsection name="Seleção Única">
        <table>
          <tr>
            <th>Tipo de Retorno do Método anotado</th>
            <th>objectField</th>
            <th>indexField</th>
          </tr>
          <tr>
            <td><code>java.util.List</code> ou array de objetos</td>
            <td>Qualquer classe (não pode ser tipo primitivo)</td>
            <td>Apenas <code>Integer</code> ou tipo primitivo <code>int</code></td>
          </tr>
        </table>
      </subsection>

      <subsection name="Seleção Múltipla">
        <table>
          <tr>
            <th>Tipo de Retorno do Método anotado</th>
            <th>objectField</th>
            <th>indexField</th>
          </tr>
          <tr>
            <td><code>java.util.List</code> ou array de objetos</td>
            <td>Array de qualquer classe (não pode ser de tipo primitivo) ou
            <code>Collection</code> de qualquer classe</td>
            <td>Apenas array de <code>Integer</code>s (ou de tipo primitivo
            <code>int</code>) ou <code>Collection</code> de
            <code>Integer</code>s</td>
          </tr>
        </table>
      </subsection>
    <p>Abaixo teremos um exemplo do uso da anotação em vários cenários possíveis:</p>
<source>
public class Estado {
   private String sigla;
   private String descricao;

   // getters e setters para as propriedades
}
</source>
<source>
@Form
public class ExemploDataProviderForm {
   private Estado estado;

   public Estado getEstado() {
      return estado;
   }

   public void setEstado(Estado estado) {
      this.estado = estado;
   }

   @DataProvider(objectField="estado")
   public List populaEstados() {
      // retorna uma List contendo instâncias de Estado
   }

   // ...
}
</source>

<p>Considerando o código fonte do Form mostrado acima, criaremos interfaces gráficas
  com diferentes APIs e componentes gráficos:
</p>
  <p><b>Thinlet</b>
    <ul>
      <li><a href="#ThinletComboBox">ComboBox</a></li>
      <li><a href="#ThinletList">List</a></li>
      <li><a href="#ThinletTable">Table</a></li>
    </ul>
  </p>
  <p><b>Swing</b>
    <ul>
      <li><a href="#SwingComboBox">ComboBox</a></li>
      <li><a href="#SwingList">List</a></li>
      <li><a href="#SwingTable">Table</a></li>
    </ul>
  </p>

<subsection name="Thinlet">
  <p><b><a name="ThinletComboBox">ComboBox</a></b></p>
<source>
<![CDATA[
<panel gap="5">
   <label text="Estado:" />
   <combobox name="estado" property="key=sigla;value=descricao" />
</panel>
]]>
</source>
      <p>Acima vemos o xml da tela que exibe um <code>label</code> e
      um <code>combobox</code> que conterá os estados em tempo de execução. A
      propriedade <code>name</code> possui o mesmo valor que o atributo
      <code>objectField</code> da anotação <code>@DataProvider</code>.
      Pode-se notar alguns valores configurados no atributo
      <code>property</code>. Os seguintes valores são utilizados no caso de
      comboboxes:</p>
      <ul>
        <li><b>key</b>: nome da propriedade do bean que será utilizado para
        popular o componente cujo valor é único por instância.  É
        requerido, com exceção das enums (<code>java.lang.Enum</code> ou
        <code>net.java.dev.reusablecomponents.lang.Enum</code>).
        No caso das enums, se essa propriedade
        não é definida, o valor <code>toString()</code> da enum é utilizado.</li>
        <li><b>value</b>: nome da propriedade utilizada para exibir o bean. É
        requerida quando o bean não for uma enum (<code>java.lang.Enum</code> ou
        <code>net.java.dev.reusablecomponents.lang.Enum</code>).</li>
        <li><b>blank</b>: inclui uma linha em branco como primeira opção da
        combobox. Não é requerida e tem como valor padrão <code>false</code>.
        </li>
        <li><b>blankLabel</b>: define o texto a ser exibido na linha em branco.
        Não é requerida, tem como valor padrão uma <code>String</code> vazia e
        só é usada quando <code>blank=true</code>.</li>
      </ul>
      <p>Conforme indicado pelo valor do atributo <code>objectField</code>, a
      propriedade de nome <code>estado</code> do form conterá a 
      instância de <code>Estado</code>
      correspondente à opção da combo escolhida pelo usuário.</p>
  <p><b><a name="ThinletList">List</a></b></p>
<source>
<![CDATA[
<panel gap="5">
   <label text="Estado:" />
   <list name="estado" property="key=sigla;value=descricao" />
</panel>
]]>
</source>
    <p>No caso de uma <code>List</code>, os requerimentos são similares ao do <a href="#ThinletComboBox">ComboBox</a>.</p>
  <p><b><a name="ThinletTable">Table</a></b></p>
<source>
<![CDATA[
<panel gap="5">
   <table name="estado">
      <header>
         <column name="sigla" text="Sigla" />
         <column name="descricao" text="Descrição" />
      </header>
   </table>
</panel>
]]>
</source>
      <p>Os requerimentos para popular uma table são um pouco diferentes.</p>
      <p>Com base no exemplo acima, podemos observar que o valor de <code>name
      </code> na tabela precisa ser igual ao valor do atributo
      <code>objectField</code>, exceto quando for especificado o atributo
      <code>widgetName</code> na anotação, e nesse caso o valor de <code>widgetName</code>
      deve ser o nome do componente.
      Cada linha da tabela representará uma instância e cada
      coluna será preenchida com a propriedade do bean cujo nome é o valor de
      <code>name</code> em cada uma delas.</p>
      <p>Uma variação desta anotação ocorre com a utilização do atributo
      <code>callOnInit</code>. Suponha que o <code>combobox</code> ou a
      <code>table</code> dos exemplos acima <b>não devam ser preenchidas</b> na
      inicialização da janela em questão. Neste caso, a anotação deverá ser
      reescrita da seguinte forma:</p>
<source>
   // ...

   @DataProvider(objectField="estado", callOnInit=false)
   public List populaEstados() {
      // retorna uma Collection contendo instâncias de Estado
         }
    
   // ...
</source>

      <p>Desta forma, na inicialização da janela, os widgets
      <code>combobox</code> ou <code>list</code> ou <code>table</code>
      estarão vazios. O preenchimento dos mesmos poderá ser acionado mediante
      a anotação
      <code>@CallWhen</code>. Isto é, a anotação <code>@CallWhen</code> pode ser
      usada em conjunto com <code>@DataProvider</code> para
      indicar sob que condição a tabela/lista/combo
      será repopulada. <code>@Action</code> pode ser usado no mesmo método caso
      este também possa ser acionado por um botão (como Pesquisar, por exemplo)
      e, quando isso ocorrer, o uso de <code>@EnabledWhen</code> e
      <code>@VisibleWhen</code> também será possível.</p>
      <p>O atributo <code>resetSelection</code> determina se os elementos serão
      desselecionados quando o método for invocado. Este é o comportamento
      padrão, ou seja, se omitido, o valor desse atributo é considerado
      <code>true</code>. Quando o valor informado é <code>false</code>, a
      seleção é mantida com respeito a <b>posição</b> dos ítens, o que torna
      essa funcionalidade mais útil quando algo está sendo adicionado ao final
      da <code>java.util.List</code> ou array cada vez que o método é
      executado.</p>
</subsection>
<subsection name="Swing">
  <p><b><a name="SwingComboBox">ComboBox</a></b></p>
<source>
<![CDATA[
private JComboBox estadoComboBox;
  ...
  private initComponents() {
     ...
     stateComboBox = new JComboBox();
     stateComboBox.setName("estado");
     stateComboBox.putClientProperty(SwingBinder.KEY_PROPERTY, "sigla");
     stateComboBox.putClientProperty(SwingBinder.VALUE_PROPERTY, "descricao");
     stateComboBox.setRenderer(new KeyValueListCellRenderer(stateComboBox));
  }
]]>
</source>
      <p>Acima vemos o código da tela que exibe um <code>combobox</code>
      que conterá os estados em tempo de execução. O nome do componente
      (<code>stateComboBox.setName("estado")</code>) possui o mesmo valor
      que o atributo <code>objectField</code> da anotação <code>@DataProvider</code>.
      Para que ao popular o ComboBox, os valores sejam mostrados corretamente
      ao usuário é necessário configurar algumas propriedades do componente e
      utilizar a classe <code>net.java.dev.genesis.ui.swing.renderers.KeyValueListCellRenderer</code>
      como Renderer do componente. Tal classe verifica os valores configurados
      na propriedade do componente para saber qual propriedade do Bean deve
      ser visível para o usuário. Os valores das propriedades são configuradas
      através do método <code>putClientProperty(Object chave, Object valor)</code>
      do componente.
      As seguintes propriedades são utilizadas no caso de comboboxes:</p>
      <ul>
        <li><b>SwingBinder.KEY_PROPERTY</b>: nome da propriedade do bean que será
        utilizado para popular o componente cujo valor é único por instância. É
        requerido, com exceção das enums (<code>java.lang.Enum</code> ou
        <code>net.java.dev.reusablecomponents.lang.Enum</code>).
        No caso das enums, se essa propriedade
        não é definida, o valor <code>toString()</code> da enum é utilizado.</li>
        <li><b>SwingBinder.VALUE_PROPERTY</b>: nome da propriedade utilizada
        para exibir o bean. É requerida quando o bean não for uma enum
        (<code>java.lang.Enum</code> ou
        <code>net.java.dev.reusablecomponents.lang.Enum</code>).</li>
        <li><b>SwingBinder.BLANK_PROPERTY</b>: inclui uma linha em branco
        como primeira opção da
        combobox. Não é requerida e tem como valor padrão <code>false</code>.
        </li>
        <li><b>SwingBinder.BLANK_LABEL_PROPERTY</b>: define o texto a
        ser exibido na linha em branco.
        Não é requerida, tem como valor padrão uma <code>String</code> vazia e
        só é usada quando <code>SwingBinder.BLANK_PROPERTY</code> é
        <code>true</code>.</li>
      </ul>
      <p>Conforme indicado pelo valor do atributo <code>objectField</code>, a
      propriedade de nome <code>estado</code> do form conterá a 
      instância de <code>Estado</code>
      correspondente à opção da combo escolhida pelo usuário.</p>
      <p>Para facilitar a construção, pode-se utilizar métodos estáticos da classe
      <code>net.java.dev.genesis.ui.swing.factory.SwingFactory</code>. O código
      para criação e configuração do ComboBox seria:</p>
<source>
<![CDATA[
private SwingBinder binder;
private JComboBox estadoComboBox;
  ...
  private initComponents() {
     ...
     stateComboBox = SwingFactory.createComboBox(binder, "estado", "sigla", "descricao");
  }
]]>
</source>
      <p>No código acima, construímos um ComboBox passando como parâmetros
      o binder, o nome do componente, o nome da propriedade chave
      (<code>SwingBinder.KEY_PROPERTY</code>) e o nome
      da propriedade value (<code>SwingBinder.VALUE_PROPERTY</code>)
      respectivamente.</p>
      <p><b><a name="SwingList">List</a></b></p>
<source>
<![CDATA[
private JList estadoList;
  ...
  private initComponents() {
     ...
     estadoList = new JList();
     estadoList.setName("estado");
     estadoList.putClientProperty(SwingBinder.KEY_PROPERTY, "sigla");
     estadoList.putClientProperty(SwingBinder.VALUE_PROPERTY, "descricao");
     estadoList.setRenderer(new KeyValueListCellRenderer(stateComboBox));
  }
]]>
</source>
      <p>No caso de uma <code>List</code>, os requerimentos são similares ao do <a href="#SwingComboBox">ComboBox</a>.</p>
      
  <p><b><a name="SwingTable">Table</a></b></p>
<source>
<![CDATA[
private JTable estadoTable;
  ...
  private initComponents() {
     ...

     TableColumnModel columnModel = new DefaultTableColumnModel();
     TableModel model = new DefaultTableModel();

     TableColumn siglaColumn = new TableColumn(0);
     siglaColumn.setIdentifier("sigla");
     siglaColumn.setHeaderValue("Sigla");
     columnModel.addColumn(siglaColumn);

     TableColumn descricaoColumn = new TableColumn(1);
     descricaoColumn.setIdentifier("descricao");
     descricaoColumn.setHeaderValue("Descrição");
     columnModel.addColumn(descricaoColumn);

     estadoTable = new JTable(model, columnModel);
     estadoTable.setName("estado");
  }
]]>
</source>
      <p>Os requerimentos para popular uma table são um pouco diferentes.</p>
      <p>Com base no exemplo acima, podemos observar que o nome do componente
      (<code>estadoTable.setName("estado")</code>)
      na tabela precisa ser igual ao valor do atributo
      <code>objectField</code>, exceto quando for especificado o atributo
      <code>widgetName</code> na anotação, e nesse caso o valor de <code>widgetName</code>
      deve ser o nome do componente.
      Cada linha da tabela representará uma instância e cada
      coluna será preenchida com a propriedade do bean cujo nome é o valor do
      <code>identifier</code> (e.g.: <code>descricaoColumn.setIdentifier("descricao")</code>)
      em cada uma das TableColumn. É possível definir o identifier de cada coluna de outra forma
      mais fácil, através do método <code>putClientProperty</code>:</p>
<source>
<![CDATA[
private JTable estadoTable;
  ...
  private initComponents() {
     ...
     estadoTable = new JTable(new DefaultTableModel(new String[] {"Sigla", "Descrição"}), 0);
     estadoTable.setName("estado");
     estadoTable.putClientProperty(SwingBinder.COLUMN_NAMES, new String[] {"sigla", "descricao"});
  }
]]>
</source>
      <p>Para facilitar a construção, pode-se utilizar métodos estáticos da classe
      <code>net.java.dev.genesis.ui.swing.factory.SwingFactory</code>. O código
      para criação e configuração da Table seria:</p>
<source>
<![CDATA[
private SwingBinder binder;
private JTable estadoTable;
  ...
  private initComponents() {
     ...
     estadoTable = SwingFactory.createTable(binder, "estado",
          new String[] {"sigla", "descricao" },
          new String[] {"Sigla", "Descrição" });
  }
]]>
</source>
      <p>No código acima, construímos uma Table passando como parâmetros
      o binder, o nome do componente, um array dos <code>identifier</code>s
      de cada coluna e um array para os textos visíveis para cada coluna
      respectivamente.</p>
  </subsection>
</section>
<section name="Referências">
      <p>Anotação <a href="quick_reference.html#@DataProvider">@DataProvider</a></p>
</section>
  </body>
</document>