/* * The Genesis Project * Copyright (C) 2005-2006  Summa Technologies do Brasil Ltda. * * This library is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation; either * version 2.1 of the License, or (at your option) any later version. * * This library is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the Free Software * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */package net.java.dev.genesis.anttasks.aspectwerkz;import java.io.File;import java.lang.reflect.Method;import java.net.MalformedURLException;import java.net.URL;import java.net.URLClassLoader;import java.util.Arrays;import java.util.Hashtable;import java.util.List;import java.util.Set;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.DirectoryScanner;import org.apache.tools.ant.taskdefs.MatchingTask;import org.apache.tools.ant.types.Path;import org.apache.tools.ant.types.Reference;import org.apache.tools.ant.types.Resource;import org.apache.tools.ant.util.FileUtils;import org.apache.tools.ant.util.IdentityMapper;import org.apache.tools.ant.util.SourceFileScanner;import org.codehaus.aspectwerkz.definition.DefinitionLoader;import org.codehaus.aspectwerkz.definition.SystemDefinitionContainer;import org.codehaus.aspectwerkz.hook.ClassPreProcessor;public class SimplifiedAspectWerkzCTask extends MatchingTask {   private static boolean isAW2;   static {      try {         Class.forName("org.codehaus.aspectwerkz.AspectContext");         isAW2 = true;      } catch (ClassNotFoundException e) {         isAW2 = false;      }   }   public final static String AW_TRANSFORM_VERBOSE = "aspectwerkz.transform.verbose";   public final static String AW_TRANSFORM_DETAILS = "aspectwerkz.transform.details";   private static final String AW_DEFINITION_FILE = "aspectwerkz.definition.file";   private final FileUtils fileUtils = FileUtils.newFileUtils();   private File[] compileList = new File[0];   private boolean verbose;   private boolean taskverbose;   private String preProcessorName = "org.codehaus.aspectwerkz.transform.AspectWerkzPreProcessor";   private File definitionFile;   private Path classpath;   private Path src;   private File destDir;   private boolean genjp;   private String[] expandedSources;   private File[] expandedSourcesDir;   private File[] srcDirs = new File[0];   private URL[] urls;   public void setDefinition(File defFile) {      definitionFile = defFile;   }   public void setVerbose(boolean verbose) {      this.verbose = verbose;   }   public void setTaskverbose(boolean taskverbose) {      this.taskverbose = taskverbose;   }   public void setDestdir(File destDir) {      this.destDir = destDir;   }   public Path createSrc() {      if (src == null) {         src = new Path(getProject());      }      return src.createPath();   }   public void setSrcdir(Path srcDir) {      if (src == null) {         src = srcDir;      } else {         src.append(srcDir);      }   }   public void setSourcepath(Path sourcepath) {      if (src == null) {         src = sourcepath;      } else {         src.append(sourcepath);      }   }   public Path createSourcepath() {      if (src == null) {         src = new Path(getProject());      }      return src.createPath();   }   public void setSourcepathRef(Reference r) {      createSourcepath().setRefid(r);   }   public void setPreprocessor(String preprocessorFqn) {      preProcessorName = preprocessorFqn;   }   public void setClasspath(Path classpath) {      if (classpath == null) {         this.classpath = classpath;      } else {         this.classpath.append(classpath);      }   }   public Path createClasspath() {      if (classpath == null) {         classpath = new Path(getProject());      }      return classpath.createPath();   }   public void setClasspathRef(Reference r) {      createClasspath().setRefid(r);   }   public void setGenjp(boolean genjp) {      this.genjp = genjp;   }   protected void checkParameters() throws BuildException {      expandedSources = src == null ? null : src.list();      if (definitionFile != null && !definitionFile.isFile()) {         throw new BuildException("Definition file provided does not exists",               getLocation());      }      if (expandedSources == null || expandedSources.length == 0) {         throw new BuildException("srcdir attribute must be set!",               getLocation());      }      if (destDir == null || !destDir.isDirectory()) {         throw new BuildException("destdir provided is not a valid directory",               getLocation());      }   }   protected long getAOPXMLLastModified() {      long lastModified = 0;      expandedSourcesDir = new File[expandedSources.length];      for (int i = 0; i < expandedSources.length; i++) {         expandedSourcesDir[i] = getProject().resolveFile(expandedSources[i]);         if (!expandedSourcesDir[i].exists()) {            throw new BuildException("srcdir \""                  + expandedSourcesDir[i].getPath() + "\" does not exist!",                  getLocation());         }         File definitionMETAINF = new File(expandedSourcesDir[i]               .getAbsolutePath()               + File.separatorChar               + "META-INF"               + File.separatorChar               + "aop.xml");         File definitionWEBINF = new File(expandedSourcesDir[i]               .getAbsolutePath()               + File.separatorChar               + "WEB-INF"               + File.separatorChar               + "aop.xml");         if (definitionMETAINF.isFile()) {            lastModified = Math.max(lastModified, definitionMETAINF                  .lastModified());         }         if (definitionWEBINF.isFile()) {            lastModified = Math.max(lastModified, definitionWEBINF                  .lastModified());         }      }      return lastModified;   }   protected long getClassPathLastModified() {      try {         long lastModified = Math.max(getAOPXMLLastModified(),               definitionFile == null ? 0 : definitionFile.lastModified());         String[] list = classpath.list();         urls = new URL[list.length + expandedSources.length];         int i = 0;         int k = 0;         for (; k < expandedSourcesDir.length; k++, i++) {            urls[k] = fileUtils.getFileURL(expandedSourcesDir[i]);         }         i = 0;         for (; i < list.length; i++, k++) {            File dir = getProject().resolveFile(list[i]);            urls[k] = fileUtils.getFileURL(dir);            if (!dir.exists()) {               continue;            }            if (!dir.isDirectory()) {               if (isJar(dir)) {                  lastModified = Math.max(lastModified, dir.lastModified());               }               continue;            }            DirectoryScanner ds = this.getDirectoryScanner(dir);            String[] files = ds.getIncludedFiles();            for (int j = 0; j < files.length; j++) {               File file = fileUtils.resolveFile(ds.getBasedir(), files[j]);               if (isJar(file)) {                  lastModified = Math.max(lastModified, file.lastModified());               }            }         }         return lastModified;      } catch (MalformedURLException e) {         throw new BuildException(e.getMessage(), e);      }   }   protected boolean isJar(File file) {      final String name = file.getName().toLowerCase();      return name.endsWith(".jar") || name.endsWith(".zip");   }   protected void scanDir(final File srcDir, final File destDir,         final String[] files, final long lastModified) {      IdentityMapper m = new IdentityMapper();      SourceFileScanner sfs = new SourceFileScanner(this) {         public Resource getResource(String name) {            File src = fileUtils.resolveFile(destDir, name);            long srcLastModified = src.lastModified();            return new Resource(name, src.exists(),                  (lastModified > srcLastModified ? 0 : srcLastModified), src                        .isDirectory());         }      };      File[] newFiles = sfs.restrictAsFiles(files, srcDir, destDir, m);      if (newFiles.length > 0) {         File[] newCompileList = new File[compileList.length + newFiles.length];         System               .arraycopy(compileList, 0, newCompileList, 0, compileList.length);         System.arraycopy(newFiles, 0, newCompileList, compileList.length,               newFiles.length);         compileList = newCompileList;         File[] newSrcList = new File[newCompileList.length];         System.arraycopy(srcDirs, 0, newSrcList, 0, srcDirs.length);         Arrays.fill(newSrcList, srcDirs.length, newSrcList.length, srcDir);         srcDirs = newSrcList;      }   }   public void execute() throws BuildException {      checkParameters();      long lastModified = getClassPathLastModified();      for (int i = 0; i < expandedSourcesDir.length; i++) {         DirectoryScanner ds = this.getDirectoryScanner(expandedSourcesDir[i]);         String[] files = ds.getIncludedFiles();         scanDir(expandedSourcesDir[i], destDir, files, lastModified);      }      if (compileList.length == 0) {         return;      }      compile();   }   protected void compile() {      log("Weaving " + compileList.length + " class"            + (compileList.length == 1 ? "" : "es")            + (destDir != null ? " to " + destDir : ""));      if (definitionFile != null) {         System.setProperty(AW_DEFINITION_FILE, definitionFile               .getAbsolutePath());      }      try {         AspectWerkzCompiler compiler = getCompiler();         if (verbose) {            compiler.setVerbose(true);         }                  ClassLoader loader = new URLClassLoader(urls, false ? ClassLoader               .getSystemClassLoader() : getClass().getClassLoader());         Thread.currentThread().setContextClassLoader(loader);         SystemDefinitionContainer.disableSystemWideDefinition();         Method method = DefinitionLoader.class.getMethod(               "getDefaultDefinition", new Class[] { ClassLoader.class });         Object result = method.invoke(null, new Object[] {loader});         String methodName = isAW2 ? "deployDefinitions"               : "deploySystemDefinitions";         Class[] argsClass = isAW2 ? new Class[] { ClassLoader.class, Set.class }               : new Class[] { ClassLoader.class, List.class };         method = SystemDefinitionContainer.class.getMethod(methodName,               argsClass);         method.invoke(null, new Object[] { loader, result });         ClassPreProcessor preprocessor = (ClassPreProcessor) Class.forName(               preProcessorName).newInstance();         argsClass = isAW2 ? new Class[0] : new Class[] { Hashtable.class };         Object[] args = isAW2 ? new Object[0] : new Object[] { null };         method = preprocessor.getClass().getMethod("initialize", argsClass);         method.invoke(preprocessor, args);         for (int i = 0; i < compileList.length; i++) {            File file = compileList[i];            File destFile = new File(destDir.getAbsolutePath()                  + File.separatorChar                  + fileUtils.removeLeadingPath(srcDirs[i], file));            if (!destFile.exists()) {               destFile.getParentFile().mkdirs();            }            if (file.getName().endsWith(".class")) {               File parentFile = file.getParentFile();               String packageName = parentFile == null ? "" : fileUtils                     .removeLeadingPath(srcDirs[i], parentFile).replace(                           File.separatorChar, '.');               if (taskverbose) {                  log("Weaving " + file.getAbsolutePath());               }               compiler.compileClass(destDir, file, destFile, packageName,                     loader, preprocessor);               continue;            }            fileUtils.copyFile(file, destFile);         }      } catch (BuildException be) {         throw be;      } catch (Exception ex) {         throw new BuildException("weaving failed", ex, getLocation());      }   }   protected AspectWerkzCompiler getCompiler() {      if (isAW2) {         final AspectWerkzCompiler compiler = new AspectWerkzCompiler2x(this);         if (genjp) {            compiler.setAttribute("genjp", Boolean.TRUE);         }         return compiler;      }      return new AspectWerkzCompiler1x(this);   }}