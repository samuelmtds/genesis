/* * The Genesis Project * Copyright (C) 2005  Summa Technologies do Brasil Ltda. * * This library is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation; either * version 2.1 of the License, or (at your option) any later version. * * This library is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the Free Software * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */package net.java.dev.genesis.anttasks.aspectwerkz;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.net.MalformedURLException;import java.net.URL;import java.net.URLClassLoader;import java.util.Arrays;import java.util.Hashtable;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.DirectoryScanner;import org.apache.tools.ant.Project;import org.apache.tools.ant.taskdefs.MatchingTask;import org.apache.tools.ant.types.Path;import org.apache.tools.ant.types.Reference;import org.apache.tools.ant.types.Resource;import org.apache.tools.ant.util.FileUtils;import org.apache.tools.ant.util.IdentityMapper;import org.apache.tools.ant.util.SourceFileScanner;import org.codehaus.aspectwerkz.compiler.CompileException;import org.codehaus.aspectwerkz.definition.DefinitionLoader;import org.codehaus.aspectwerkz.definition.SystemDefinitionContainer;import org.codehaus.aspectwerkz.hook.ClassPreProcessor;public class SimplifiedAspectWerkzCTask extends MatchingTask {   private final static String AW_TRANSFORM_VERBOSE = "aspectwerkz.transform.verbose";   private static final String AW_DEFINITION_FILE = "aspectwerkz.definition.file";   private final FileUtils fileUtils = FileUtils.newFileUtils();   private File[] compileList = new File[0];   private boolean verbose;   private boolean taskverbose;   private String preProcessorName = "org.codehaus.aspectwerkz.transform.AspectWerkzPreProcessor";   private File definitionFile;   private Path classpath;   private Path src;   private File destDir;   private String[] expandedSources;   private File[] expandedSourcesDir;   private File[] srcDirs = new File[0];   private URL[] urls;   public void setDefinition(File defFile) {      definitionFile = defFile;   }   public void setVerbose(boolean verbose) {      this.verbose = verbose;   }   public void setTaskverbose(boolean taskverbose) {      this.taskverbose = taskverbose;   }   public void setDestdir(File destDir) {      this.destDir = destDir;   }   public Path createSrc() {      if (src == null) {         src = new Path(getProject());      }      return src.createPath();   }   public void setSrcdir(Path srcDir) {      if (src == null) {         src = srcDir;      } else {         src.append(srcDir);      }   }   public void setSourcepath(Path sourcepath) {      if (src == null) {         src = sourcepath;      } else {         src.append(sourcepath);      }   }   public Path createSourcepath() {      if (src == null) {         src = new Path(getProject());      }      return src.createPath();   }   public void setSourcepathRef(Reference r) {      createSourcepath().setRefid(r);   }   public void setPreprocessor(String preprocessorFqn) {      preProcessorName = preprocessorFqn;   }   public void setClasspath(Path classpath) {      if (classpath == null) {         this.classpath = classpath;      } else {         this.classpath.append(classpath);      }   }   public Path createClasspath() {      if (classpath == null) {         classpath = new Path(getProject());      }      return classpath.createPath();   }   public void setClasspathRef(Reference r) {      createClasspath().setRefid(r);   }   protected void checkParameters() throws BuildException {      expandedSources = src == null ? null : src.list();      if (definitionFile != null && !definitionFile.isFile()) {         throw new BuildException("Definition file provided does not exists",               getLocation());      }      if (expandedSources == null || expandedSources.length == 0) {         throw new BuildException("srcdir attribute must be set!",               getLocation());      }      if (destDir == null || !destDir.isDirectory()) {         throw new BuildException("destdir provided is not a valid directory",               getLocation());      }   }   protected long getAOPXMLLastModified() {      long lastModified = 0;      expandedSourcesDir = new File[expandedSources.length];      for (int i = 0; i < expandedSources.length; i++) {         expandedSourcesDir[i] = getProject().resolveFile(expandedSources[i]);         if (!expandedSourcesDir[i].exists()) {            throw new BuildException("srcdir \""                  + expandedSourcesDir[i].getPath() + "\" does not exist!",                  getLocation());         }         File definitionMETAINF = new File(expandedSourcesDir[i]               .getAbsolutePath()               + File.separatorChar               + "META-INF"               + File.separatorChar               + "aop.xml");         File definitionWEBINF = new File(expandedSourcesDir[i]               .getAbsolutePath()               + File.separatorChar               + "WEB-INF"               + File.separatorChar               + "aop.xml");         if (definitionMETAINF.isFile()) {            lastModified = Math.max(lastModified, definitionMETAINF                  .lastModified());         }         if (definitionWEBINF.isFile()) {            lastModified = Math.max(lastModified, definitionWEBINF                  .lastModified());         }      }      return lastModified;   }   protected long getClassPathLastModified() {      try {         long lastModified = Math.max(getAOPXMLLastModified(),               definitionFile == null ? 0 : definitionFile.lastModified());         String[] list = classpath.list();         urls = new URL[list.length + expandedSources.length];         int i = 0;         for (; i < list.length; i++) {            File dir = getProject().resolveFile(list[i]);            if (!dir.exists()) {               throw new BuildException("dir \"" + dir.getPath()                     + "\" does not exist!", getLocation());            }            urls[i] = fileUtils.getFileURL(dir);            if (!dir.isDirectory()) {               if (isJar(dir)) {                  lastModified = Math.max(lastModified, dir.lastModified());               }               continue;            }            DirectoryScanner ds = this.getDirectoryScanner(dir);            String[] files = ds.getIncludedFiles();            for (int j = 0; j < files.length; j++) {               File file = fileUtils.resolveFile(ds.getBasedir(), files[j]);               if (isJar(file)) {                  lastModified = Math.max(lastModified, file.lastModified());               }            }         }         for (int k = 0; k < expandedSourcesDir.length; k++, i++) {            urls[i] = fileUtils.getFileURL(expandedSourcesDir[k]);         }         return lastModified;      } catch (MalformedURLException e) {         throw new BuildException(e.getMessage(), e);      }   }   protected boolean isJar(File file) {      final String name = file.getName().toLowerCase();      return name.endsWith(".jar") || name.endsWith(".zip");   }   protected void scanDir(final File srcDir, final File destDir,         final String[] files, final long lastModified) {      IdentityMapper m = new IdentityMapper();      SourceFileScanner sfs = new SourceFileScanner(this) {         public Resource getResource(String name) {            File src = fileUtils.resolveFile(destDir, name);            long srcLastModified = src.lastModified();            return new Resource(name, src.exists(),                  (lastModified > srcLastModified ? 0 : srcLastModified), src                        .isDirectory());         }      };      File[] newFiles = sfs.restrictAsFiles(files, srcDir, destDir, m);      if (newFiles.length > 0) {         File[] newCompileList = new File[compileList.length + newFiles.length];         System               .arraycopy(compileList, 0, newCompileList, 0, compileList.length);         System.arraycopy(newFiles, 0, newCompileList, compileList.length,               newFiles.length);         compileList = newCompileList;         File[] newSrcList = new File[newCompileList.length];         System.arraycopy(srcDirs, 0, newSrcList, 0, srcDirs.length);         Arrays.fill(newSrcList, srcDirs.length, newSrcList.length, srcDir);         srcDirs = newSrcList;      }   }   public void execute() throws BuildException {      checkParameters();      long lastModified = getClassPathLastModified();      for (int i = 0; i < expandedSourcesDir.length; i++) {         DirectoryScanner ds = this.getDirectoryScanner(expandedSourcesDir[i]);         String[] files = ds.getIncludedFiles();         scanDir(expandedSourcesDir[i], destDir, files, lastModified);      }      if (compileList.length == 0) {         return;      }      compile();   }   protected void compile() {      log("Weaving " + compileList.length + " class"            + (compileList.length == 1 ? "" : "es")            + (destDir != null ? " to " + destDir : ""));      if (definitionFile != null) {         System.setProperty(AW_DEFINITION_FILE, definitionFile               .getAbsolutePath());      }      if (verbose) {         System.setProperty(AW_TRANSFORM_VERBOSE, verbose ? "true" : "false");      }      try {         ClassLoader loader = new URLClassLoader(urls, getClass()               .getClassLoader());         Thread.currentThread().setContextClassLoader(loader);         SystemDefinitionContainer.disableSystemWideDefinition();         SystemDefinitionContainer.deploySystemDefinitions(loader,               DefinitionLoader.getDefaultDefinition(loader));         ClassPreProcessor preprocessor = (ClassPreProcessor) Class.forName(               preProcessorName).newInstance();         preprocessor.initialize(new Hashtable());         for (int i = 0; i < compileList.length; i++) {            File file = compileList[i];            File destFile = new File(destDir.getAbsolutePath()                  + File.separatorChar                  + fileUtils.removeLeadingPath(srcDirs[i], file));            if (!destFile.exists()) {               destFile.getParentFile().mkdirs();            }            if (file.getName().endsWith(".class")) {               compileClass(srcDirs[i], file, destFile, loader, preprocessor);               continue;            }            fileUtils.copyFile(file, destFile);         }      } catch (BuildException be) {         throw be;      } catch (Exception ex) {         throw new BuildException("weaving failed", ex, getLocation());      }   }   protected void compileClass(File baseDir, File file, File destFile,         ClassLoader loader, ClassPreProcessor preProcessor)         throws CompileException {      if (taskverbose) {         log("Weaving " + file.getAbsolutePath());      }      InputStream in = null;      OutputStream os = null;      int fileSize = (int) file.length();      // Dont work for files larger than 2 Gb :-p      try {         in = new FileInputStream(file);         byte[] buffer = new byte[fileSize];         in.read(buffer);         // rebuild className         File parentFile = file.getParentFile();         String packageName = parentFile == null ? "" : fileUtils               .removeLeadingPath(baseDir, parentFile).replace(                     File.separatorChar, '.');         String className = packageName + '.'               + file.getName().substring(0, file.getName().length() - 6);         // transform         byte[] transformed = preProcessor               .preProcess(className, buffer, loader);         // write new file         os = new FileOutputStream(destFile);         os.write(transformed);      } catch (Exception e) {         throw new BuildException("weaving " + file.getAbsolutePath()               + " failed", e, getLocation());      } finally {         try {            in.close();         } catch (Throwable e) {            log(e.getMessage(), Project.MSG_ERR);         }         try {            os.close();         } catch (Throwable e) {            log(e.getMessage(), Project.MSG_ERR);         }      }   }}